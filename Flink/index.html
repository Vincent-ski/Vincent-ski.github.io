<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/cute.jpeg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/cute.jpeg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/cute.jpeg">
  <link rel="mask-icon" href="/images/cute.jpeg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Flink从入门到大神">
<meta property="og:type" content="article">
<meta property="og:title" content="Flink">
<meta property="og:url" content="http://example.com/Flink/index.html">
<meta property="og:site_name" content="Vincent&#39;s Learning Journey">
<meta property="og:description" content="Flink从入门到大神">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8A%E5%8D%8811.27.50.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8A%E5%8D%8811.41.01.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8A%E5%8D%8811.44.13.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8A%E5%8D%8811.51.54.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8B%E5%8D%881.45.50.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8B%E5%8D%882.20.24.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8B%E5%8D%882.26.46.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8B%E5%8D%882.28.07.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8B%E5%8D%882.41.21.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8B%E5%8D%884.36.32.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8B%E5%8D%885.01.43.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8B%E5%8D%885.28.05.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8B%E5%8D%889.46.48.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8B%E5%8D%8810.22.59.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8B%E5%8D%8810.35.04.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-03-23%20%E4%B8%8B%E5%8D%883.31.54.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-03-23%20%E4%B8%8B%E5%8D%888.50.24.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-03-25%20%E4%B8%8A%E5%8D%8812.08.27.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-03-25%20%E4%B8%8A%E5%8D%889.56.19.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-03-25%20%E4%B8%8A%E5%8D%8811.24.56.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-03-25%20%E4%B8%8B%E5%8D%883.47.50.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-03-25%20%E4%B8%8B%E5%8D%883.48.55.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-03-28%20%E4%B8%8B%E5%8D%883.40.58.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-07-11%20%E4%B8%8B%E5%8D%883.02.09.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-07-11%20%E4%B8%8B%E5%8D%883.09.55.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-07-11%20%E4%B8%8B%E5%8D%883.12.40.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-07-11%20%E4%B8%8B%E5%8D%883.32.10.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-07-11%20%E4%B8%8B%E5%8D%883.35.06.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-07-11%20%E4%B8%8B%E5%8D%883.35.40.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-07-11%20%E4%B8%8B%E5%8D%884.33.23.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-07-11%20%E4%B8%8B%E5%8D%884.35.15.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-07-11%20%E4%B8%8B%E5%8D%884.36.20.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-07-11%20%E4%B8%8B%E5%8D%884.37.24.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-07-11%20%E4%B8%8B%E5%8D%884.39.01.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-07-18%20%E4%B8%8B%E5%8D%885.10.28.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-07-18%20%E4%B8%8B%E5%8D%888.23.04.png">
<meta property="article:published_time" content="2021-12-17T10:35:47.000Z">
<meta property="article:modified_time" content="2022-07-18T16:29:17.017Z">
<meta property="article:author" content="Vincent">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8A%E5%8D%8811.27.50.png">

<link rel="canonical" href="http://example.com/Flink/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Flink | Vincent's Learning Journey</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Vincent's Learning Journey</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">DayDayUp</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section">Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section">Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section">Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger">Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/Flink/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cute.jpeg">
      <meta itemprop="name" content="Vincent">
      <meta itemprop="description" content="nice">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vincent's Learning Journey">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Flink
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-12-17 18:35:47" itemprop="dateCreated datePublished" datetime="2021-12-17T18:35:47+08:00">2021-12-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-07-19 00:29:17" itemprop="dateModified" datetime="2022-07-19T00:29:17+08:00">2022-07-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AE%9E%E6%97%B6%E8%AE%A1%E7%AE%97/" itemprop="url" rel="index"><span itemprop="name">实时计算</span></a>
                </span>
            </span>

          
            <div class="post-description">Flink从入门到大神</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="Flink概述"><a href="#Flink概述" class="headerlink" title="Flink概述"></a>Flink概述</h2><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>1、高吞吐和低延迟。每秒处理数百万个事件，毫秒级延迟。</p>
<p>2、结果的准确性。Flink 提供了事件时间(event-time)和处理时间(processing-time) 语义。对于乱序事件流，事件时间语义仍然能提供一致且准确的结果。</p>
<p>3、精确一次(exactly-once)的状态一致性保证。</p>
<p>4、可以连接到最常用的存储系统，如 Apache Kafka、Apache Cassandra、Elasticsearch、JDBC、Kinesis 和(分布式)文件系统，如 HDFS 和 S3。</p>
<p>5、高可用。本身高可用的设置，加上与K8s，YARN和Mesos的紧密集成，再加上从故障中快速恢复和动态扩展任务的能力，Flink 能做到以极少的停机时间 7×24 全天候运行。</p>
<p>6、能够更新应用程序代码并将作业(jobs)迁移到不同的 Flink 集群，而不会丢失应用程序的状态。</p>
<h3 id="分层API"><a href="#分层API" class="headerlink" title="分层API"></a>分层API</h3><p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8A%E5%8D%8811.27.50.png" alt="截屏2022-03-22 上午11.27.50"></p>
<h3 id="部署模式"><a href="#部署模式" class="headerlink" title="部署模式"></a>部署模式</h3><p>它们的区别主要在于：集群的生命周期以及资源的分配方式；以及应用的 main 方法到底在哪里执行——客户端(Client)还是 JobManager。</p>
<h4 id="会话模式-Session-Mode"><a href="#会话模式-Session-Mode" class="headerlink" title="会话模式(Session Mode)"></a>会话模式(Session Mode)</h4><p>集群启动时所有资源就都已经确定，所以所有提交的作业会竞争集群中的资源。会话模式比较适合于单个规模小、执行时间短的大量作业。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8A%E5%8D%8811.41.01.png" alt="截屏2022-03-22 上午11.41.01"></p>
<p>这样的好处很明显，我们只需要一个集群，就像一个大箱子，所有的作业提交之后都塞进去；集群的生命周期是超越于作业之上的，铁打的营盘流水的兵，作业结束了就释放资源，集群依然正常运行。当然缺点也是显而易见的：因为资源是共享的，所以资源不够了，提交新的作业就会失败。另外，同一个 TaskManager 上可能运行了很多作业，如果其中一个发生故障导致 TaskManager 宕机，那么所有作业都会受到影响。</p>
<h4 id="单作业模式-Per-Job-Mode"><a href="#单作业模式-Per-Job-Mode" class="headerlink" title="单作业模式(Per-Job Mode)"></a>单作业模式(Per-Job Mode)</h4><p>会话模式因为资源共享会导致很多问题，所以为了更好地隔离资源，我们可以考虑为每个提交的作业启动一个集群，这就是所谓的单作业(Per-Job)模式。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8A%E5%8D%8811.44.13.png" alt="截屏2022-03-22 上午11.44.13"></p>
<p>单作业模式也很好理解，就是严格的一对一，集群只为这个作业而生。同样由客户端运行应用程序，然后启动集群，作业被提交给 JobManager，进而分发给 TaskManager 执行。作业完成后，集群就会关闭，所有资源也会释放。这样一来，每个作业都有它自己的 JobManager 管理，占用独享的资源，即使发生故障，它的 TaskManager 宕机也不会影响其他作业。</p>
<p>这些特性使得单作业模式在生产环境运行更加稳定，所以是实际应用的首选模式。</p>
<p>需要注意的是，Flink 本身无法直接这样运行，所以单作业模式一般需要借助一些资源管理框架来启动集群，比如 YARN、Kubernetes。</p>
<h4 id="应用模式-Application-Mode"><a href="#应用模式-Application-Mode" class="headerlink" title="应用模式(Application Mode)"></a>应用模式(Application Mode)</h4><p>前面提到的两种模式下，应用代码都是在客户端上执行，然后由客户端提交给 JobManager 的。但是这种方式客户端需要占用大量网络带宽，去下载依赖和把二进制数据发送给 JobManager；加上很多情况下我们提交作业用的是同一个客户端，就会加重客户端所在节点的资源消耗。</p>
<p>所以解决办法就是，我们<strong>不要客户端</strong>了，直接把应用提交到 JobManger 上运行。而这也就代表着，我们需要为每一个提交的应用单独启动一个JobManager，也就是创建一个集群。这个 JobManager 只为执行这一个应用而存在，执行结束之后 JobManager 也就关闭了，这就是所谓的应用模式。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8A%E5%8D%8811.51.54.png" alt="截屏2022-03-22 上午11.51.54"></p>
<p>应用模式与单作业模式，都是提交作业之后才创建集群；单作业模式是通过客户端来提交的，客户端解析出的每一个作业对应一个集群；而应用模式下，是直接由 JobManager 执行应用程序的，并且即使应用包含了多个作业，也只创建一个集群。</p>
<p>总结一下，在会话模式下，集群的生命周期独立于集群上运行的任何作业的生命周期，并且提交的所有作业共享资源。而单作业模式为每个提交的作业创建一个集群，带来了更好的资源隔离，这时集群的生命周期与作业的生命周期绑定。最后，应用模式为每个应用程序创建一个会话集群，在 JobManager 上直接调用应用程序的 main() 方法。</p>
<h3 id="独立模式-Standalone"><a href="#独立模式-Standalone" class="headerlink" title="独立模式(Standalone)"></a>独立模式(Standalone)</h3><p>独立模式(Standalone)是部署 Flink 最基本也是最简单的方式：所需要的所有 Flink 组件，都只是操作系统上运行的一个 JVM 进程。</p>
<p>独立模式是独立运行的，不依赖任何外部的资源管理平台；当然独立也是有代价的：如果资源不足，或者出现故障，没有自动扩展或重分配资源的保证，必须手动处理。所以独立模式 一般只用在开发测试或作业非常少的场景下。</p>
<p>另外，我们也可以将独立模式的集群放在容器中运行。Flink 提供了独立模式的容器化部署方式，可以在 Docker 或者 Kubernetes 上进行部署。</p>
<h3 id="YARN-模式"><a href="#YARN-模式" class="headerlink" title="YARN 模式"></a>YARN 模式</h3><p>独立模式(Standalone)由 Flink 自身提供资源，无需其他框架，这种方式降低了和其他第三方资源框架的耦合性，独立性非常强。但我们知道，Flink 是大数据计算框架，不是资源调度框架，这并不是它的强项；所以还是应该让专业的框架做专业的事，和其他资源调度框架集成更靠谱。而在目前大数据生态中，国内应用最为广泛的资源管理平台就是 YARN 了。</p>
<p>整体来说，YARN 上部署的过程是：客户端把 Flink 应用提交给 Yarn 的 ResourceManager, Yarn 的 ResourceManager 会向 Yarn 的 NodeManager 申请容器。在这些容器上，Flink 会部署 JobManager 和 TaskManager 的实例，从而启动集群。Flink 会根据运行在 JobManger 上的作业所需要的 Slot 数量动态分配 TaskManager 资源。</p>
<h3 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h3><p>Flink 就是一个分布式的并行流处理系统。简单来说，它会由多个进程构成，这些进程一般会分布运行在不同的机器上。</p>
<p>Flink 可以配置为独立(Standalone)集群运行，也可以方便地跟一些集群资源管理工具集成使用，比如 YARN、Kubernetes 和 Mesos。Flink 也不会自己去提供持久化的分布式存储，而是直接利用了已有的分布式文件系统(比如HDFS)或者对象存储(比如S3)。而对于高可用的配置，Flink 是依靠 Apache ZooKeeper 来完成的。</p>
<p>Flink 的运行时架构中，最重要的就是两大组件：作业管理器(<strong>JobManger</strong>)和任务管理器 (<strong>TaskManager</strong>)。对于一个提交执行的作业，JobManager 是真正意义上的管理者(Master)， 负责管理调度，所以在不考虑高可用的情况下只能有一个；而 TaskManager 是工作者(Worker、Slave)，负责执行任务处理数据，所以可以有一个或多个。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8B%E5%8D%881.45.50.png" alt="截屏2022-03-22 下午1.45.50"></p>
<p>这里首先要说明一下”客户端”。其实客户端并不是处理系统的一部分，它<strong>只负责作业的提交</strong>。具体来说，就是调用程序的 main 方法，将代码转换成”数据流图”(<strong>Dataflow Graph</strong>)， 并最终生成作业图(<strong>JobGraph</strong>)，一并发送给 JobManager。提交之后，任务的执行其实就跟客户端没有关系了；我们可以在客户端选择断开与 JobManager 的连接，也可以继续保持连接。 之前我们在命令提交作业时，加上的-d 参数，就是表示分离模式(detached mode)，也就是断开连接。</p>
<p>当然，客户端可以随时连接到 JobManager，获取当前作业的状态和执行结果，也可以发送请求取消作业。不论通过 Web UI 还是命令行执行”flink run”的相关操作，都是通过客户端实现的。</p>
<p>TaskManager 启动之后，JobManager 会与它建立连接，并将作业图(<strong>JobGraph</strong>)转换成可执行的”执行图”(<strong>ExecutionGraph</strong>)分发给可用的 TaskManager，然后就由 TaskManager 具体执行任务。</p>
<h4 id="作业管理器-JobManager"><a href="#作业管理器-JobManager" class="headerlink" title="作业管理器(JobManager)"></a>作业管理器(JobManager)</h4><p>JobManager 是一个 Flink 集群中任务管理和调度的核心，是控制应用执行的主进程。也就是说，每个应用都应该被唯一的 JobManager 所控制执行。当然，在高可用(HA)的场景下，可能会出现多个 JobManager；这时只有一个是正在运行的领导节点(leader)，其他都是备用节点(standby)。</p>
<p>JobManger 又包含 3 个不同的组件：JobMaster，ResourceManager，Dispatcher</p>
<h5 id="JobMaster"><a href="#JobMaster" class="headerlink" title="JobMaster"></a>JobMaster</h5><p>JobMaster 是 JobManager 中最核心的组件，<strong>负责处理单独的作业</strong>(Job)。所以 JobMaster 和具体的 Job 是一一对应的，多个 Job 可以同时运行在一个 Flink 集群中，每个 Job 都有一个自己的 JobMaster。需要注意在早期版本的 Flink 中，没有 JobMaster 的概念；而 JobManager 的概念范围较小，实际指的就是现在所说的 JobMaster。</p>
<p>在作业提交时，JobMaster 会先接收到要执行的应用。这里所说”应用”一般是客户端提交来的，包括：Jar包、数据流图(dataflow graph)、作业图(JobGraph)。</p>
<p>JobMaster 会把 JobGraph 转换成一个物理层面的数据流图，这个图被叫作”执行图” (ExecutionGraph)，它包含了所有可以并发执行的任务。JobMaster 会向资源管理器 (ResourceManager)发出请求，申请执行任务必要的资源。一旦它获取到了足够的资源，就会将执行图分发到真正运行它们的 TaskManager 上。而在运行过程中，JobMaster 会负责所有需要中央协调的操作，比如说检查点(checkpoints)的协调。</p>
<h5 id="ResourceManager"><a href="#ResourceManager" class="headerlink" title="ResourceManager"></a>ResourceManager</h5><p>ResourceManager 主要<strong>负责资源的分配和管理</strong>，在 Flink 集群中只有一个。所谓资源，主要是指 TaskManager 的任务槽(task slots)。任务槽就是 Flink 集群中的资源调配单元，包含了机器用来执行计算的一组CPU和内存资源。每一个任务(Task)都需要分配到一个 slot 上执行。</p>
<p>这里注意要把 Flink 内置的 ResourceManager 和其他资源管理平台(比如 YARN)的 ResourceManager 区分开。</p>
<p>Flink 的 ResourceManager，针对不同的环境和资源管理平台(比如 Standalone 部署，或者 YARN)，有不同的具体实现。在 Standalone 部署时，因为 TaskManager 是单独启动的(没有 Per-Job 模式)，所以 ResourceManager 只能分发可用 TaskManager 的任务槽，不能单独启动新 TaskManager。</p>
<p>而在有资源管理平台时，就不受此限制。当新的作业申请资源时，ResourceManager 会将有空闲槽位的 TaskManager 分配给 JobMaster。如果 ResourceManager 没有足够的任务槽，它还可以向资源提供平台发起会话，请求提供启动 TaskManager 进程的容器。另外，ResourceManager 还负责停掉空闲的 TaskManager，释放计算资源。</p>
<h5 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h5><p>Dispatcher 主要负责提供一个 REST 接口，用来提交应用，并且负责为每一个新提交的作业启动一个新的 JobMaster 组件。Dispatcher 也会启动一个 Web UI，用来方便地展示和监控作业执行的信息。Dispatcher 在架构中并不是必需的，在不同的部署模式下可能会被忽略掉。</p>
<h4 id="任务管理器-TaskManager"><a href="#任务管理器-TaskManager" class="headerlink" title="任务管理器(TaskManager)"></a>任务管理器(TaskManager)</h4><p>TaskManager 是 Flink 中的工作进程，<strong>数据流的具体计算就是它来做的</strong>，所以也被称为 Worker。Flink 集群中必须至少有一个 TaskManager；当然由于分布式计算的考虑，通常会有多个 TaskManager 运行，每一个 TaskManager 都包含了一定数量的任务槽(task slots)。Slot 是资源调度的最小单位，slot 的数量限制了 TaskManager 能够并行处理的任务数量。</p>
<p>启动之后，TaskManager 会向 ResourceManager 注册它的 slots；收到 ResourceManager 的指令后，TaskManager 就会将一个或者多个槽位提供给 JobMaster 调用，JobMaster 就可以分配任务来执行了。在执行过程中，TaskManager 可以缓冲数据，还可以跟其他运行同一应用的 TaskManager 交换数据。</p>
<h4 id="作业提交流程"><a href="#作业提交流程" class="headerlink" title="作业提交流程"></a>作业提交流程</h4><p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8B%E5%8D%882.20.24.png" alt="截屏2022-03-22 下午2.20.24"></p>
<p>(1) 一般情况下，由客户端(App)通过分发器提供的 REST 接口，将作业提交给JobManager。</p>
<p>(2) 由分发器启动 JobMaster，并将作业(包含 JobGraph)提交给 JobMaster。</p>
<p>(3) JobMaster 将 JobGraph 解析为可执行的 ExecutionGraph，得到所需的资源数量，然后向资源管理器请求资源(slots)。</p>
<p>(4) 资源管理器判断当前是否由足够的可用资源；如果没有，启动新的 TaskManager。 </p>
<p>(5) TaskManager 启动之后，向 ResourceManager 注册自己的可用任务槽(slots)。</p>
<p>(6) 资源管理器通知 TaskManager 为新的作业提供 slots。</p>
<p>(7) TaskManager 连接到对应的 JobMaster，提供 slots。 </p>
<p>(8) JobMaster 将需要执行的任务分发给 TaskManager。 </p>
<p>(9) TaskManager 执行任务，互相之间可以交换数据。</p>
<p><strong>YARN集群 会话(Session)模式：</strong></p>
<p>在会话模式下，我们需要先启动一个 YARN session，这个会话会创建一个 Flink 集群。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8B%E5%8D%882.26.46.png" alt="截屏2022-03-22 下午2.26.46"></p>
<p>这里只启动了 JobManager，而 TaskManager 可以根据需要动态地启动。在 JobManager 内部，由于还没有提交作业，所以只有 ResourceManager 和 Dispatcher 在运行。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8B%E5%8D%882.28.07.png" alt="截屏2022-03-22 下午2.28.07"></p>
<p>接下来就是真正提交作业的流程：</p>
<p>(1) 客户端通过 REST 接口，将作业提交给分发器。</p>
<p>(2) 分发器启动 JobMaster，并将作业(包含 JobGraph)提交给 JobMaster。 (3)JobMaster 向资源管理器请求资源(slots)。</p>
<p>(4) 资源管理器向 YARN 的资源管理器请求 container 资源。</p>
<p>(5) YARN 启动新的 TaskManager 容器。</p>
<p>(6) TaskManager 启动之后，向 Flink 的资源管理器注册自己的可用任务槽。 </p>
<p>(7) 资源管理器通知 TaskManager 为新的作业提供 slots。 </p>
<p>(8) TaskManager 连接到对应的 JobMaster，提供 slots。</p>
<p>(9) JobMaster 将需要执行的任务分发给 TaskManager，执行任务。</p>
<p>注意：请求资源时要上报YARN的资源管理器。</p>
<p><strong>YARN集群 单作业(Per-Job)模式：</strong></p>
<p>在单作业模式下，Flink 集群不会预先启动，而是在提交作业时，才启动新的 JobManager。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8B%E5%8D%882.41.21.png" alt="截屏2022-03-22 下午2.41.21"></p>
<p>(1) 客户端将作业提交给 YARN 的资源管理器，这一步中会同时将 Flink 的 Jar 包和配置 上传到 HDFS，以便后续启动 Flink 相关组件的容器。</p>
<p>(2) YARN的资源管理器分配Container资源，启动Flink JobManager，并将作业提交给 JobMaster。这里省略了 Dispatcher 组件。</p>
<p>(3) JobMaster 向资源管理器请求资源(slots)。</p>
<p>(4) 资源管理器向 YARN 的资源管理器请求 container 资源。</p>
<p>(5) YARN 启动新的 TaskManager 容器。</p>
<p>(6) TaskManager 启动之后，向 Flink 的资源管理器注册自己的可用任务槽。 </p>
<p>(7) 资源管理器通知 TaskManager 为新的作业提供 slots。 </p>
<p>(8) TaskManager 连接到对应的 JobMaster，提供 slots。</p>
<p>(9) JobMaster 将需要执行的任务分发给 TaskManager，执行任务。</p>
<p>区别只在于 JobManager 的启动方式，以及省去了分发器。当第 2 步作业提交给 JobMaster，之后的流程就与会话模式完全一样了。</p>
<p><strong>YARN集群的应用(Application)模式：</strong></p>
<p>应用模式与单作业模式的提交流程非常相似，只是初始提交给 YARN 资源管理器的不再 是具体的作业，而是整个应用。一个应用中可能包含了多个作业，这些作业都将在 Flink 集群 中启动各自对应的 JobMaster。</p>
<h4 id="数据流图-Dataflow-Graph"><a href="#数据流图-Dataflow-Graph" class="headerlink" title="数据流图(Dataflow Graph)"></a>数据流图(Dataflow Graph)</h4><p>所有的 Flink 程序都可以归纳为由三部分构成：Source、Transformation 和 Sink。 </p>
<p>Source表示源算子，负责读取数据源。</p>
<p>Transformation表示转换算子，利用各种算子进行处理加工。</p>
<p>Sink表示下沉算子，负责数据的输出。</p>
<p>在运行时，Flink 程序会被映射成所有算子按照逻辑顺序连接在一起的一张图，这被称为逻辑数据流(logical dataflow)，或者叫数据流图(dataflow graph)。我们提交作业之后， 打开 Flink 自带的 Web UI，点击作业就能看到对应的 dataflow。</p>
<h4 id="并行度-Parallelism"><a href="#并行度-Parallelism" class="headerlink" title="并行度(Parallelism)"></a>并行度(Parallelism)</h4><p>在 Flink 执行过程中，每一个算子(operator)可以包含一个或多个子任务(operator subtask)，<strong>这些子任务在不同的线程、不同的物理机或不同的容器中完全独立地执行</strong>。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8B%E5%8D%884.36.32.png" alt="截屏2022-03-22 下午4.36.32"></p>
<p>**一个特定算子的子任务(subtask)的个数被称之为其并行度(parallelism)**。这样，包含并行子任务的数据流，就是并行数据流，它需要多个分区(stream partition)来分配并行任务。 一般情况下，一个流程序的并行度，可以认为就是其所有算子中最大的并行度。一个程序中， 不同的算子可能具有不同的并行度。</p>
<p>如图 4-8 所示，当前数据流中有 source、map、window、sink 四个算子，除最后 sink，其他算子的并行度都为 2。整个程序包含了 7 个子任务，至少需要 2 个分区来并行执行。我们可以说，这段流处理程序的并行度就是 2。</p>
<p><strong>并行度的设置：</strong></p>
<p>可以用不同的方法来设置并行度，它们的有效范围和优先级别也是不同的。</p>
<p>1、代码中设置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只针对当前算子有效</span></span><br><span class="line">stream.map(word -&gt; Tuple2.of(word, <span class="number">1L</span>)).setParallelism(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局设定并行度</span></span><br><span class="line"><span class="comment">//这样代码中所有算子，默认的并行度就都为2了</span></span><br><span class="line">env.setParallelism(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//keyBy不是算子，所以无法对keyBy设置并行度</span></span><br></pre></td></tr></table></figure>

<p>2、提交应用时设置</p>
<p>在使用flink run命令提交应用时，可以增加-p参数来指定当前应用程序执行的并行度，它的作用类似于执行环境的全局设置。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/flink run –p 2 –c com.vincent.wc.StreamWordCount ./FlinkTutorial-1.0-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>

<p>3、配置文件中设置</p>
<p>我们还可以直接在集群的配置文件 flink-conf.yaml 中直接更改默认并行度。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">parallelism.default:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>这个设置对于整个集群上提交的所有作业有效，初始值为 1。无论在代码中设置、还是提交时的 -p 参数，都不是必须的；所以在没有指定并行度的时候，就会采用配置文件中的集群 默认并行度。在开发环境中，没有配置文件，默认并行度就是当前机器的 CPU 核心数。</p>
<p><strong>优先级：</strong></p>
<p>(1) 对于一个算子，首先看在<strong>代码中是否单独指定了它的并行度</strong>，这个特定的设置优先级最高，会覆盖后面所有的设置。 </p>
<p>(2) 如果没有单独设置，那么采用当前<strong>代码中执行环境全局设置的并行度</strong>。 </p>
<p>(3) 如果代码中完全没有设置，那么采用<strong>提交时-p 参数指定的并行度</strong>。</p>
<p>(4) 如果提交时也未指定-p 参数，那么采用集群<strong>配置文件</strong>中的默认并行度。</p>
<h4 id="算子链-Operator-Chain"><a href="#算子链-Operator-Chain" class="headerlink" title="算子链(Operator Chain)"></a>算子链(Operator Chain)</h4><p>一个数据流在算子之间传输数据的形式可以是一对一(one-to-one)的直通 (forwarding)模式，也可以是打乱的重分区(redistributing)模式，具体是哪一种形式，取决于算子的种类。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8B%E5%8D%885.01.43.png" alt="截屏2022-03-22 下午5.01.43"></p>
<h5 id="一对一-one-to-one"><a href="#一对一-one-to-one" class="headerlink" title="一对一(one-to-one)"></a>一对一(one-to-one)</h5><p>这种模式下，<strong>数据流维护着分区以及元素的顺序</strong>。比如图中的 source 和 map 算子，source 算子读取数据之后，可以直接发送给 map 算子做处理，它们之间不需要重新分区，也不需要调整数据的顺序。这就意味着 map 算子的子任务，看到的元素个数和顺序跟 source 算子的子任务产生的完全一样，保证着一对一的关系。map、filter、flatMap 等算子都是这种 one-to-one 的对应关系。</p>
<h5 id="重分区-Redistributing"><a href="#重分区-Redistributing" class="headerlink" title="重分区(Redistributing)"></a>重分区(Redistributing)</h5><p>在这种模式下，<strong>数据流的分区会发生改变</strong>。比图中的 map 和后面的 keyBy/window 算子之间(这里的 keyBy 是数据传输算子，后面的 window、apply 方法共同构成了 window 算子)，以及 keyBy/window 算子和 Sink 算子之间，都是这样的关系。</p>
<p>每一个算子的子任务，会根据数据传输的策略，把数据发送到不同的下游目标任务。例如，keyBy()是分组操作，<strong>本质上基于键(key)的哈希值(hashCode)进行了重分区</strong>；而当并行度改变时，比如从并行度为 2 的 window 算子，要传递到并行度为 1 的 Sink 算子，这时的数据传输方式是再平衡(rebalance)，会把数据均匀地向下游子任务分发出去。这些传输方式都会引起重分区(redistribute)的过程，这一过程类似于 Spark 中的 shuffle。</p>
<h5 id="合并算子链"><a href="#合并算子链" class="headerlink" title="合并算子链"></a>合并算子链</h5><p>在 Flink 中，并行度相同的一对一(one to one)算子操作，可以直接链接在一起形成一个大的任务(task)，这样原来的算子就成为了真正任务里的一部分。每个 task 会被一个<strong>线程</strong>执行。这样的技术被称为“算子链”(Operator Chain)。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8B%E5%8D%885.28.05.png" alt="截屏2022-03-22 下午5.28.05"></p>
<p>比如在图 4-11 中的例子中，Source 和 map 之间满足了算子链的要求，所以可以直接合并在一起，形成了一个任务；因为并行度为 2，所以合并后的任务也有两个并行子任务。这样，这个数据流图所表示的作业最终会有 5 个任务，由 5 个线程并行执行。</p>
<p>Flink 为什么要有算子链这样一个设计呢？这是因为将算子链接成 task 是非常有效的优化：可以减少线程之间的切换和基于缓存区的数据交换，在减少时延的同时提升吞吐量。</p>
<p>Flink 默认会按照算子链的原则进行链接合并，如果我们想要禁止合并或者自行定义，也可以在代码中对算子做一些特定的设置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 禁用算子链</span></span><br><span class="line">.map(word -&gt; Tuple2.of(word, <span class="number">1L</span>)).disableChaining(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 从当前算子开始新链</span></span><br><span class="line">.map(word -&gt; Tuple2.of(word, <span class="number">1L</span>)).startNewChain();</span><br></pre></td></tr></table></figure>

<h4 id="作业图-JobGraph-与执行图-ExecutionGraph"><a href="#作业图-JobGraph-与执行图-ExecutionGraph" class="headerlink" title="作业图(JobGraph)与执行图(ExecutionGraph)"></a>作业图(JobGraph)与执行图(ExecutionGraph)</h4><p>逻辑流图(StreamGraph)→ 作业图(JobGraph)→ 执行图(ExecutionGraph)→ 物理图(Physical Graph)</p>
<p>处理 socket 文本流的 StreamWordCount 程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env.socketTextStream().flatMap(...).keyBy(<span class="number">0</span>).sum(<span class="number">1</span>).print();</span><br></pre></td></tr></table></figure>

<p>提交时设置并行度为 2：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/flink run –p 2 –c com.vincent.wc.StreamWordCount ./FlinkTutorial-1.0-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>

<p>除了 socketTextStream() 是非并行的 Source 算子，它的并行度始终 为 1，其他算子的并行度都为 2。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8B%E5%8D%889.46.48.png" alt="截屏2022-03-22 下午9.46.48"></p>
<ol>
<li>逻辑流图(StreamGraph)</li>
</ol>
<p>这是根据用户通过 DataStream API 编写的代码生成的最初的 DAG 图，用来表示程序的拓扑结构。这一步一般在<strong>客户端</strong>完成。我们可以看到，逻辑流图中的节点，完全对应着代码中的四步算子操作：源算子 Source(socketTextStream())→扁平映射算子 Flat Map(flatMap()) →分组聚合算子 Keyed Aggregation(keyBy/sum()) →输出算子 Sink(print())。</p>
<ol start="2">
<li>作业图(JobGraph)</li>
</ol>
<p>StreamGraph 经过优化后生成的就是作业图(JobGraph)，这是提交给 JobManager 的数据结构，确定了当前作业中所有任务的划分。主要的优化为：将多个符合条件的节点链接在一起合并成一个任务节点，形成<strong>算子链</strong>，这样可以减少数据交换的消耗。JobGraph 一般也是在<strong>客户端</strong>生成的，在作业提交时传递给 JobMaster。在图 4-12 中，分组聚合算子(Keyed Aggregation)和输出算子 Sink(print)并行度都为 2， 而且是一对一的关系，满足算子链的要求，所以会合并在一起，成为一个任务节点。</p>
<ol start="3">
<li>执行图(ExecutionGraph)</li>
</ol>
<p>JobMaster 收到 JobGraph 后，会根据它来生成执行图(ExecutionGraph)。ExecutionGraph 是 JobGraph 的并行化版本，是调度层最核心的数据结构。从图 4-12 中可以看到，与 JobGraph 最大的区别就是<strong>按照并行度对并行子任务进行了拆分</strong>， 并明确了任务间数据传输的方式。</p>
<ol start="4">
<li>物理图(Physical Graph)</li>
</ol>
<p>JobMaster 生成执行图后， 会将它分发给 TaskManager；各个 TaskManager 会根据执行图部署任务，最终的物理执行过程也会形成一张图，一般就叫作物理图(Physical Graph)。 这只是具体执行层面的图，并不是一个具体的数据结构。对应在上图 4-12 中，物理图主要就是在执行图的基础上，进一步<strong>确定数据存放的位置和收发的具体方式</strong>。有了物理图，TaskManager 就可以对传递来的数据进行处理计算了。所以我们可以看到，程序里定义了<strong>四个算子</strong>操作：源(Source)-&gt;转换(flatMap)-&gt;分组聚合(keyBy/sum)-&gt;输出(print)；合并算子链进行优化之后，就只有<strong>三个任务节点</strong>了；再考虑并行度后，一共有 <strong>5 个并行子任务</strong>，最终需要 <strong>5 个线程来</strong>执行。</p>
<h4 id="任务-Tasks-和任务槽-Task-Slots"><a href="#任务-Tasks-和任务槽-Task-Slots" class="headerlink" title="任务(Tasks)和任务槽(Task Slots)"></a>任务(Tasks)和任务槽(Task Slots)</h4><p>Flink 中每一个 worker(也就是 TaskManager)都是一个 <strong>JVM 进程</strong>，它可以启动<strong>多个独立的线程</strong>，来**并行执行多个子任务(subtask)**。</p>
<p>所以如果想要执行 5 个任务，并不一定非要 5 个 TaskManager，我们可以让 TaskManager 多线程执行任务。如果可以同时运行 5 个线程，那么只要一个 TaskManager 就可以满足我们之前程序的运行需求了。</p>
<p>很显然，TaskManager 的计算资源是有限的，并不是所有任务都可以放在一个 TaskManager 上并行执行。并行的任务越多，每个线程的资源就会越少。那一个 TaskManager 到底能并行处理多少个任务呢？为了控制并发量，我们需要在 TaskManager 上对每个任务运行所占用的资源做出明确的划分，这就是所谓的任务槽(task slots)。</p>
<p>每个任务槽(task slot)其实表示了<strong>TaskManager</strong>拥有计算资源的一个<strong>固定大小的子集</strong>。这些资源就是用来独立执行一个<strong>子任务</strong>的。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8B%E5%8D%8810.22.59.png" alt="截屏2022-03-22 下午10.22.59"></p>
<p>假如一个 TaskManager 有三个 slot，那么它会将管理的内存平均分成三份，每个 slot 独自占据一份。这样一来，我们在 slot 上执行一个子任务时，相当于划定了一块内存”专款专用”，就不需要跟来自其他作业的任务去竞争内存资源了。所以现在我们只要 2 个 TaskManager，就可以并行处理分配好的 5 个任务了。</p>
<p><strong>任务槽数量的设置</strong></p>
<p>我们可以通过集群的配置文件来设定 TaskManager 的 slot 数量：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskmanager.numberOfTaskSlots: 8</span><br></pre></td></tr></table></figure>

<p>通过调整 slot 的数量，我们就可以控制子任务之间的隔离级别。</p>
<p>具体来说，如果一个 TaskManager 只有一个 slot，那将意味着每个任务都会运行在独立的 JVM 中(当然，该 JVM 可能是通过一个特定的容器启动的)；而一个 TaskManager 设置多个 slot 则意味着多个子任务可以共享同一个 JVM。它们的区别在于：前者任务之间完全独立运行， 隔离级别更高、彼此间的影响可以降到最小；而后者在同一个 JVM 进程中运行的任务，将<strong>共享 TCP 连接和心跳消息</strong>，也可能<strong>共享数据集和数据结构</strong>，这就减少了每个任务的运行开销， 在降低隔离级别的同时提升了性能。</p>
<p>需要注意的是，<strong>slot 目前仅仅用来隔离内存</strong>，不会涉及 CPU 的隔离。在具体应用时，可以将 slot 数量配置为机器的 CPU 核心数，尽量避免不同任务之间对 CPU 的竞争。这也是开发环境默认并行度设为机器 CPU 数量的原因。</p>
<p><strong>任务对任务槽的共享</strong></p>
<p>这样看来，一共有多少任务，我们就需要有多少 slot 来并行处理它们。不过实际提交作业进行测试就会发现，我们之前的WordCount 程序设置并行度为 2 提交，一共有 5 个并行子任务，可集群即使只有 2 个 task slot 也是可以成功提交并运行的。这又是为什么呢？</p>
<p>我们可以基于之前的例子继续扩展。如果我们保持 sink 任务并行度为 1 不变，而作业提交时设置全局并行度为 6，那么前两个任务节点就会各自有 6 个并行子任务，整个流处理程序 则有 13 个子任务。那对于 2 个 TaskManager、每个有 3 个 slot 的集群配置来说，还能否正常运行呢?</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8B%E5%8D%8810.35.04.png" alt="截屏2022-03-22 下午10.35.04"></p>
<p>完全没有问题。这是因为默认情况下，Flink 是允许子任务共享 slot 的。只要属于同一个作业，那么对于不同任务节点的并行子任务，就可以放到同一个 slot 上执行。 所以对于第一个任务节点 source→map，它的 6 个并行子任务必须分到不同的 slot 上(如果在 同一 slot 就没法数据并行了)，而第二个任务节点 keyBy/window/apply 的并行子任务却可以和第一个任务节点共享 slot。</p>
<p>这个特性看起来有点奇怪：我们不是希望并行处理、任务之间相互隔离吗，为什么这里又允许共享 slot 呢?</p>
<p>我们知道，一个 slot 对应了一组独立的计算资源。在之前不做共享的时候，每个任务都平等地占据了一个 slot，但其实<strong>不同的任务对资源的占用是不同的</strong>。例如这里的前两个任务， source/map 尽管是两个算子合并算子链得到的，但它只是基本的数据读取和简单转换，计算耗时极短，一般也不需要太大的内存空间；而 window 算子所做的窗口操作，往往会涉及大量的数据、状态存储和计算，我们一般把这类任务叫作<strong>资源密集型(intensive)任务</strong>。当它们被平等地分配到独立的 slot 上时，实际运行我们就会发现，大量数据到来时 source/map 和 sink 任务很快就可以完成，但 window 任务却耗时很久；于是<strong>下游的 sink 任务占据的 slot 就会等待闲置</strong>，而上游的 source/map 任务受限于下游的处理能力，也会在快速处理完一部分数据后阻塞对应的资源开始等待(相当于处理背压)。这样资源的利用就出现了极大的不平衡，忙的忙死，闲的闲死。</p>
<p>解决这一问题的思路就是允许 slot 共享。当我们<strong>将资源密集型和非密集型的任务同时放到 一个 slot 中</strong>，它们就可以自行分配对资源占用的比例，从而保证最重的活平均分配给所有的 TaskManager。</p>
<p>slot 共享另一个好处就是允许我们保存完整的作业管道。这样一来，即使某个 TaskManager 出现故障宕机，其他节点也可以完全不受影响，作业的任务可以继续执行。</p>
<p>另外，同一个任务节点的并行子任务是不能共享 slot 的。所以允许 slot 共享之后，运行作业所需的 slot 数量正好就是作业中所有算子并行度的最大值。这样一来，我们考虑当前集群需要配置多少 slot 资源时，就不需要再去详细计算一个作业总共包含多少个并行子任务了，只看<strong>最大的并行度</strong>就够了。</p>
<p>Flink 默认是允许 slot 共享的，如果希望某个算子对应的任务完全独占一个 slot，或者只有某一部分算子共享 slot，我们也可以通过设置 **slot 共享组(SlotSharingGroup)**手动指定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.map(word -&gt; Tuple2.of(word, <span class="number">1L</span>)).slotSharingGroup(<span class="string">&quot;1&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这样，只有属于同一个 slot 共享组的子任务，才会开启 slot 共享；不同组之间的任务是完全隔离的，必须分配到不同的 slot 上。在这种场景下，总共需要的 slot 数量，就是各个 slot 共享组最大并行度的总和。</p>
<p><strong>任务槽和并行度的关系</strong></p>
<p>Slot 和并行度确实都跟程序的并行执行有关，但两者是完全不同的概念。简单来说，task slot 是静态的概念，是指 TaskManager 具有的并发执行能力，可以通过参数 taskmanager.numberOfTaskSlots 进行配置；而并行度(parallelism)是动态概念，也就是 TaskManager 运行程序时实际使用的并发能力，可以通过参数 parallelism.default 进行配置。换句话说，并行度如果小于等于集群中可用 slot 的总数，程序是可以正常执行的，因为 slot 不一定要全部占用，有十分力气可以只用八分；而如果并行度大于可用 slot 总数，导致超出了并行能力上限，那么心有余力不足，程序就只好等待资源管理器分配更多的资源了。</p>
<h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">flink.version</span>&gt;</span>1.12.0<span class="tag">&lt;/<span class="name">flink.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scala.binary.version</span>&gt;</span>2.11<span class="tag">&lt;/<span class="name">scala.binary.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slf4j.version</span>&gt;</span>1.7.30<span class="tag">&lt;/<span class="name">slf4j.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-streaming-java_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-clients_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-runtime-web_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-to-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.14.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-kafka_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.75<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-redis_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-elasticsearch6_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.49<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-jdbc_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-statebackend-rocksdb_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-hdfs<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-cep_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-table-planner_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-table-planner-blink_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-streaming-scala_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-csv<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-json<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-hive_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- Hive Dependency --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hive<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hive-exec<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="WordCount"><a href="#WordCount" class="headerlink" title="WordCount"></a>WordCount</h2><h3 id="batch"><a href="#batch" class="headerlink" title="batch"></a>batch</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.获取执行环境</span></span><br><span class="line">    ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.读取文件</span></span><br><span class="line">    DataSource&lt;String&gt; input = env.readTextFile(<span class="string">&quot;/Users/vincent/Documents/flink/input/word.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.用flatmap压平 1行hello world 变成 1行hello 1行world</span></span><br><span class="line">    FlatMapOperator&lt;String, String&gt; stringObjectFlatMapOperator = input.flatMap(<span class="keyword">new</span> FlatMapFunction&lt;String, String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(String s, Collector&lt;String&gt; collector)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">//按照空格切割</span></span><br><span class="line">            String[] words = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (String word: words</span><br><span class="line">                 ) &#123;</span><br><span class="line">                collector.collect(word);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.单词变元组 hello -&gt; (hello,1)</span></span><br><span class="line">    MapOperator&lt;String, Tuple2&lt;String,Integer&gt;&gt; stringObjectMapOperator = stringObjectFlatMapOperator.map(<span class="keyword">new</span> MapFunction&lt;String, Tuple2&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Tuple2&lt;String, Integer&gt; <span class="title">map</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">//return new Tuple2&lt;&gt;(s,1);</span></span><br><span class="line">            <span class="keyword">return</span> Tuple2.of(s,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.分组</span></span><br><span class="line">    UnsortedGrouping&lt;Tuple2&lt;String, Integer&gt;&gt; tuple2UnsortedGrouping = stringObjectMapOperator.groupBy(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.聚合</span></span><br><span class="line">    AggregateOperator&lt;Tuple2&lt;String, Integer&gt;&gt; tuple2AggregateOperator = tuple2UnsortedGrouping.sum(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.显示</span></span><br><span class="line">    tuple2AggregateOperator.print();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建执行环境</span></span><br><span class="line">    ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    <span class="comment">// 2. 从文件读取数据  按行读取(存储的元素就是每行的文本)</span></span><br><span class="line">    DataSource&lt;String&gt; lineDS = env.readTextFile(<span class="string">&quot;/Users/vincent/Documents/flink/input/word.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 3. 转换数据格式</span></span><br><span class="line">    FlatMapOperator&lt;String, Tuple2&lt;String, Long&gt;&gt; wordAndOne = lineDS</span><br><span class="line">            .flatMap((String line, Collector&lt;Tuple2&lt;String, Long&gt;&gt; out) -&gt; &#123;</span><br><span class="line">                String[] words = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">                    out.collect(Tuple2.of(word, <span class="number">1L</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .returns(Types.TUPLE(Types.STRING, Types.LONG));  <span class="comment">//当Lambda表达式使用 Java 泛型的时候, 由于泛型擦除的存在, 需要显示的声明类型信息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 按照 word 进行分组</span></span><br><span class="line">    UnsortedGrouping&lt;Tuple2&lt;String, Long&gt;&gt; wordAndOneUG = wordAndOne.groupBy(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 5. 分组内聚合统计</span></span><br><span class="line">    AggregateOperator&lt;Tuple2&lt;String, Long&gt;&gt; sum = wordAndOneUG.sum(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 打印结果</span></span><br><span class="line">    sum.print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="bounded-stream"><a href="#bounded-stream" class="headerlink" title="bounded_stream"></a>bounded_stream</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、创建执行环境，设置并行度为1</span></span><br><span class="line">    StreamExecutionEnvironment executionEnvironment = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    executionEnvironment.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、读取文件流</span></span><br><span class="line">    DataStreamSource&lt;String&gt; stringDataStreamSource = executionEnvironment.readTextFile(<span class="string">&quot;/Users/vincent/Documents/flink/input/word.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.hello world 转换为 (hello,1) (world,1)</span></span><br><span class="line">    SingleOutputStreamOperator&lt;Tuple2&lt;String, Integer&gt;&gt; objectSingleOutputStreamOperator = stringDataStreamSource.flatMap(<span class="keyword">new</span> FlatMapFunction&lt;String, Tuple2&lt;String,Integer&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(String s, Collector&lt;Tuple2&lt;String,Integer&gt;&gt; collector)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            String[] words = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (String word: words</span><br><span class="line">                 ) &#123;</span><br><span class="line">                collector.collect(Tuple2.of(word, <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.分组</span></span><br><span class="line">    KeyedStream&lt;Tuple2&lt;String, Integer&gt;, String&gt; tuple2TupleKeyedStream = objectSingleOutputStreamOperator.keyBy(<span class="keyword">new</span> KeySelector&lt;Tuple2&lt;String, Integer&gt;, String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getKey</span><span class="params">(Tuple2&lt;String, Integer&gt; stringIntegerTuple2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> stringIntegerTuple2.f0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.聚合</span></span><br><span class="line">    SingleOutputStreamOperator&lt;Tuple2&lt;String, Integer&gt;&gt; sum = tuple2TupleKeyedStream.sum(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.显示</span></span><br><span class="line">    sum.print();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.启动任务</span></span><br><span class="line">    JobExecutionResult execute = executionEnvironment.execute(<span class="string">&quot;start&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建流式执行环境</span></span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    <span class="comment">// 2. 读取文件</span></span><br><span class="line">    DataStreamSource&lt;String&gt; lineDSS = env.readTextFile(<span class="string">&quot;/Users/vincent/Documents/flink/input/word.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 3. 转换数据格式</span></span><br><span class="line">    SingleOutputStreamOperator&lt;Tuple2&lt;String, Long&gt;&gt; wordAndOne = lineDSS</span><br><span class="line">            .flatMap((String line, Collector&lt;String&gt; words) -&gt; &#123;</span><br><span class="line">                Arrays.stream(line.split(<span class="string">&quot; &quot;</span>)).forEach(words::collect);</span><br><span class="line">            &#125;)</span><br><span class="line">            .returns(Types.STRING)</span><br><span class="line">            .map(word -&gt; Tuple2.of(word, <span class="number">1L</span>))</span><br><span class="line">            .returns(Types.TUPLE(Types.STRING, Types.LONG));</span><br><span class="line">    <span class="comment">// 4. 分组</span></span><br><span class="line">    KeyedStream&lt;Tuple2&lt;String, Long&gt;, String&gt; wordAndOneKS = wordAndOne</span><br><span class="line">            .keyBy(t -&gt; t.f0);</span><br><span class="line">    <span class="comment">// 5. 求和</span></span><br><span class="line">    SingleOutputStreamOperator&lt;Tuple2&lt;String, Long&gt;&gt; result = wordAndOneKS</span><br><span class="line">            .sum(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 6. 打印</span></span><br><span class="line">    result.print();</span><br><span class="line">    <span class="comment">// 7. 执行</span></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unbounded-stream"><a href="#unbounded-stream" class="headerlink" title="unbounded_stream"></a>unbounded_stream</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.获取执行环境</span></span><br><span class="line">    StreamExecutionEnvironment executionEnvironment = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    executionEnvironment.setParallelism(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.读取端口数据流</span></span><br><span class="line">    DataStreamSource&lt;String&gt; stringDataStreamSource = executionEnvironment.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">1234</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.转换为元组</span></span><br><span class="line">    SingleOutputStreamOperator&lt;Tuple2&lt;String, Integer&gt;&gt; objectSingleOutputStreamOperator = stringDataStreamSource.flatMap(<span class="keyword">new</span> FlatMapFunction&lt;String, Tuple2&lt;String,Integer&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(String s, Collector&lt;Tuple2&lt;String,Integer&gt;&gt; collector)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            String[] words = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (String word: words</span><br><span class="line">            ) &#123;</span><br><span class="line">                collector.collect(Tuple2.of(word, <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.分组</span></span><br><span class="line">    KeyedStream&lt;Tuple2&lt;String, Integer&gt;, String&gt; tuple2TupleKeyedStream = objectSingleOutputStreamOperator.keyBy(<span class="keyword">new</span> KeySelector&lt;Tuple2&lt;String, Integer&gt;, String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getKey</span><span class="params">(Tuple2&lt;String, Integer&gt; stringIntegerTuple2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> stringIntegerTuple2.f0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5.聚合</span></span><br><span class="line">    SingleOutputStreamOperator&lt;Tuple2&lt;String, Integer&gt;&gt; sum = tuple2TupleKeyedStream.sum(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//6.显示</span></span><br><span class="line">    sum.print();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//7.启动任务</span></span><br><span class="line">    executionEnvironment.execute();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建流式执行环境</span></span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    <span class="comment">// 2. 读取文本流</span></span><br><span class="line">    DataStreamSource&lt;String&gt; lineDSS = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">7777</span>);</span><br><span class="line">    <span class="comment">// 3. 转换数据格式</span></span><br><span class="line">    SingleOutputStreamOperator&lt;Tuple2&lt;String, Long&gt;&gt; wordAndOne = lineDSS</span><br><span class="line">            .flatMap((String line, Collector&lt;String&gt; words) -&gt; &#123;</span><br><span class="line">                Arrays.stream(line.split(<span class="string">&quot; &quot;</span>)).forEach(words::collect);</span><br><span class="line">            &#125;)</span><br><span class="line">            .returns(Types.STRING)</span><br><span class="line">            .map(word -&gt; Tuple2.of(word, <span class="number">1L</span>))</span><br><span class="line">            .returns(Types.TUPLE(Types.STRING, Types.LONG));</span><br><span class="line">    <span class="comment">// 4. 分组</span></span><br><span class="line">    KeyedStream&lt;Tuple2&lt;String, Long&gt;, String&gt; wordAndOneKS = wordAndOne</span><br><span class="line">            .keyBy(t -&gt; t.f0);</span><br><span class="line">    <span class="comment">// 5. 求和</span></span><br><span class="line">    SingleOutputStreamOperator&lt;Tuple2&lt;String, Long&gt;&gt; result = wordAndOneKS</span><br><span class="line">            .sum(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 6. 打印</span></span><br><span class="line">    result.print();</span><br><span class="line">    <span class="comment">// 7. 执行</span></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><h3 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">StreamExecutionEnvironment executionEnvironment = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">executionEnvironment.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">List&lt;WaterSensor&gt; list = Arrays.asList(</span><br><span class="line">  <span class="keyword">new</span> WaterSensor(<span class="string">&quot;a&quot;</span>,<span class="number">12345678910L</span>,<span class="number">56</span>),</span><br><span class="line">  <span class="keyword">new</span> WaterSensor(<span class="string">&quot;b&quot;</span>,<span class="number">12354657829L</span>,<span class="number">57</span>),</span><br><span class="line">  <span class="keyword">new</span> WaterSensor(<span class="string">&quot;c&quot;</span>,<span class="number">12362457829L</span>,<span class="number">52</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">DataStreamSource&lt;WaterSensor&gt; waterSensorDataStreamSource = executionEnvironment.fromCollection(list);</span><br><span class="line"></span><br><span class="line">waterSensorDataStreamSource.print();</span><br><span class="line"></span><br><span class="line">executionEnvironment.execute();</span><br></pre></td></tr></table></figure>

<h3 id="file"><a href="#file" class="headerlink" title="file"></a>file</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">StreamExecutionEnvironment executionEnvironment = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">executionEnvironment.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">DataStreamSource&lt;String&gt; stringDataStreamSource = executionEnvironment.readTextFile(<span class="string">&quot;input/sensor.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">SingleOutputStreamOperator&lt;WaterSensor&gt; map = stringDataStreamSource.map(<span class="keyword">new</span> MapFunction&lt;String, WaterSensor&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WaterSensor <span class="title">map</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String[] split = s.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WaterSensor(split[<span class="number">0</span>],Long.parseLong(split[<span class="number">1</span>]),Integer.parseInt(split[<span class="number">2</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">map.print();</span><br><span class="line"></span><br><span class="line">executionEnvironment.execute();</span><br></pre></td></tr></table></figure>

<h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">DataStreamSource&lt;String&gt; socketTextStream = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">1234</span>);</span><br><span class="line"></span><br><span class="line">socketTextStream.print();</span><br><span class="line"></span><br><span class="line">env.execute();</span><br></pre></td></tr></table></figure>

<h3 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-producer.sh --broker-list linux1:9092 --topic tp_order</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">    properties.setProperty(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;hadoop102:9092&quot;</span>);</span><br><span class="line">    properties.setProperty(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;consumer-group&quot;</span>);</span><br><span class="line">    properties.setProperty(<span class="string">&quot;key.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">    properties.setProperty(<span class="string">&quot;value.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">    properties.setProperty(<span class="string">&quot;auto.offset.reset&quot;</span>, <span class="string">&quot;latest&quot;</span>);</span><br><span class="line"></span><br><span class="line">    DataStreamSource&lt;String&gt; stream = env.addSource(<span class="keyword">new</span> FlinkKafkaConsumer&lt;String&gt;(</span><br><span class="line">            <span class="string">&quot;clicks&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> SimpleStringSchema(),</span><br><span class="line">            properties</span><br><span class="line">    ));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    stream.print(<span class="string">&quot;Kafka&quot;</span>);</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="custom-parallel"><a href="#custom-parallel" class="headerlink" title="custom_parallel"></a>custom_parallel</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">    env.addSource(<span class="keyword">new</span> CustomSource()).setParallelism(<span class="number">2</span>).print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomSource</span> <span class="keyword">implements</span> <span class="title">ParallelSourceFunction</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> running = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(SourceContext&lt;Integer&gt; sourceContext)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            sourceContext.collect(random.nextInt());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        running = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="custom-source"><a href="#custom-source" class="headerlink" title="custom_source"></a>custom_source</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    StreamExecutionEnvironment executionEnvironment = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    executionEnvironment.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    DataStreamSource&lt;WaterSensor&gt; objectDataStreamSource = executionEnvironment.addSource(<span class="keyword">new</span> MySource(<span class="string">&quot;localhost&quot;</span>,<span class="number">2345</span>));</span><br><span class="line"></span><br><span class="line">    objectDataStreamSource.print();</span><br><span class="line"></span><br><span class="line">    executionEnvironment.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MySource</span> <span class="keyword">implements</span> <span class="title">SourceFunction</span>&lt;<span class="title">WaterSensor</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Boolean running = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySource</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(SourceContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        socket = <span class="keyword">new</span> Socket(host,port);</span><br><span class="line">        reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream(), UTF_8));</span><br><span class="line"></span><br><span class="line">        String s = reader.readLine();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(running &amp;&amp; s != <span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            String[] split = s.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            WaterSensor waterSensor = <span class="keyword">new</span> WaterSensor(split[<span class="number">0</span>], Long.parseLong(split[<span class="number">1</span>]), Integer.parseInt(split[<span class="number">2</span>]));</span><br><span class="line">            ctx.collect(waterSensor);</span><br><span class="line">            s = reader.readLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        running = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            reader.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h2><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    DataStreamSource&lt;Event&gt; stream = env.fromElements(</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./cart&quot;</span>, <span class="number">2000L</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传入匿名类，实现MapFunction</span></span><br><span class="line">    stream.map(<span class="keyword">new</span> MapFunction&lt;Event, String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">map</span><span class="params">(Event e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> e.user;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传入MapFunction的实现类</span></span><br><span class="line">    stream.map(<span class="keyword">new</span> UserExtractor()).print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserExtractor</span> <span class="keyword">implements</span> <span class="title">MapFunction</span>&lt;<span class="title">Event</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">map</span><span class="params">(Event e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> e.user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="richFunction"><a href="#richFunction" class="headerlink" title="richFunction"></a>richFunction</h3><p>RichFunction富有的地方在于：1、生命周期方法 2、可以获取上下文执行环境，做状态编程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    DataStreamSource&lt;Event&gt; clicks = env.fromElements(</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./cart&quot;</span>, <span class="number">2000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod?id=1&quot;</span>, <span class="number">5</span> * <span class="number">1000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Cary&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">60</span> * <span class="number">1000L</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将点击事件转换成长整型的时间戳输出</span></span><br><span class="line">    clicks.map(<span class="keyword">new</span> RichMapFunction&lt;Event, Long&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">super</span>.open(parameters);</span><br><span class="line">                    System.out.println(<span class="string">&quot;索引为 &quot;</span> + getRuntimeContext().getIndexOfThisSubtask() + <span class="string">&quot; 的任务开始&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Long <span class="title">map</span><span class="params">(Event value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> value.timestamp;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">super</span>.close();</span><br><span class="line">                    System.out.println(<span class="string">&quot;索引为 &quot;</span> + getRuntimeContext().getIndexOfThisSubtask() + <span class="string">&quot; 的任务结束&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    DataStreamSource&lt;Event&gt; stream = env.fromElements(</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./cart&quot;</span>, <span class="number">2000L</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    stream.flatMap(<span class="keyword">new</span> MyFlatMap()).print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFlatMap</span> <span class="keyword">implements</span> <span class="title">FlatMapFunction</span>&lt;<span class="title">Event</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(Event value, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value.user.equals(<span class="string">&quot;Mary&quot;</span>)) &#123;</span><br><span class="line">            out.collect(value.user);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value.user.equals(<span class="string">&quot;Bob&quot;</span>)) &#123;</span><br><span class="line">            out.collect(value.user);</span><br><span class="line">            out.collect(value.url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    DataStreamSource&lt;Event&gt; stream = env.fromElements(</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./cart&quot;</span>, <span class="number">2000L</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传入匿名类实现FilterFunction</span></span><br><span class="line">    stream.filter(<span class="keyword">new</span> FilterFunction&lt;Event&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(Event e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> e.user.equals(<span class="string">&quot;Mary&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传入FilterFunction实现类</span></span><br><span class="line">    stream.filter(<span class="keyword">new</span> UserFilter()).print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserFilter</span> <span class="keyword">implements</span> <span class="title">FilterFunction</span>&lt;<span class="title">Event</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(Event e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> e.user.equals(<span class="string">&quot;Mary&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><p><strong>说明：1、只能操作两个流    2、两个流可以是不同类型</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.获取执行环境</span></span><br><span class="line">StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.读取端口数据创建流</span></span><br><span class="line">DataStreamSource&lt;String&gt; stringDS = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">1234</span>);</span><br><span class="line">DataStreamSource&lt;String&gt; socketTextStream2 = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">4321</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.将socketTextStream2转换为Int类型</span></span><br><span class="line">SingleOutputStreamOperator&lt;Integer&gt; intDS = socketTextStream2.map(String::length);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.连接两个流</span></span><br><span class="line">ConnectedStreams&lt;String, Integer&gt; connectedStreams = stringDS.connect(intDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.处理连接之后的流</span></span><br><span class="line">SingleOutputStreamOperator&lt;Object&gt; result = connectedStreams.map(<span class="keyword">new</span> CoMapFunction&lt;String, Integer, Object&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">map1</span><span class="params">(String value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">map2</span><span class="params">(Integer value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.打印数据</span></span><br><span class="line">result.print();</span><br><span class="line"></span><br><span class="line"><span class="comment">//7.执行</span></span><br><span class="line">env.execute();</span><br></pre></td></tr></table></figure>

<h3 id="union"><a href="#union" class="headerlink" title="union"></a>union</h3><p><strong>说明：1、可以操作多个流    2、多个流必须是同类型</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.获取执行环境</span></span><br><span class="line">StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.读取端口数据创建流</span></span><br><span class="line">DataStreamSource&lt;String&gt; socketTextStream1 = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">1234</span>);</span><br><span class="line">DataStreamSource&lt;String&gt; socketTextStream2 = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">4321</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.连接两条流</span></span><br><span class="line">DataStream&lt;String&gt; union = socketTextStream1.union(socketTextStream2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.打印</span></span><br><span class="line">union.print();</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.执行任务</span></span><br><span class="line">env.execute();</span><br></pre></td></tr></table></figure>

<h3 id="max-maxBy"><a href="#max-maxBy" class="headerlink" title="max/maxBy"></a>max/maxBy</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.获取执行环境</span></span><br><span class="line">StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.读取端口数据并转换为JavaBean</span></span><br><span class="line">SingleOutputStreamOperator&lt;WaterSensor&gt; waterSensorDS = env.socketTextStream(<span class="string">&quot;hadoop102&quot;</span>, <span class="number">9999</span>)</span><br><span class="line">        .map(<span class="keyword">new</span> MapFunction&lt;String, WaterSensor&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> WaterSensor <span class="title">map</span><span class="params">(String value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                String[] split = value.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> WaterSensor(split[<span class="number">0</span>],</span><br><span class="line">                        Long.parseLong(split[<span class="number">1</span>]),</span><br><span class="line">                        Integer.parseInt(split[<span class="number">2</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.按照传感器ID分组</span></span><br><span class="line">KeyedStream&lt;WaterSensor, String&gt; keyedStream = waterSensorDS.keyBy(<span class="keyword">new</span> KeySelector&lt;WaterSensor, String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getKey</span><span class="params">(WaterSensor value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value.getId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.计算最高水位线</span></span><br><span class="line"><span class="comment">//SingleOutputStreamOperator&lt;WaterSensor&gt; result = keyedStream.max(&quot;vc&quot;);</span></span><br><span class="line">SingleOutputStreamOperator&lt;WaterSensor&gt; result = keyedStream.maxBy(<span class="string">&quot;vc&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.打印</span></span><br><span class="line">result.print();</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.执行任务</span></span><br><span class="line">env.execute();</span><br></pre></td></tr></table></figure>

<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的使用了之前自定义数据源小节中的ClickSource()</span></span><br><span class="line">    env.addSource(<span class="keyword">new</span> ClickSource())</span><br><span class="line">            <span class="comment">// 将Event数据类型转换成元组类型</span></span><br><span class="line">            .map(<span class="keyword">new</span> MapFunction&lt;Event, Tuple2&lt;String, Long&gt;&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Tuple2&lt;String, Long&gt; <span class="title">map</span><span class="params">(Event e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> Tuple2.of(e.user, <span class="number">1L</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .keyBy(r -&gt; r.f0) <span class="comment">// 使用用户名来进行分流</span></span><br><span class="line">            .reduce(<span class="keyword">new</span> ReduceFunction&lt;Tuple2&lt;String, Long&gt;&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Tuple2&lt;String, Long&gt; <span class="title">reduce</span><span class="params">(Tuple2&lt;String, Long&gt; value1, Tuple2&lt;String, Long&gt; value2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="comment">// 每到一条数据，用户pv的统计值加1</span></span><br><span class="line">                    <span class="keyword">return</span> Tuple2.of(value1.f0, value1.f1 + value2.f1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .keyBy(r -&gt; <span class="keyword">true</span>) <span class="comment">// 为每一条数据分配同一个key，将聚合结果发送到一条流中去</span></span><br><span class="line">            .reduce(<span class="keyword">new</span> ReduceFunction&lt;Tuple2&lt;String, Long&gt;&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Tuple2&lt;String, Long&gt; <span class="title">reduce</span><span class="params">(Tuple2&lt;String, Long&gt; value1, Tuple2&lt;String, Long&gt; value2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="comment">// 将累加器更新为当前最大的pv统计值，然后向下游发送累加器的值</span></span><br><span class="line">                    <span class="keyword">return</span> value1.f1 &gt; value2.f1 ? value1 : value2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="returnType"><a href="#returnType" class="headerlink" title="returnType"></a>returnType</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    DataStreamSource&lt;Event&gt; clicks = env.fromElements(</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./cart&quot;</span>, <span class="number">2000L</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 想要转换成二元组类型，需要进行以下处理</span></span><br><span class="line">    <span class="comment">// 1) 使用显式的 &quot;.returns(...)&quot;</span></span><br><span class="line">    DataStream&lt;Tuple2&lt;String, Long&gt;&gt; stream3 = clicks</span><br><span class="line">            .map( event -&gt; Tuple2.of(event.user, <span class="number">1L</span>) )</span><br><span class="line">            .returns(Types.TUPLE(Types.STRING, Types.LONG));</span><br><span class="line">    stream3.print();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 使用类来替代Lambda表达式</span></span><br><span class="line">    clicks.map(<span class="keyword">new</span> MyTuple2Mapper())</span><br><span class="line">            .print();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3) 使用匿名类来代替Lambda表达式</span></span><br><span class="line">    clicks.map(<span class="keyword">new</span> MapFunction&lt;Event, Tuple2&lt;String, Long&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Tuple2&lt;String, Long&gt; <span class="title">map</span><span class="params">(Event value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Tuple2.of(value.user, <span class="number">1L</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义MapFunction的实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTuple2Mapper</span> <span class="keyword">implements</span> <span class="title">MapFunction</span>&lt;<span class="title">Event</span>, <span class="title">Tuple2</span>&lt;<span class="title">String</span>, <span class="title">Long</span>&gt;&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Tuple2&lt;String, Long&gt; <span class="title">map</span><span class="params">(Event value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Tuple2.of(value.user, <span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tupleAggreation"><a href="#tupleAggreation" class="headerlink" title="tupleAggreation"></a>tupleAggreation</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    DataStreamSource&lt;Tuple2&lt;String, Integer&gt;&gt; stream = env.fromElements(</span><br><span class="line">            Tuple2.of(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>),</span><br><span class="line">            Tuple2.of(<span class="string">&quot;a&quot;</span>, <span class="number">3</span>),</span><br><span class="line">            Tuple2.of(<span class="string">&quot;b&quot;</span>, <span class="number">3</span>),</span><br><span class="line">            Tuple2.of(<span class="string">&quot;b&quot;</span>, <span class="number">4</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  stream.keyBy(r -&gt; r.f0).sum(1).print();</span></span><br><span class="line">    <span class="comment">//  stream.keyBy(r -&gt; r.f0).sum(&quot;f1&quot;).print();</span></span><br><span class="line">    <span class="comment">//  stream.keyBy(r -&gt; r.f0).max(1).print();</span></span><br><span class="line">    <span class="comment">//  stream.keyBy(r -&gt; r.f0).max(&quot;f1&quot;).print();</span></span><br><span class="line">    <span class="comment">//  stream.keyBy(r -&gt; r.f0).min(1).print();</span></span><br><span class="line">    <span class="comment">//  stream.keyBy(r -&gt; r.f0).min(&quot;f1&quot;).print();</span></span><br><span class="line">    <span class="comment">//  stream.keyBy(r -&gt; r.f0).maxBy(1).print();</span></span><br><span class="line">    <span class="comment">//  stream.keyBy(r -&gt; r.f0).maxBy(&quot;f1&quot;).print();</span></span><br><span class="line">    <span class="comment">//  stream.keyBy(r -&gt; r.f0).minBy(1).print();</span></span><br><span class="line">    stream.keyBy(r -&gt; r.f0).minBy(<span class="string">&quot;f1&quot;</span>).print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="process"><a href="#process" class="headerlink" title="process"></a>process</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.获取执行环境</span></span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.读取端口数据</span></span><br><span class="line">    DataStreamSource&lt;String&gt; socketTextStream = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">1234</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.使用Process实现压平功能</span></span><br><span class="line">    SingleOutputStreamOperator&lt;String&gt; wordDS = socketTextStream.process(<span class="keyword">new</span> ProcessFlatMapFunc());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.使用Process实现Map功能</span></span><br><span class="line">    SingleOutputStreamOperator&lt;Tuple2&lt;String, Integer&gt;&gt; wordToOneDS = wordDS.process(<span class="keyword">new</span> ProcessMapFunc());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.按照单词分组</span></span><br><span class="line">    KeyedStream&lt;Tuple2&lt;String, Integer&gt;, String&gt; keyedStream = wordToOneDS.keyBy(data -&gt; data.f0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.计算总和</span></span><br><span class="line">    SingleOutputStreamOperator&lt;Tuple2&lt;String, Integer&gt;&gt; result = keyedStream.sum(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.打印</span></span><br><span class="line">    result.print();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8.执行任务</span></span><br><span class="line">    env.execute();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessFlatMapFunc</span> <span class="keyword">extends</span> <span class="title">ProcessFunction</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生命周期方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(String value, Context ctx, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//运行时上下文,状态编程</span></span><br><span class="line">        RuntimeContext runtimeContext = getRuntimeContext();</span><br><span class="line"></span><br><span class="line">        String[] words = value.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            out.collect(word);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定时器</span></span><br><span class="line">        TimerService timerService = ctx.timerService();</span><br><span class="line">        timerService.registerProcessingTimeTimer(<span class="number">1245L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取当前处理数据的时间</span></span><br><span class="line">        timerService.currentProcessingTime();</span><br><span class="line">        timerService.currentWatermark();  <span class="comment">//事件时间</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//侧输出流</span></span><br><span class="line">        <span class="comment">//ctx.output();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessMapFunc</span> <span class="keyword">extends</span> <span class="title">ProcessFunction</span>&lt;<span class="title">String</span>, <span class="title">Tuple2</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(String value, Context ctx, Collector&lt;Tuple2&lt;String, Integer&gt;&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        out.collect(<span class="keyword">new</span> Tuple2&lt;&gt;(value, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="physicalPartitioning"><a href="#physicalPartitioning" class="headerlink" title="physicalPartitioning"></a>physicalPartitioning</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 创建执行环境</span></span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    DataStreamSource&lt;Event&gt; stream = env.fromElements(<span class="keyword">new</span> Event(<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./cart&quot;</span>, <span class="number">2000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod?id=100&quot;</span>, <span class="number">3000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod?id=200&quot;</span>, <span class="number">3500L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./prod?id=2&quot;</span>, <span class="number">2500L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod?id=300&quot;</span>, <span class="number">3600L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">3000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./prod?id=1&quot;</span>, <span class="number">2300L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./prod?id=3&quot;</span>, <span class="number">3300L</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 随机分区</span></span><br><span class="line">    stream.shuffle().print(<span class="string">&quot;shuffle&quot;</span>).setParallelism(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 轮询分区</span></span><br><span class="line">    stream.rebalance().print(<span class="string">&quot;rebalance&quot;</span>).setParallelism(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. rescale重缩放分区</span></span><br><span class="line">    env.addSource(<span class="keyword">new</span> RichParallelSourceFunction&lt;Integer&gt;() &#123;  <span class="comment">// 这里使用了并行数据源的富函数版本</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(SourceContext&lt;Integer&gt; sourceContext)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; i++) &#123;</span><br><span class="line">                        <span class="comment">// 将奇数发送到索引为1的并行子任务</span></span><br><span class="line">                        <span class="comment">// 将偶数发送到索引为0的并行子任务</span></span><br><span class="line">                        <span class="keyword">if</span> ( i % <span class="number">2</span> == getRuntimeContext().getIndexOfThisSubtask()) &#123;</span><br><span class="line">                            sourceContext.collect(i);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .setParallelism(<span class="number">2</span>)</span><br><span class="line">            .rescale()</span><br><span class="line">            .print().setParallelism(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 广播</span></span><br><span class="line">    stream.broadcast().print(<span class="string">&quot;broadcast&quot;</span>).setParallelism(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 全局分区</span></span><br><span class="line">    stream.global().print(<span class="string">&quot;global&quot;</span>).setParallelism(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 自定义重分区</span></span><br><span class="line">    <span class="comment">// 将自然数按照奇偶分区</span></span><br><span class="line">    env.fromElements(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line">            .partitionCustom(<span class="keyword">new</span> Partitioner&lt;Integer&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Integer key, <span class="keyword">int</span> numPartitions)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> key % <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="keyword">new</span> KeySelector&lt;Integer, Integer&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Integer <span class="title">getKey</span><span class="params">(Integer value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .print().setParallelism(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PojoAggregation"><a href="#PojoAggregation" class="headerlink" title="PojoAggregation"></a>PojoAggregation</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    DataStreamSource&lt;Event&gt; stream = env.fromElements(</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./cart&quot;</span>, <span class="number">2000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;./cart&quot;</span>, <span class="number">3000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;./fav&quot;</span>, <span class="number">4000L</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    stream.keyBy(e -&gt; e.user)</span><br><span class="line">            <span class="comment">//.maxBy(&quot;timestamp&quot;)</span></span><br><span class="line">            .max(<span class="string">&quot;timestamp&quot;</span>)    <span class="comment">// 指定字段名称</span></span><br><span class="line">            .print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="udf"><a href="#udf" class="headerlink" title="udf"></a>udf</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    DataStreamSource&lt;Event&gt; clicks = env.fromElements(</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./cart&quot;</span>, <span class="number">2000L</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 传入实现FilterFunction接口的自定义函数类</span></span><br><span class="line">    DataStream&lt;Event&gt; stream1 = clicks.filter(<span class="keyword">new</span> FlinkFilter());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传入属性字段</span></span><br><span class="line">    DataStream&lt;Event&gt; stream2 = clicks.filter(<span class="keyword">new</span> KeyWordFilter(<span class="string">&quot;home&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 传入匿名类</span></span><br><span class="line">    DataStream&lt;Event&gt; stream3 = clicks.filter(<span class="keyword">new</span> FilterFunction&lt;Event&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(Event value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value.url.contains(<span class="string">&quot;home&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 传入Lambda表达式</span></span><br><span class="line">    SingleOutputStreamOperator&lt;Event&gt; stream4 = clicks.filter(data -&gt; data.url.contains(<span class="string">&quot;home&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//        stream1.print();</span></span><br><span class="line"><span class="comment">//        stream2.print();</span></span><br><span class="line"><span class="comment">//        stream3.print();</span></span><br><span class="line">    stream4.print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FlinkFilter</span> <span class="keyword">implements</span> <span class="title">FilterFunction</span>&lt;<span class="title">Event</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(Event value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value.url.contains(<span class="string">&quot;home&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyWordFilter</span> <span class="keyword">implements</span> <span class="title">FilterFunction</span>&lt;<span class="title">Event</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String keyWord;</span><br><span class="line"></span><br><span class="line">    KeyWordFilter(String keyWord) &#123; <span class="keyword">this</span>.keyWord = keyWord; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(Event value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value.url.contains(<span class="keyword">this</span>.keyWord);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Sink"><a href="#Sink" class="headerlink" title="Sink"></a>Sink</h2><h3 id="kafka-1"><a href="#kafka-1" class="headerlink" title="kafka"></a>kafka</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">    properties.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;hadoop102:9092&quot;</span>);</span><br><span class="line"></span><br><span class="line">    DataStreamSource&lt;String&gt; stream = env.readTextFile(<span class="string">&quot;input/clicks.csv&quot;</span>);</span><br><span class="line"></span><br><span class="line">    stream</span><br><span class="line">            .addSink(<span class="keyword">new</span> FlinkKafkaProducer&lt;String&gt;(</span><br><span class="line">                    <span class="string">&quot;clicks&quot;</span>,</span><br><span class="line">                    <span class="keyword">new</span> SimpleStringSchema(),</span><br><span class="line">                    properties</span><br><span class="line">            ));</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自定义source</span></span><br><span class="line">    DataStreamSource&lt;Event&gt; stream = env.addSource(<span class="keyword">new</span> ClickSource());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个到redis连接的配置</span></span><br><span class="line">    FlinkJedisPoolConfig conf = <span class="keyword">new</span> FlinkJedisPoolConfig.Builder()</span><br><span class="line">            .setHost(<span class="string">&quot;hadoop102&quot;</span>)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    stream.addSink(<span class="keyword">new</span> RedisSink&lt;Event&gt;(conf, <span class="keyword">new</span> MyRedisMapper()));</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRedisMapper</span> <span class="keyword">implements</span> <span class="title">RedisMapper</span>&lt;<span class="title">Event</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisCommandDescription <span class="title">getCommandDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RedisCommandDescription(RedisCommand.HSET, <span class="string">&quot;clicks&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getKeyFromData</span><span class="params">(Event data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValueFromData</span><span class="params">(Event data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.url;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClickSource</span> <span class="keyword">implements</span> <span class="title">SourceFunction</span>&lt;<span class="title">Event</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 声明一个布尔变量，作为控制数据生成的标识位</span></span><br><span class="line">    <span class="keyword">private</span> Boolean running = <span class="keyword">true</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(SourceContext&lt;Event&gt; ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();    <span class="comment">// 在指定的数据集中随机选取数据</span></span><br><span class="line">        String[] users = &#123;<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Cary&quot;</span>&#125;;</span><br><span class="line">        String[] urls = &#123;<span class="string">&quot;./home&quot;</span>, <span class="string">&quot;./cart&quot;</span>, <span class="string">&quot;./fav&quot;</span>, <span class="string">&quot;./prod?id=1&quot;</span>, <span class="string">&quot;./prod?id=2&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            ctx.collect(<span class="keyword">new</span> Event(</span><br><span class="line">                    users[random.nextInt(users.length)],</span><br><span class="line">                    urls[random.nextInt(urls.length)],</span><br><span class="line">                    Calendar.getInstance().getTimeInMillis()</span><br><span class="line">            ));</span><br><span class="line">            <span class="comment">// 隔1秒生成一个点击事件，方便观测</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        running = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="elasticsearch"><a href="#elasticsearch" class="headerlink" title="elasticsearch"></a>elasticsearch</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    DataStreamSource&lt;Event&gt; stream = env.fromElements(</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./cart&quot;</span>, <span class="number">2000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod?id=100&quot;</span>, <span class="number">3000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod?id=200&quot;</span>, <span class="number">3500L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./prod?id=2&quot;</span>, <span class="number">2500L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod?id=300&quot;</span>, <span class="number">3600L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">3000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./prod?id=1&quot;</span>, <span class="number">2300L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./prod?id=3&quot;</span>, <span class="number">3300L</span>));</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;HttpHost&gt; httpHosts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    httpHosts.add(<span class="keyword">new</span> HttpHost(<span class="string">&quot;hadoop102&quot;</span>, <span class="number">9200</span>, <span class="string">&quot;http&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个ElasticsearchSinkFunction</span></span><br><span class="line">    ElasticsearchSinkFunction&lt;Event&gt; elasticsearchSinkFunction = <span class="keyword">new</span> ElasticsearchSinkFunction&lt;Event&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Event element, RuntimeContext ctx, RequestIndexer indexer)</span> </span>&#123;</span><br><span class="line">            HashMap&lt;String, String&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            data.put(element.user, element.url);</span><br><span class="line"></span><br><span class="line">            IndexRequest request = Requests.indexRequest()</span><br><span class="line">                    .index(<span class="string">&quot;clicks&quot;</span>)</span><br><span class="line">                    .type(<span class="string">&quot;type&quot;</span>)    <span class="comment">// Es 6 必须定义 type</span></span><br><span class="line">                    .source(data);</span><br><span class="line"></span><br><span class="line">            indexer.add(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    stream.addSink(<span class="keyword">new</span> ElasticsearchSink.Builder&lt;Event&gt;(httpHosts, elasticsearchSinkFunction).build());</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="jdbc"><a href="#jdbc" class="headerlink" title="jdbc"></a>jdbc</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.获取执行环境</span></span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.读取端口数据并转换为JavaBean</span></span><br><span class="line">    SingleOutputStreamOperator&lt;WaterSensor&gt; waterSensorDS = env.socketTextStream(<span class="string">&quot;linux1&quot;</span>, <span class="number">9999</span>)</span><br><span class="line">            .map(<span class="keyword">new</span> MapFunction&lt;String, WaterSensor&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> WaterSensor <span class="title">map</span><span class="params">(String value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    String[] split = value.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> WaterSensor(split[<span class="number">0</span>],</span><br><span class="line">                            Long.parseLong(split[<span class="number">1</span>]),</span><br><span class="line">                            Integer.parseInt(split[<span class="number">2</span>]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.将数据写入MySQL</span></span><br><span class="line">    waterSensorDS.addSink(JdbcSink.sink(</span><br><span class="line">            <span class="string">&quot;INSERT INTO `sensor-0821` VALUES(?,?,?) ON DUPLICATE KEY UPDATE `ts`=?,`vc`=?&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> JdbcStatementBuilder&lt;WaterSensor&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(PreparedStatement preparedStatement, WaterSensor waterSensor)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">                    <span class="comment">//给占位符赋值</span></span><br><span class="line">                    preparedStatement.setString(<span class="number">1</span>, waterSensor.getId());</span><br><span class="line">                    preparedStatement.setLong(<span class="number">2</span>, waterSensor.getTs());</span><br><span class="line">                    preparedStatement.setInt(<span class="number">3</span>, waterSensor.getVc());</span><br><span class="line">                    preparedStatement.setLong(<span class="number">4</span>, waterSensor.getTs());</span><br><span class="line">                    preparedStatement.setInt(<span class="number">5</span>, waterSensor.getVc());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            JdbcExecutionOptions.builder()</span><br><span class="line">                    .withBatchSize(<span class="number">1</span>)</span><br><span class="line">                    .build(),</span><br><span class="line">            <span class="keyword">new</span> JdbcConnectionOptions.JdbcConnectionOptionsBuilder()</span><br><span class="line">                    .withUrl(<span class="string">&quot;jdbc:mysql://linux1:3306/test?useSSL=false&quot;</span>)</span><br><span class="line">                    .withDriverName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>)</span><br><span class="line">                    .withUsername(<span class="string">&quot;root&quot;</span>)</span><br><span class="line">                    .withPassword(<span class="string">&quot;000000&quot;</span>)</span><br><span class="line">                    .build()</span><br><span class="line">    ));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.执行任务</span></span><br><span class="line">    env.execute();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    DataStreamSource&lt;Event&gt; stream = env.fromElements(</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./cart&quot;</span>, <span class="number">2000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod?id=100&quot;</span>, <span class="number">3000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod?id=200&quot;</span>, <span class="number">3500L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./prod?id=2&quot;</span>, <span class="number">2500L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod?id=300&quot;</span>, <span class="number">3600L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">3000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./prod?id=1&quot;</span>, <span class="number">2300L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./prod?id=3&quot;</span>, <span class="number">3300L</span>));</span><br><span class="line"></span><br><span class="line">    stream.addSink(</span><br><span class="line">            JdbcSink.sink(</span><br><span class="line">                    <span class="string">&quot;INSERT INTO clicks (user, url) VALUES (?, ?)&quot;</span>,</span><br><span class="line">                    (statement, r) -&gt; &#123;</span><br><span class="line">                        statement.setString(<span class="number">1</span>, r.user);</span><br><span class="line">                        statement.setString(<span class="number">2</span>, r.url);</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="keyword">new</span> JdbcConnectionOptions.JdbcConnectionOptionsBuilder()</span><br><span class="line">                            .withUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>)</span><br><span class="line">                            .withDriverName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>)</span><br><span class="line">                            .withUsername(<span class="string">&quot;root&quot;</span>)</span><br><span class="line">                            .withPassword(<span class="string">&quot;root&quot;</span>)</span><br><span class="line">                            .build()</span><br><span class="line">            )</span><br><span class="line">    );</span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="file-1"><a href="#file-1" class="headerlink" title="file"></a>file</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    DataStream&lt;Event&gt; stream = env.fromElements(<span class="keyword">new</span> Event(<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./cart&quot;</span>, <span class="number">2000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod?id=100&quot;</span>, <span class="number">3000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod?id=200&quot;</span>, <span class="number">3500L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./prod?id=2&quot;</span>, <span class="number">2500L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod?id=300&quot;</span>, <span class="number">3600L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">3000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./prod?id=1&quot;</span>, <span class="number">2300L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./prod?id=3&quot;</span>, <span class="number">3300L</span>));</span><br><span class="line"></span><br><span class="line">    StreamingFileSink&lt;String&gt; fileSink = StreamingFileSink</span><br><span class="line">            .&lt;String&gt;forRowFormat(<span class="keyword">new</span> Path(<span class="string">&quot;./output&quot;</span>),</span><br><span class="line">                    <span class="keyword">new</span> SimpleStringEncoder&lt;&gt;(<span class="string">&quot;UTF-8&quot;</span>))</span><br><span class="line">            .withRollingPolicy(</span><br><span class="line">                    DefaultRollingPolicy.builder()</span><br><span class="line">                            .withRolloverInterval(TimeUnit.MINUTES.toMillis(<span class="number">15</span>))</span><br><span class="line">                            .withInactivityInterval(TimeUnit.MINUTES.toMillis(<span class="number">5</span>))</span><br><span class="line">                            .withMaxPartSize(<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>)</span><br><span class="line">                            .build())</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将Event转换成String写入文件</span></span><br><span class="line">    stream.map(Event::toString).addSink(fileSink);</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="custome-sink"><a href="#custome-sink" class="headerlink" title="custome_sink"></a>custome_sink</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.获取执行环境</span></span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.读取端口数据并转换为JavaBean</span></span><br><span class="line">    SingleOutputStreamOperator&lt;WaterSensor&gt; waterSensorDS = env.socketTextStream(<span class="string">&quot;linux1&quot;</span>, <span class="number">9999</span>)</span><br><span class="line">            .map(<span class="keyword">new</span> MapFunction&lt;String, WaterSensor&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> WaterSensor <span class="title">map</span><span class="params">(String value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    String[] split = value.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> WaterSensor(split[<span class="number">0</span>],</span><br><span class="line">                            Long.parseLong(split[<span class="number">1</span>]),</span><br><span class="line">                            Integer.parseInt(split[<span class="number">2</span>]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.将数据写入Mysql</span></span><br><span class="line">    waterSensorDS.addSink(<span class="keyword">new</span> MySink());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.执行任务</span></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MySink</span> <span class="keyword">extends</span> <span class="title">RichSinkFunction</span>&lt;<span class="title">WaterSensor</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明连接</span></span><br><span class="line">    <span class="keyword">private</span> Connection connection;</span><br><span class="line">    <span class="keyword">private</span> PreparedStatement preparedStatement;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生命周期方法,用于创建连接</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        connection = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://linux1:3306/test?useSSL=false&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;000000&quot;</span>);</span><br><span class="line">        preparedStatement = connection.prepareStatement(<span class="string">&quot;INSERT INTO `sensor-0821` VALUES(?,?,?) ON DUPLICATE KEY UPDATE `ts`=?,`vc`=?&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(WaterSensor value, Context context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给占位符赋值</span></span><br><span class="line">        preparedStatement.setString(<span class="number">1</span>, value.getId());</span><br><span class="line">        preparedStatement.setLong(<span class="number">2</span>, value.getTs());</span><br><span class="line">        preparedStatement.setInt(<span class="number">3</span>, value.getVc());</span><br><span class="line">        preparedStatement.setLong(<span class="number">4</span>, value.getTs());</span><br><span class="line">        preparedStatement.setInt(<span class="number">5</span>, value.getVc());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行操作</span></span><br><span class="line">        preparedStatement.execute();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生命周期方法,用于关闭连接</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        preparedStatement.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h2><h3 id="时间窗口-Time-Window"><a href="#时间窗口-Time-Window" class="headerlink" title="时间窗口(Time Window)"></a>时间窗口(Time Window)</h3><p>时间窗口以时间点来定义窗口的开始(start)和结束(end)，所以截取出的就是某一时间段的数据。到达结束时间时，窗口不再收集数据，触发计算输出结果，并将窗口关闭销毁。</p>
<p>Flink 中有一个专门的类来表示时间窗口，名称就叫作 TimeWindow。这个类只有两个私 有属性：start 和 end，表示窗口的开始和结束的时间戳，单位为毫秒。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> start;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> end;</span><br></pre></td></tr></table></figure>

<p>我们可以调用公有的 getStart() 和 getEnd()方法直接获取这两个时间戳。另外，TimeWindow 还提供了一个 maxTimestamp()方法，用来获取窗口中能够包含数据的最大时间戳。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">maxTimestamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> end - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显，窗口中的数据，最大允许的时间戳就是end - 1，这也就代表了我们定义的窗口时间范围都是左闭右开的区间[start，end)。</p>
<h4 id="TimeTumbling"><a href="#TimeTumbling" class="headerlink" title="TimeTumbling"></a>TimeTumbling</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理时间</span></span><br><span class="line">stream.keyBy(...)</span><br><span class="line">      .window(TumblingProcessingTimeWindows.of(Time.seconds(<span class="number">5</span>)))</span><br><span class="line">      .aggregate(...)</span><br><span class="line"><span class="comment">//北京时间0点</span></span><br><span class="line">.window(TumblingProcessingTimeWindows.of(Time.days(<span class="number">1</span>), Time.hours(-<span class="number">8</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">//事件时间</span></span><br><span class="line">stream.keyBy(...)</span><br><span class="line">      .window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">5</span>)))</span><br><span class="line">      .aggregate(...)</span><br></pre></td></tr></table></figure>

<h4 id="TimeSliding"><a href="#TimeSliding" class="headerlink" title="TimeSliding"></a>TimeSliding</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个长度为 10 秒、滑动步长为 5 秒</span></span><br><span class="line"><span class="comment">//处理时间</span></span><br><span class="line">stream.keyBy(...)</span><br><span class="line">      .window(SlidingProcessingTimeWindows.of(Time.seconds(<span class="number">10</span>), Time.seconds(<span class="number">5</span>)))</span><br><span class="line">      .aggregate(...)</span><br><span class="line"></span><br><span class="line"><span class="comment">//事件时间</span></span><br><span class="line">stream.keyBy(...)</span><br><span class="line">      .window(SlidingEventTimeWindows.of(Time.seconds(<span class="number">10</span>), Time.seconds(<span class="number">5</span>)))</span><br><span class="line">      .aggregate(...)</span><br></pre></td></tr></table></figure>

<h4 id="TimeSession"><a href="#TimeSession" class="headerlink" title="TimeSession"></a>TimeSession</h4><p>窗口分配器由类 ProcessingTimeSessionWindows 提供，需要调用它的静态方法.withGap()或者.withDynamicGap()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态会话超时时间为 10 秒的会话窗口</span></span><br><span class="line"><span class="comment">//处理时间</span></span><br><span class="line">stream.keyBy(...)</span><br><span class="line">      .window(ProcessingTimeSessionWindows.withGap(Time.seconds(<span class="number">10</span>)))</span><br><span class="line">      .aggregate(...)</span><br><span class="line"></span><br><span class="line"><span class="comment">//事件时间</span></span><br><span class="line">stream.keyBy(...)</span><br><span class="line">      .window(EventTimeSessionWindows.withGap(Time.seconds(<span class="number">10</span>)))</span><br><span class="line">      .aggregate(...)</span><br></pre></td></tr></table></figure>

<p>这里.withDynamicGap()方法需要传入一个 SessionWindowTimeGapExtractor 作为参数，用来<strong>定义session gap的动态提取逻辑</strong>。在这里，我们提取了数据元素的第一个字段，用它的长度乘以 1000 作为会话超时的间隔。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">stream.keyBy(...)</span><br><span class="line">      .window(ProcessingTimeSessionWindows.withDynamicGap(</span><br><span class="line">        <span class="keyword">new</span> SessionWindowTimeGapExtractor&lt;Tuple2&lt;String, Long&gt;&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extract</span><span class="params">(Tuple2&lt;String, Long&gt; element)</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 提取 session gap 值返回, 单位毫秒 </span></span><br><span class="line">                    <span class="keyword">return</span> element.f0.length() * <span class="number">1000</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">      ).aggregate(...)</span><br></pre></td></tr></table></figure>

<h3 id="计数窗口-Count-Window"><a href="#计数窗口-Count-Window" class="headerlink" title="计数窗口(Count Window)"></a>计数窗口(<strong>Count Window</strong>)</h3><p>计数窗口基于元素的个数来截取数据，到达固定的个数时就触发计算并关闭窗口。这相当于座位有限、人满就发车，是否发车与时间无关。每个窗口截取数据的个数，就是窗口的大小。</p>
<h4 id="CountTumbling"><a href="#CountTumbling" class="headerlink" title="CountTumbling"></a>CountTumbling</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当窗口中元素数量达到 10 的时候，就会触发计算执行并关闭窗口</span></span><br><span class="line">stream.keyBy(...)</span><br><span class="line">      .countWindow(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<h4 id="CountSliding"><a href="#CountSliding" class="headerlink" title="CountSliding"></a>CountSliding</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//长度为 10、滑动步长为 3 的滑动计数窗口。每个窗口统计 10 个数据，每隔 3 个数据就统计输出一次结果</span></span><br><span class="line">stream.keyBy(...)</span><br><span class="line">      .countWindow(<span class="number">10</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h3 id="全局窗口-Global-Windows"><a href="#全局窗口-Global-Windows" class="headerlink" title="全局窗口(Global Windows)"></a>全局窗口(<strong>Global Windows</strong>)</h3><p>还有一类比较通用的窗口，就是全局窗口。这种窗口全局有效，会把相同 key 的所有数据都分配到同一个窗口中；说直白一点，就跟没分窗口一样。无界流的数据永无止尽，所以这种窗口也没有结束的时候，默认是不会做触发计算的。如果希望它能对数据进行计算处理， 还需要**自定义触发器(Trigger)**。Flink 中的计数窗口(Count Window)，底层就是用全局窗口实现的。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stream.key<span class="constructor">By(<span class="operator">...</span>)</span></span><br><span class="line">      .window(<span class="module-access"><span class="module"><span class="identifier">GlobalWindows</span>.</span></span>create<span class="literal">()</span>);</span><br></pre></td></tr></table></figure>

<h3 id="窗口函数-Window-Functions"><a href="#窗口函数-Window-Functions" class="headerlink" title="窗口函数(Window Functions)"></a>窗口函数(Window Functions)</h3><p><strong>1、按键分区(Keyed)和非按键分区(Non-Keyed)</strong></p>
<p>按键分区窗口(Keyed Windows)：</p>
<p>经过按键分区 keyBy 操作后，数据流会按照 key 被分为多条逻辑流(logical streams)，这就是 KeyedStream。基于 KeyedStream 进行窗口操作时，窗口计算会在多个并行子任务上同时 执行。相同 key 的数据会被发送到同一个并行子任务，而窗口操作会基于每个 key 进行单独的处理。所以可以认为，每个 key 上都定义了一组窗口，各自独立地进行统计计算。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stream.keyBy(...)</span><br><span class="line">      .window(...)</span><br></pre></td></tr></table></figure>

<p>非按键分区(Non-Keyed Windows)：</p>
<p>如果没有进行 keyBy，那么原始的 DataStream 就不会分成多条逻辑流。这时窗口逻辑只能在一个任务(task)上执行，就相当于并行度变成了 1。所以在实际应用中一般不推荐使用这种方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream.windowAll(...)</span><br></pre></td></tr></table></figure>

<p><strong>2、代码中窗口 API 的调用</strong></p>
<p>窗口操作主要有两个部分：窗口分配器(Window Assigners)和窗口函数(Window Functions)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stream.keyBy(&lt;key selector&gt;)</span><br><span class="line">      .window(&lt;window assigner&gt;)      <span class="comment">//窗口分配器</span></span><br><span class="line">      .aggregate(&lt;window function&gt;)   <span class="comment">//窗口函数</span></span><br></pre></td></tr></table></figure>

<p>其中.window() 方法需要传入一个窗口分配器，它指明了窗口的类型;而后面的.aggregate() 方法传入一个窗口函数作为参数，它用来定义窗口具体的处理逻辑。窗口分配器有各种形式， 而窗口函数的调用方法也不只.aggregate()一种，我们接下来就详细展开讲解。</p>
<p>另外，在实际应用中，一般都需要并行执行任务，非按键分区很少用到，所以我们之后都以按键分区窗口为例；如果想要实现非按键分区窗口，只要前面不做 keyBy，后面调用.window() 时直接换成.windowAll() 就可以了。</p>
<p>经<strong>窗口分配器</strong>处理之后，数据可以分配到对应的窗口中，而数据流经过转换得到的数据类型是 WindowedStream。这个类型并不是 DataStream，所以并不能直接进行其他转换，而必须进一步调用<strong>窗口函数</strong>，对收集到的数据进行处理计算之后，才能最终再次得到 DataStream。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-03-23%20%E4%B8%8B%E5%8D%883.31.54.png" alt="截屏2022-03-23 下午3.31.54"></p>
<p>窗口函数定义了要对窗口中收集的数据做的计算操作，根据处理的方式可以分为两类：<strong>增量聚合函数</strong>和<strong>全窗口函数</strong>。</p>
<h4 id="增量聚合函数-incremental-aggregation-functions"><a href="#增量聚合函数-incremental-aggregation-functions" class="headerlink" title="增量聚合函数(incremental aggregation functions)"></a>增量聚合函数(incremental aggregation functions)</h4><p>就像 DataStream 的简单聚合 一样，每来一条数据就立即进行计算，中间只要保持一个简单的聚合状态就可以了；区别只是 在于不立即输出结果，而是要等到窗口结束时间。等到窗口到了结束时间需要输出计算结果的时候，我们只需要拿出之前聚合的状态直接输出，这无疑就大大提高了程序运行的效率和实时性。</p>
<p>典型的增量聚合函数有两个：ReduceFunction 和 AggregateFunction。</p>
<p><strong>ReduceFunction：</strong></p>
<p>将窗口中收集到的数据两两进行归约，当我们进行流处理时，就是要保存一个状态；每来一个新的数据，就和之前的聚合状态做归约，这样就实现了增量式的聚合。</p>
<p>代码中我们对每个用户的行为数据进行了开窗统计。与 word count 逻辑类似，首先将数据转换成(user, count)的二元组形式(类型为 Tuple2&lt;String, Long&gt;)，每条数据对应的初始 count 值都是 1；然后按照用户 id 分组，在处理时间下开滚动窗口，统计每 5 秒内的用户行为数量。 对于窗口的计算，我们用 ReduceFunction 对 count 值做了增量聚合：窗口中会将当前的总 count 值保存成一个归约状态，每来一条数据，就会调用内部的 reduce 方法，将新数据中的 count 值叠加到状态上，并得到新的状态保存起来。等到了 5 秒窗口的结束时间，就把归约好的状态直接输出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从自定义数据源读取数据，并提取时间戳、生成水位线</span></span><br><span class="line">    SingleOutputStreamOperator&lt;Event&gt; stream = env.addSource(<span class="keyword">new</span> ClickSource())</span><br><span class="line">                    .assignTimestampsAndWatermarks(WatermarkStrategy.&lt;Event&gt;forBoundedOutOfOrderness(Duration.ZERO)</span><br><span class="line">                    .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Event&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Event element, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> element.timestamp;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;));          </span><br><span class="line"></span><br><span class="line">    stream.map( <span class="keyword">new</span> MapFunction&lt;Event, Tuple2&lt;String, Long&gt;&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> Tuple2&lt;String, Long&gt; <span class="title">map</span><span class="params">(Event value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="comment">// 将数据转换成二元组，方便计算</span></span><br><span class="line">                            <span class="keyword">return</span> Tuple2.of(value.user, <span class="number">1L</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">          )</span><br><span class="line">          .keyBy(r -&gt; r.f0)</span><br><span class="line">          <span class="comment">// 设置滚动事件时间窗口</span></span><br><span class="line">          .window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">5</span>)))</span><br><span class="line">          .reduce(<span class="keyword">new</span> ReduceFunction&lt;Tuple2&lt;String, Long&gt;&gt;() &#123;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> Tuple2&lt;String, Long&gt; <span class="title">reduce</span><span class="params">(Tuple2&lt;String, Long&gt; value1, Tuple2&lt;String, Long&gt; value2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                  <span class="comment">// 定义累加规则，窗口闭合时，向下游发送累加结果</span></span><br><span class="line">                  <span class="keyword">return</span> Tuple2.of(value1.f0, value1.f1 + value2.f1);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">          .print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>AggregateFunction：</strong></p>
<p>ReduceFunction 可以解决大多数归约聚合的问题，但是这个接口有一个限制，就是聚合状态的类型、输出结果的类型都必须和输入数据类型一样。这就迫使我们必须在聚合前，先将数据转换(map)成预期结果类型；而在有些情况下，还需要对状态进行进一步处理才能得到输出结果，这时它们的类型可能不同，使用 ReduceFunction 就会非常麻烦。</p>
<p>如果我们希望计算一组数据的平均值，应该怎样做聚合呢？很明显，这时我们需要计算两个状态量：数据的总和(sum)，以及数据的个数(count)，而最终输出结果是两者的商 (sum/count)。如果用 ReduceFunction，那么我们应该先把数据转换成二元组(sum, count)的形 式，然后进行归约聚合，最后再将元组的两个元素相除转换得到最后的平均值。本来应该只是一个任务，可我们却需要 map-reduce-map 三步操作，这显然不够高效。应该允许让输入数据、中间状态、输出结果三者类型不同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AggregateFunction</span>&lt;<span class="title">IN</span>, <span class="title">ACC</span>, <span class="title">OUT</span>&gt; <span class="keyword">extends</span> <span class="title">Function</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">   <span class="function">ACC <span class="title">createAccumulator</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function">ACC <span class="title">add</span><span class="params">(IN value, ACC accumulator)</span></span>;</span><br><span class="line">   <span class="function">OUT <span class="title">getResult</span><span class="params">(ACC accumulator)</span></span>;</span><br><span class="line">   <span class="function">ACC <span class="title">merge</span><span class="params">(ACC a, ACC b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AggregateFunction 可以看作是 ReduceFunction 的通用版本，这里有三种类型：输入类型 (IN)、累加器类型(ACC)和输出类型(OUT)。输入类型 IN 就是输入流中元素的数据类型；累加器类型 ACC 则是我们进行聚合的中间状态类型；而输出类型当然就是最终计算结果的类型了。</p>
<p>createAccumulator()：创建一个累加器，这就是为聚合创建了一个<strong>初始状态</strong>，每个聚合任务只会<strong>调用一次</strong>。</p>
<p>add()：将输入的元素添加到累加器中。这就是基于聚合状态，对新来的数据进行进一步聚合的过程。方法传入两个参数：当前新到的数据 value，和当前的累加器 accumulator；返回一个新的累加器值，也就是<strong>对聚合状态进行更新</strong>。每条数据到来之后都会调用这个方法。</p>
<p>getResult()：从累加器中提取聚合的输出结果。也就是说，我们可以定义多个状态，然后再基于这些聚合的状态计算出一个结果进行输出。比如之前我们提到的计算平均值，就可以把 sum 和 count 作为状态放入累加器，而在调用这个方法时相除得到最终结果。这个方法只在窗口要输出结果时调用。</p>
<p>merge()：<strong>合并两个累加器</strong>，并将合并后的状态作为一个累加器返回。这个方法只在需要合并窗口的场景下才会被调用；最常见的合并窗口(Merging Window)的场景就是会话窗口(Session Windows)。</p>
<p>AggregateFunction 的工作原理是：首先调用 createAccumulator()为任务初始化一个状态(累加器)；而后每来一个数据就调用一次 add() 方法，对数据进行聚合，得到的结果保存在状态中；等到了窗口需要输出时，再调用 getResult() 方法得到计算结果。很明显，与 ReduceFunction 相同 AggregateFunction 也是增量式的聚合；而由于输入、中间状态、输出的类型可以不同，使得应用更加灵活方便。</p>
<p>在电商网站中，PV(页面浏览量) 和 UV(独立访客数) 是非常重要的两个流量指标。一般来说，PV 统计的是所有的点击量；而对用户 id 进行去重之后，得到的就是 UV。所以有时我们会用 PV/UV 这个比值，来表示人均重复访问量，也就是平均每个用户会访问多少次页面，这在一定程度上代表了用户的粘度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    SingleOutputStreamOperator&lt;Event&gt; stream = env.addSource(<span class="keyword">new</span> ClickSource())</span><br><span class="line">            .assignTimestampsAndWatermarks(WatermarkStrategy.&lt;Event&gt;forMonotonousTimestamps()</span><br><span class="line">                    .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Event&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Event element, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> element.timestamp;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有数据设置相同的key，发送到同一个分区统计PV和UV，再相除</span></span><br><span class="line">    stream.keyBy(data -&gt; <span class="keyword">true</span>)</span><br><span class="line">            .window(SlidingEventTimeWindows.of(Time.seconds(<span class="number">10</span>), Time.seconds(<span class="number">2</span>)))</span><br><span class="line">            .aggregate(<span class="keyword">new</span> AvgPv())</span><br><span class="line">            .print();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AvgPv</span> <span class="keyword">implements</span> <span class="title">AggregateFunction</span>&lt;<span class="title">Event</span>, <span class="title">Tuple2</span>&lt;<span class="title">HashSet</span>&lt;<span class="title">String</span>&gt;, <span class="title">Long</span>&gt;, <span class="title">Double</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Tuple2&lt;HashSet&lt;String&gt;, Long&gt; createAccumulator() &#123;</span><br><span class="line">        <span class="comment">// 创建累加器</span></span><br><span class="line">        <span class="keyword">return</span> Tuple2.of(<span class="keyword">new</span> HashSet&lt;String&gt;(), <span class="number">0L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Tuple2&lt;HashSet&lt;String&gt;, Long&gt; add(Event value, Tuple2&lt;HashSet&lt;String&gt;, Long&gt; accumulator) &#123;</span><br><span class="line">        <span class="comment">// 属于本窗口的数据来一条累加一次，并返回累加器</span></span><br><span class="line">        accumulator.f0.add(value.user);</span><br><span class="line">        <span class="keyword">return</span> Tuple2.of(accumulator.f0, accumulator.f1 + <span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">getResult</span><span class="params">(Tuple2&lt;HashSet&lt;String&gt;, Long&gt; accumulator)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 窗口闭合时，增量聚合结束，将计算结果发送到下游</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>) accumulator.f1 / accumulator.f0.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Tuple2&lt;HashSet&lt;String&gt;, Long&gt; merge(Tuple2&lt;HashSet&lt;String&gt;, Long&gt; a, Tuple2&lt;HashSet&lt;String&gt;, Long&gt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="全窗口函数-full-window-functions"><a href="#全窗口函数-full-window-functions" class="headerlink" title="全窗口函数(full window functions)"></a>全窗口函数(full window functions)</h4><p>窗口操作中的另一大类就是全窗口函数。与增量聚合函数不同，全窗口函数需要先收集窗口中的数据，并在内部缓存起来，等到窗口要输出结果的时候再取出数据进行计算。</p>
<p>为什么还需要有全窗口函数呢？这是因为有些场景下，我们要做的计算必须基于全部的数据才有效，这时做增量聚合就没什么意义了；另外，输出的结果有可能要包含上下文中的一 些信息(比如窗口的起始时间)，这是增量聚合函数做不到的。所以，我们还需要有更丰富的窗口计算方式，这就可以用全窗口函数来实现。在 Flink 中，全窗口函数也有两种：<strong>WindowFunction</strong> 和 <strong>ProcessWindowFunction</strong>。</p>
<p><strong>窗口函数(WindowFunction)</strong></p>
<p>WindowFunction 字面上就是窗口函数，它其实是老版本的通用窗口函数接口。我们可以基于 WindowedStream 调用.apply()方法，传入一个WindowFunction 的实现类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stream</span><br><span class="line">   .keyBy(&lt;key selector&gt;)</span><br><span class="line">   .window(&lt;window assigner&gt;)</span><br><span class="line">   .apply(<span class="keyword">new</span> MyWindowFunction());</span><br></pre></td></tr></table></figure>

<p>这个类中可以获取到包含窗口所有数据的可迭代集合(Iterable)，还可以拿到窗口 (Window)本身的信息。WindowFunction 接口在源码中实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WindowFunction</span>&lt;<span class="title">IN</span>, <span class="title">OUT</span>, <span class="title">KEY</span>, <span class="title">W</span> <span class="keyword">extends</span> <span class="title">Window</span>&gt; <span class="keyword">extends</span> <span class="title">Function</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(KEY key, W window, Iterable&lt;IN&gt; input, Collector&lt;OUT&gt; out)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WindowFunction 能提供的上下文信息较少，也没有更高级的功能。 事实上，它的作用可以被 ProcessWindowFunction 全覆盖，所以之后可能会逐渐弃用。一般在实际应用，直接使用 ProcessWindowFunction 就可以了。</p>
<p><strong>处理窗口函数(ProcessWindowFunction)</strong></p>
<p>ProcessWindowFunction 是 Window API 中最底层的通用窗口函数接口。之所以说它最底层，是因为除了可以拿到窗口中的所有数据之外ProcessWindowFunction 还可以获取到一个上下文对象(Context)。这个上下文对象非常强大，不仅能够获取窗口信息，还可以访问当前的时间和状态信息。这里的时间就包括了处理时间(processing time)和事件时间水位线(event time watermark)。这就使得 ProcessWindowFunction 更加灵活、功能更加丰富。</p>
<p>作为一个全窗口函数， ProcessWindowFunction 同样需要将所有数据缓存下来、等到窗口触发计算时才使用。它其实就是一个增强版的WindowFunction。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    SingleOutputStreamOperator&lt;Event&gt; stream = env.addSource(<span class="keyword">new</span> ClickSource())</span><br><span class="line">            .assignTimestampsAndWatermarks(WatermarkStrategy.&lt;Event&gt;forBoundedOutOfOrderness(Duration.ZERO)</span><br><span class="line">                    .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Event&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Event element, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> element.timestamp;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数据全部发往同一分区，按窗口统计UV</span></span><br><span class="line">    stream.keyBy(data -&gt; <span class="keyword">true</span>)</span><br><span class="line">            .window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">10</span>)))</span><br><span class="line">            .process(<span class="keyword">new</span> UvCountByWindow())</span><br><span class="line">            .print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义窗口处理函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UvCountByWindow</span> <span class="keyword">extends</span> <span class="title">ProcessWindowFunction</span>&lt;<span class="title">Event</span>, <span class="title">String</span>, <span class="title">Boolean</span>, <span class="title">TimeWindow</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Boolean aBoolean, Context context, Iterable&lt;Event&gt; elements, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        HashSet&lt;String&gt; userSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">// 遍历所有数据，放到Set里去重</span></span><br><span class="line">        <span class="keyword">for</span> (Event event: elements)&#123;</span><br><span class="line">            userSet.add(event.user);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结合窗口信息，包装输出内容</span></span><br><span class="line">        Long start = context.window().getStart();</span><br><span class="line">        Long end = context.window().getEnd();</span><br><span class="line">        out.collect(<span class="string">&quot;窗口: &quot;</span> + <span class="keyword">new</span> Timestamp(start) + <span class="string">&quot; ~ &quot;</span> + <span class="keyword">new</span> Timestamp(end)</span><br><span class="line">                + <span class="string">&quot; 的独立访客数量是：&quot;</span> + userSet.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全窗口函数因为运行效率较低，很少直接单独使用，往往会和增量聚合函数结合在一起，共同实现窗口的处理计算。</p>
<h4 id="增量聚合和全窗口函数的结合使用"><a href="#增量聚合和全窗口函数的结合使用" class="headerlink" title="增量聚合和全窗口函数的结合使用"></a>增量聚合和全窗口函数的结合使用</h4><p>我们之前在调用 WindowedStream 的.reduce()和.aggregate()方法时，只是简单地直接传入了一个 ReduceFunction 或 AggregateFunction 进行增量聚合。除此之外，其实还可以传入第二个参数：一个全窗口函数，可以是 WindowFunction 或者 ProcessWindowFunction。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReduceFunction 与 WindowFunction 结合</span></span><br><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">SingleOutputStreamOperator&lt;R&gt; <span class="title">reduce</span><span class="params">(ReduceFunction&lt;T&gt; reduceFunction, WindowFunction&lt;T, R, K, W&gt; function)</span></span></span><br><span class="line"><span class="function"><span class="comment">// ReduceFunction 与 ProcessWindowFunction 结合</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;R&gt; SingleOutputStreamOperator&lt;R&gt; <span class="title">reduce</span><span class="params">(ReduceFunction&lt;T&gt; reduceFunction, ProcessWindowFunction&lt;T, R, K, W&gt; function)</span></span></span><br><span class="line"><span class="function"><span class="comment">// AggregateFunction 与 WindowFunction 结合</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;ACC, V, R&gt; SingleOutputStreamOperator&lt;R&gt; <span class="title">aggregate</span><span class="params">(AggregateFunction&lt;T, ACC, V&gt; aggFunction, WindowFunction&lt;V, R, K, W&gt; windowFunction)</span></span></span><br><span class="line"><span class="function"><span class="comment">// AggregateFunction 与 ProcessWindowFunction 结合</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;ACC, V, R&gt; SingleOutputStreamOperator&lt;R&gt; <span class="title">aggregate</span><span class="params">(AggregateFunction&lt;T, ACC, V&gt; aggFunction, ProcessWindowFunction&lt;V, R, K, W&gt; windowFunction)</span></span></span><br></pre></td></tr></table></figure>

<p>这样调用的处理机制是：基于第一个参数(增量聚合函数)来处理窗口数据，每来一个数据就做一次聚合；等到窗口需要触发计算时，则调用第二个参数(全窗口函数)的处理逻辑输出结果。需要注意的是，这里的<strong>全窗口函数就不再缓存所有数据</strong>了，而是<strong>直接将增量聚合函数的结果拿来当作了 Iterable 类型的输入</strong>。一般情况下，这时的<strong>可迭代集合中就只有一个元素</strong>了。</p>
<p>下面我们举一个具体的实例来说明。在网站的各种统计指标中，一个很重要的统计指标就是热门的链接；想要得到热门的url，前提是得到每个链接的热门度。一般情况下，可以用 url 的浏览量(点击量)表示热门度。我们这里统计 10 秒钟的 url 浏览量，每 5 秒钟更新一次；另外为了更加清晰地展示，还应该把窗口的起始结束时间一起输出。我们可以定义滑动窗口，并结合增量聚合函数和全窗口函数来得到统计结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//POJO 类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UrlViewCount</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String url;</span><br><span class="line">    <span class="keyword">public</span> Long count;</span><br><span class="line">    <span class="keyword">public</span> Long windowStart;</span><br><span class="line">    <span class="keyword">public</span> Long windowEnd;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UrlViewCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UrlViewCount</span><span class="params">(String url, Long count, Long windowStart, Long windowEnd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">        <span class="keyword">this</span>.windowStart = windowStart;</span><br><span class="line">        <span class="keyword">this</span>.windowEnd = windowEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;UrlViewCount&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;url=&#x27;&quot;</span> + url + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, count=&quot;</span> + count +</span><br><span class="line">                <span class="string">&quot;, windowStart=&quot;</span> + <span class="keyword">new</span> Timestamp(windowStart) +</span><br><span class="line">                <span class="string">&quot;, windowEnd=&quot;</span> + <span class="keyword">new</span> Timestamp(windowEnd) +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    SingleOutputStreamOperator&lt;Event&gt; stream = env.addSource(<span class="keyword">new</span> ClickSource())</span><br><span class="line">            .assignTimestampsAndWatermarks(WatermarkStrategy.&lt;Event&gt;forMonotonousTimestamps()</span><br><span class="line">                    .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Event&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Event element, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> element.timestamp;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要按照url分组，开滑动窗口统计</span></span><br><span class="line">    stream.keyBy(data -&gt; data.url)</span><br><span class="line">            .window(SlidingEventTimeWindows.of(Time.seconds(<span class="number">10</span>), Time.seconds(<span class="number">5</span>)))</span><br><span class="line">            <span class="comment">// 同时传入增量聚合函数和全窗口函数</span></span><br><span class="line">            .aggregate(<span class="keyword">new</span> UrlViewCountAgg(), <span class="keyword">new</span> UrlViewCountResult())</span><br><span class="line">            .print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义增量聚合函数，来一条数据就加一</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UrlViewCountAgg</span> <span class="keyword">implements</span> <span class="title">AggregateFunction</span>&lt;<span class="title">Event</span>, <span class="title">Long</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">createAccumulator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">add</span><span class="params">(Event value, Long accumulator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accumulator + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getResult</span><span class="params">(Long accumulator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accumulator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">merge</span><span class="params">(Long a, Long b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义窗口处理函数，只需要包装窗口信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UrlViewCountResult</span> <span class="keyword">extends</span> <span class="title">ProcessWindowFunction</span>&lt;<span class="title">Long</span>, <span class="title">UrlViewCount</span>, <span class="title">String</span>, <span class="title">TimeWindow</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String url, Context context, Iterable&lt;Long&gt; elements, Collector&lt;UrlViewCount&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 结合窗口信息，包装输出内容</span></span><br><span class="line">        Long start = context.window().getStart();</span><br><span class="line">        Long end = context.window().getEnd();</span><br><span class="line">        <span class="comment">// 迭代器中只有一个元素，就是增量聚合函数的计算结果</span></span><br><span class="line">        out.collect(<span class="keyword">new</span> UrlViewCount(url, elements.iterator().next(), start, end));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中用一个 AggregateFunction 来实现增量聚合，每来一个数据就计数加一；得到的结果交给 ProcessWindowFunction，结合窗口信息包装成我们想要的 UrlViewCount，最终输出统计结果。</p>
<h3 id="其他API"><a href="#其他API" class="headerlink" title="其他API"></a>其他API</h3><h4 id="触发器-Trigger"><a href="#触发器-Trigger" class="headerlink" title="触发器(Trigger)"></a>触发器(Trigger)</h4><p>触发器主要是用来控制窗口什么时候触发计算。所谓的触发计算，本质上就是执行窗口函数，所以可以认为是计算得到结果并输出的过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stream.keyBy(...)</span><br><span class="line">      .window(...)</span><br><span class="line">      .trigger(<span class="keyword">new</span> MyTrigger())</span><br></pre></td></tr></table></figure>

<p>Trigger 是窗口算子的内部属性，每个窗口分配器(WindowAssigner)都会对应一个默认的触发器；对于 Flink 内置的窗口类型，它们的触发器都已经做了实现。例如，所有事件时间窗口，默认的触发器都是 EventTimeTrigger；类似还有 ProcessingTimeTrigger 和 CountTrigger。 所以一般情况下是不需要自定义触发器的，不过我们依然有必要了解它的原理。</p>
<p>Trigger 是一个抽象类，自定义时必须实现下面四个抽象方法：</p>
<p>onElement()：窗口中每到来一个元素，都会调用这个方法。</p>
<p>onEventTime()：当注册的事件时间定时器触发时，将调用这个方法。</p>
<p>onProcessingTime ()：当注册的处理时间定时器触发时，将调用这个方法。</p>
<p>clear()：当窗口关闭销毁时，调用这个方法。一般用来清除自定义的状态。</p>
<p>除了 clear() 比较像生命周期方法，其他三个方法其实都是对某种事件的响应。 onElement() 是对流中数据元素到来的响应；而另两个则是对时间的响应。这几个方法的参数中都有一个触发器上下文(TriggerContext)对象，可以用来注册定时器回调(callback)。这里提到的定时器(Timer)，其实就是我们设定的一个闹钟，代表未来某个时间点会执行的事件；当时间进展到设定的值时，就会执行定义好的操作。</p>
<p>上面的前三个方法可以响应事件，那它们又是怎样跟窗口操作联系起来的呢？这就需要了解一下它们的返回值。这<strong>三个方法返回类型都是 TriggerResult</strong>，这是一个枚举类型(enum)， 其中定义了对窗口进行操作的四种类型。</p>
<p>CONTINUE(继续)：什么都不做</p>
<p>FIRE(触发)：触发计算，输出结果</p>
<p>PURGE(清除)：清空窗口中的所有数据，销毁窗口</p>
<p>FIRE_AND_PURGE(触发并清除)：触发计算输出结果，并清除窗口</p>
<p>在日常业务场景中，我们经常会开比较大的窗口来计算每个窗口的 pv 或者 uv 等数据。但窗口开的太大，会使我们看到计算结果的时间间隔变长。所以我们可以使用触发器，来隔一段时间触发一次窗口计算。我们在代码中计算了每个 url 在 10 秒滚动窗口的 pv 指标，然后设置了触发器，每隔 1 秒钟触发一次窗口的计算。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    env</span><br><span class="line">            .addSource(<span class="keyword">new</span> ClickSource())</span><br><span class="line">            .assignTimestampsAndWatermarks(</span><br><span class="line">                    WatermarkStrategy.&lt;Event&gt;forMonotonousTimestamps()</span><br><span class="line">                            .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Event&gt;() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Event event, <span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">                                    <span class="keyword">return</span> event.timestamp;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;)</span><br><span class="line">            )</span><br><span class="line">            .keyBy(r -&gt; r.url)</span><br><span class="line">            .window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">10</span>)))</span><br><span class="line">            .trigger(<span class="keyword">new</span> MyTrigger())</span><br><span class="line">            .process(<span class="keyword">new</span> WindowResult())</span><br><span class="line">            .print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowResult</span> <span class="keyword">extends</span> <span class="title">ProcessWindowFunction</span>&lt;<span class="title">Event</span>, <span class="title">UrlViewCount</span>, <span class="title">String</span>, <span class="title">TimeWindow</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String s, Context context, Iterable&lt;Event&gt; iterable, Collector&lt;UrlViewCount&gt; collector)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        collector.collect(</span><br><span class="line">                <span class="keyword">new</span> UrlViewCount(</span><br><span class="line">                        s,</span><br><span class="line">                        <span class="comment">// 获取迭代器中的元素个数</span></span><br><span class="line">                        iterable.spliterator().getExactSizeIfKnown(),</span><br><span class="line">                        context.window().getStart(),</span><br><span class="line">                        context.window().getEnd()</span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTrigger</span> <span class="keyword">extends</span> <span class="title">Trigger</span>&lt;<span class="title">Event</span>, <span class="title">TimeWindow</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TriggerResult <span class="title">onElement</span><span class="params">(Event event, <span class="keyword">long</span> l, TimeWindow timeWindow, TriggerContext triggerContext)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ValueState&lt;Boolean&gt; isFirstEvent = triggerContext.getPartitionedState(</span><br><span class="line">                <span class="keyword">new</span> ValueStateDescriptor&lt;Boolean&gt;(<span class="string">&quot;first-event&quot;</span>, Types.BOOLEAN)</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (isFirstEvent.value() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> i = timeWindow.getStart(); i &lt; timeWindow.getEnd(); i = i + <span class="number">1000L</span>) &#123;</span><br><span class="line">                triggerContext.registerEventTimeTimer(i);</span><br><span class="line">            &#125;</span><br><span class="line">            isFirstEvent.update(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> TriggerResult.CONTINUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TriggerResult <span class="title">onEventTime</span><span class="params">(<span class="keyword">long</span> l, TimeWindow timeWindow, TriggerContext triggerContext)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> TriggerResult.FIRE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TriggerResult <span class="title">onProcessingTime</span><span class="params">(<span class="keyword">long</span> l, TimeWindow timeWindow, TriggerContext triggerContext)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> TriggerResult.CONTINUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(TimeWindow timeWindow, TriggerContext triggerContext)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ValueState&lt;Boolean&gt; isFirstEvent = triggerContext.getPartitionedState(</span><br><span class="line">                <span class="keyword">new</span> ValueStateDescriptor&lt;Boolean&gt;(<span class="string">&quot;first-event&quot;</span>, Types.BOOLEAN)</span><br><span class="line">        );</span><br><span class="line">        isFirstEvent.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="移除器-Evictor"><a href="#移除器-Evictor" class="headerlink" title="移除器(Evictor)"></a>移除器(Evictor)</h4><p>移除器主要用来定义移除某些数据的逻辑。基于 WindowedStream 调用.evictor()方法，就可以传入一个自定义的移除器(Evictor)。Evictor 是一个接口，不同的窗口类型都有各自预实现的移除器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stream.keyBy(...)</span><br><span class="line">      .window(...)</span><br><span class="line">      .evictor(<span class="keyword">new</span> MyEvictor())</span><br></pre></td></tr></table></figure>

<p>Evictor 接口定义了两个方法:</p>
<p>evictBefore()：定义执行窗口函数之前的移除数据操作。</p>
<p>evictAfter()：定义执行窗口函数之后的以处数据操作默认情况下，预实现的移除器都是在执行窗口函数(window fucntions)之前移除数据的。</p>
<h4 id="允许延迟-Allowed-Lateness"><a href="#允许延迟-Allowed-Lateness" class="headerlink" title="允许延迟(Allowed Lateness)"></a>允许延迟(Allowed Lateness)</h4><p>在事件时间语义下，窗口中可能会出现数据迟到的情况。这是因为在乱序流中，水位线 (watermark)并不一定能保证时间戳更早的所有数据不会再来。当水位线已经到达窗口结束时间时，窗口会触发计算并输出结果，这时一般也就要销毁窗口了；如果窗口关闭之后，又有本属于窗口内的数据姗姗来迟，默认情况下就会被丢弃。这也很好理解：窗口触发计算就像发车，如果要赶的车已经开走了，又不能坐其他的车(保证分配窗口的正确性)，那就只好放弃坐班了。</p>
<p>不过在多数情况下，直接丢弃数据也会导致统计结果不准确，我们还是希望该上车的人都能上来。为了解决迟到数据的问题，Flink 提供了一个特殊的接口，可以为窗口算子设置一个允许的最大延迟(Allowed Lateness)。也就是说，我们可以设定允许延迟一段时间，在这段时间内，窗口不会销毁，<strong>继续到来的数据依然可以进入窗口中并触发计算</strong>。直到水位线推进到了窗口结束时间 + 延迟时间，才真正将窗口的内容清空，正式关闭窗口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stream.keyBy(...)</span><br><span class="line">      .window(TumblingEventTimeWindows.of(Time.hours(<span class="number">1</span>)))</span><br><span class="line">      .allowedLateness(Time.minutes(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<h4 id="侧输出流"><a href="#侧输出流" class="headerlink" title="侧输出流"></a>侧输出流</h4><p>Flink 还提供了另外一种方式处理迟到数据。我们可以将未收入窗口的迟到数据，放入侧输出流(side output)进行另外的处理。所谓的侧输出流，相当于是数据流的一个分支，这个流中单独放置那些错过了该上的车、本该被丢弃的数据。</p>
<p>基于 WindowedStream 调用.sideOutputLateData() 方法，就可以实现这个功能。方法需要传入一个输出标签(OutputTag)，用来标记分支的迟到数据流。因为保存的就是流中的原始数据，所以 OutputTag 的类型与流中数据<strong>类型相同</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取socket文本流</span></span><br><span class="line">    SingleOutputStreamOperator&lt;Event&gt; stream =</span><br><span class="line">            env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">7777</span>)</span><br><span class="line">                    .map(<span class="keyword">new</span> MapFunction&lt;String, Event&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> Event <span class="title">map</span><span class="params">(String value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            String[] fields = value.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">new</span> Event(fields[<span class="number">0</span>].trim(), fields[<span class="number">1</span>].trim(), Long.valueOf(fields[<span class="number">2</span>].trim()));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    <span class="comment">// 方式一：设置watermark延迟时间，2秒钟</span></span><br><span class="line">                    .assignTimestampsAndWatermarks(WatermarkStrategy.&lt;Event&gt;forBoundedOutOfOrderness(Duration.ofSeconds(<span class="number">2</span>))</span><br><span class="line">                            .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Event&gt;() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Event element, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                                    <span class="keyword">return</span> element.timestamp;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义侧输出流标签</span></span><br><span class="line">    OutputTag&lt;Event&gt; outputTag = <span class="keyword">new</span> OutputTag&lt;Event&gt;(<span class="string">&quot;late&quot;</span>)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    SingleOutputStreamOperator&lt;UrlViewCount&gt; result = stream.keyBy(data -&gt; data.url)</span><br><span class="line">            .window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">10</span>)))</span><br><span class="line">            <span class="comment">// 方式二：允许窗口处理迟到数据，设置1分钟的等待时间</span></span><br><span class="line">            .allowedLateness(Time.minutes(<span class="number">1</span>))</span><br><span class="line">            <span class="comment">// 方式三：将最后的迟到数据输出到侧输出流</span></span><br><span class="line">            .sideOutputLateData(outputTag)</span><br><span class="line">            .aggregate(<span class="keyword">new</span> UrlViewCountAgg(), <span class="keyword">new</span> UrlViewCountResult());</span><br><span class="line"></span><br><span class="line">    result.print(<span class="string">&quot;result&quot;</span>);</span><br><span class="line">    result.getSideOutput(outputTag).print(<span class="string">&quot;late&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为方便观察，可以将原始数据也输出</span></span><br><span class="line">    stream.print(<span class="string">&quot;input&quot;</span>);</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UrlViewCountAgg</span> <span class="keyword">implements</span> <span class="title">AggregateFunction</span>&lt;<span class="title">Event</span>, <span class="title">Long</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">createAccumulator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">add</span><span class="params">(Event value, Long accumulator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accumulator + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getResult</span><span class="params">(Long accumulator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accumulator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">merge</span><span class="params">(Long a, Long b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UrlViewCountResult</span> <span class="keyword">extends</span> <span class="title">ProcessWindowFunction</span>&lt;<span class="title">Long</span>, <span class="title">UrlViewCount</span>, <span class="title">String</span>, <span class="title">TimeWindow</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String url, Context context, Iterable&lt;Long&gt; elements, Collector&lt;UrlViewCount&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 结合窗口信息，包装输出内容</span></span><br><span class="line">        Long start = context.window().getStart();</span><br><span class="line">        Long end = context.window().getEnd();</span><br><span class="line">        out.collect(<span class="keyword">new</span> UrlViewCount(url, elements.iterator().next(), start, end));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里注意，getSideOutput() 是 SingleOutputStreamOperator 的方法，获取到的侧输出流数据类型应该和 OutputTag 指定的类型一致，与窗口聚合之后流中的数据类型<strong>可以不同</strong>。</p>
<h3 id="窗口的生命周期"><a href="#窗口的生命周期" class="headerlink" title="窗口的生命周期"></a>窗口的生命周期</h3><p><strong>1、窗口的创建</strong></p>
<p>窗口的类型和基本信息由窗口分配器(window assigners)指定，但窗口不会预先创建好，而是由数据驱动创建。当第一个应该属于这个窗口的数据元素到达时，就会创建对应的窗口。</p>
<p><strong>2、窗口计算的触发</strong></p>
<p>除了窗口分配器，每个窗口还会有自己的<strong>窗口函数(window functions)<strong>和</strong>触发器(trigger)<strong>。 窗口函数可以分为</strong>增量聚合函数</strong>和<strong>全窗口函数</strong>，主要定义了窗口中计算的逻辑；而触发器则是指定调用窗口函数的条件。</p>
<p>对于不同的窗口类型，触发计算的条件也会不同。例如，一个滚动事件时间窗口，应该在水位线到达窗口结束时间的时候触发计算，属于定点发车；而一个计数窗口，会在窗口中元素数量达到定义大小时触发计算，属于人满就发车。所以 Flink 预定义的窗口类型都有对应内置的触发器。</p>
<p>对于事件时间窗口而言，除去到达结束时间的定点发车，还有另一种情形。当我们设置了允许延迟，那么如果水位线超过了窗口结束时间、但还没有到达设定的最大延迟时间，这期间内到达的迟到数据也会触发窗口计算。这类似于没有准时赶上班车的人又追上了车，这时车要再次停靠、开门，将新的数据整合统计进来。</p>
<p><strong>3、窗口的销毁</strong></p>
<p>一般情况下，当时间达到了结束点，就会直接触发计算输出结果、进而清除状态销毁窗口。 这时窗口的销毁可以认为和触发计算是同一时刻。这里需要注意，Flink 中只对时间窗口(TimeWindow)有销毁机制；由于计数窗口(CountWindow)是基于全局窗口(GlobalWindw) 实现的，而全局窗口不会清除状态，所以就不会被销毁。</p>
<p>在特殊的场景下，窗口的销毁和触发计算会有所不同。事件时间语义下，如果设置了允许延迟，那么在水位线到达窗口结束时间时，仍然不会销毁窗口；窗口真正被完全删除的时间点， 是窗口的结束时间加上用户指定的允许延迟时间。</p>
<p><strong>4、窗口 API 调用总结</strong></p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-03-23%20%E4%B8%8B%E5%8D%888.50.24.png" alt="截屏2022-03-23 下午8.50.24"></p>
<h2 id="WaterMark"><a href="#WaterMark" class="headerlink" title="WaterMark"></a>WaterMark</h2><p>水位线 = 观察到的最大事件时间 – 最大延迟时间 – 1 毫秒</p>
<p>Flink<strong>内置</strong>了两个WaterMark生成器：</p>
<p>1、Monotonously Increasing Timestamps(时间戳单调增长：其实就是允许的延迟为0)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有序流</span></span><br><span class="line">WatermarkStrategy.forMonotonousTimestamps();</span><br></pre></td></tr></table></figure>

<p>2、Fixed Amount of Lateness(允许固定时间的延迟)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//乱序流</span></span><br><span class="line">WatermarkStrategy.forBoundedOutOfOrderness(Duration.ofSeconds(<span class="number">10</span>));</span><br></pre></td></tr></table></figure>

<h3 id="WatermarkTest"><a href="#WatermarkTest" class="headerlink" title="WatermarkTest"></a>WatermarkTest</h3><p><strong>Flink 内置水位线生成器</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数据源改为socket文本流，并转换成Event类型</span></span><br><span class="line">    env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">7777</span>)</span><br><span class="line">            .map(<span class="keyword">new</span> MapFunction&lt;String, Event&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Event <span class="title">map</span><span class="params">(String value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    String[] fields = value.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> Event(fields[<span class="number">0</span>].trim(), fields[<span class="number">1</span>].trim(), Long.valueOf(fields[<span class="number">2</span>].trim()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment">// 插入水位线的逻辑</span></span><br><span class="line">            .assignTimestampsAndWatermarks(</span><br><span class="line">                    <span class="comment">// 针对乱序流插入水位线，延迟时间设置为5s</span></span><br><span class="line">                    WatermarkStrategy.&lt;Event&gt;forBoundedOutOfOrderness(Duration.ofSeconds(<span class="number">5</span>))</span><br><span class="line">                            .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Event&gt;() &#123;</span><br><span class="line">                                <span class="comment">// 抽取时间戳的逻辑</span></span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Event element, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                                    <span class="keyword">return</span> element.timestamp;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;)</span><br><span class="line">            )</span><br><span class="line">            <span class="comment">// 根据user分组，开窗统计</span></span><br><span class="line">            .keyBy(data -&gt; data.user)</span><br><span class="line">            .window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">10</span>)))</span><br><span class="line">            .process(<span class="keyword">new</span> WatermarkTestResult())</span><br><span class="line">            .print();</span><br><span class="line"></span><br><span class="line">    env.execute(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义处理窗口函数，输出当前的水位线和窗口信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WatermarkTestResult</span> <span class="keyword">extends</span> <span class="title">ProcessWindowFunction</span>&lt;<span class="title">Event</span>, <span class="title">String</span>, <span class="title">String</span>, <span class="title">TimeWindow</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String s, Context context, Iterable&lt;Event&gt; elements, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Long start = context.window().getStart();</span><br><span class="line">        Long end = context.window().getEnd();</span><br><span class="line">        Long currentWatermark = context.currentWatermark();</span><br><span class="line">        Long count = elements.spliterator().getExactSizeIfKnown();</span><br><span class="line">        out.collect(<span class="string">&quot;窗口&quot;</span> + start + <span class="string">&quot; ~ &quot;</span> + end + <span class="string">&quot;中共有&quot;</span> + count + <span class="string">&quot;个元素，窗口闭合计算时，水位线处于：&quot;</span> + currentWatermark);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>自定义WatermarkStrategy：</strong></p>
<p>有2种风格的WaterMark生产方式：periodic(周期性) and punctuated(间歇性)，都需要继承接口<strong>WatermarkGenerator</strong>。</p>
<p>onEvent()和 onPeriodicEmit()，前者是在<strong>每个事件到来时调用</strong>，而后者<strong>由框架周期性调用</strong>。周期性调用的方法中发出水位线，自然就是周期性生成水位线；而在事件触发的方法中发出水位线，自然就是断点式生成了。两种方式的不同就集中体现在这两个方法的实现上。</p>
<h3 id="CustomWatermarkTest"><a href="#CustomWatermarkTest" class="headerlink" title="CustomWatermarkTest"></a>CustomWatermarkTest</h3><p>自定义水位线策略</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    env</span><br><span class="line">            .addSource(<span class="keyword">new</span> ClickSource())</span><br><span class="line">            .assignTimestampsAndWatermarks(<span class="keyword">new</span> CustomWatermarkStrategy())</span><br><span class="line">            .print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomWatermarkStrategy</span> <span class="keyword">implements</span> <span class="title">WatermarkStrategy</span>&lt;<span class="title">Event</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TimestampAssigner&lt;Event&gt; <span class="title">createTimestampAssigner</span><span class="params">(TimestampAssignerSupplier.Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SerializableTimestampAssigner&lt;Event&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Event element, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> element.timestamp; <span class="comment">// 告诉程序数据源里的时间戳是哪一个字段</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WatermarkGenerator&lt;Event&gt; <span class="title">createWatermarkGenerator</span><span class="params">(WatermarkGeneratorSupplier.Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomPeriodicGenerator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//periodic</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomPeriodicGenerator</span> <span class="keyword">implements</span> <span class="title">WatermarkGenerator</span>&lt;<span class="title">Event</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long delayTime = <span class="number">5000L</span>; <span class="comment">// 延迟时间</span></span><br><span class="line">    <span class="keyword">private</span> Long maxTs = Long.MIN_VALUE + delayTime + <span class="number">1L</span>; <span class="comment">// 观察到的最大时间戳</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event event, <span class="keyword">long</span> eventTimestamp, WatermarkOutput output)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 每来一条数据就调用一次</span></span><br><span class="line">        maxTs = Math.max(event.timestamp, maxTs); <span class="comment">// 更新最大时间戳</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPeriodicEmit</span><span class="params">(WatermarkOutput output)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 发射水位线，默认200ms调用一次</span></span><br><span class="line">        output.emitWatermark(<span class="keyword">new</span> Watermark(maxTs - delayTime - <span class="number">1L</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//punctuated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomPunctuatedGenerator</span> <span class="keyword">implements</span> <span class="title">WatermarkGenerator</span>&lt;<span class="title">Event</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event r, <span class="keyword">long</span> eventTimestamp, WatermarkOutput output)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只有在遇到特定的 itemId 时，才发出水位线 </span></span><br><span class="line">        <span class="keyword">if</span> (r.user.equals(<span class="string">&quot;Mary&quot;</span>)) &#123;</span><br><span class="line">            output.emitWatermark(<span class="keyword">new</span> Watermark(r.timestamp - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPeriodicEmit</span><span class="params">(WatermarkOutput output)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不需要做任何事情，因为我们在 onEvent 方法中发射了水位线</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="EmitWatermarkInSourceFunction"><a href="#EmitWatermarkInSourceFunction" class="headerlink" title="EmitWatermarkInSourceFunction"></a>EmitWatermarkInSourceFunction</h3><p>我们也可以在自定义的数据源中抽取事件时间，然后发送水位线。这里要注意的是，在自定义数据源中发送了水位线以后，就不能再在程序中使用 assignTimestampsAndWatermarks 方法来生成水位线了。在自定义数据源中生成水位线和在程序中使用 assignTimestampsAndWatermarks 方法生成水位线<strong>二者只能取其一</strong>。</p>
<p>在自定义水位线中生成水位线相比 assignTimestampsAndWatermarks 方法更加灵活，可以任意的产生周期性的、非周期性的水位线，以及水位线的大小也完全由我们自定义。所以非常适合用来编写 Flink 的测试程序，测试 Flink 的各种各样的特性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    env.addSource(<span class="keyword">new</span> ClickSourceWithWatermark()).print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClickSourceWithWatermark</span> <span class="keyword">implements</span> <span class="title">SourceFunction</span>&lt;<span class="title">Event</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> running = <span class="keyword">true</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(SourceContext&lt;Event&gt; sourceContext)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        String[] userArr = &#123;<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Alice&quot;</span>&#125;;</span><br><span class="line">        String[] urlArr  = &#123;<span class="string">&quot;./home&quot;</span>, <span class="string">&quot;./cart&quot;</span>, <span class="string">&quot;./prod?id=1&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            <span class="keyword">long</span> currTs = Calendar.getInstance().getTimeInMillis(); <span class="comment">// 毫秒时间戳</span></span><br><span class="line">            String username = userArr[random.nextInt(userArr.length)];</span><br><span class="line">            String url      = urlArr[random.nextInt(urlArr.length)];</span><br><span class="line">            Event event = <span class="keyword">new</span> Event(username, url, currTs);</span><br><span class="line">            <span class="comment">// 使用collectWithTimestamp方法将数据发送出去，并指明数据中的时间戳的字段</span></span><br><span class="line">            sourceContext.collectWithTimestamp(event, event.timestamp);</span><br><span class="line">            <span class="comment">// 发送水位线</span></span><br><span class="line">            sourceContext.emitWatermark(<span class="keyword">new</span> Watermark(event.timestamp - <span class="number">1L</span>));</span><br><span class="line">            Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        running = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ProcessFunction-API"><a href="#ProcessFunction-API" class="headerlink" title="ProcessFunction API"></a>ProcessFunction API</h2><p>处理函数提供了一个定时服务 (TimerService)，我们可以通过它访问流中的事件(event)、时间戳(timestamp)、水位线 (watermark)，甚至可以注册定时事件。而且处理函数继承了 AbstractRichFunction 抽象类，所以拥有富函数类的所有特性，同样可以访问状态(state)和其他运行时信息。此外，处理函数还可以直接将数据输出到侧输出流(side output)中。所以，处理函数是最为灵活的处理方法，可以实现各种自定义的业务逻辑；同时也是整个 DataStream API 的底层基础。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    env</span><br><span class="line">            .addSource(<span class="keyword">new</span> ClickSource())</span><br><span class="line">            .assignTimestampsAndWatermarks(</span><br><span class="line">                    WatermarkStrategy.&lt;Event&gt;forMonotonousTimestamps()</span><br><span class="line">                            .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Event&gt;() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Event event, <span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">                                    <span class="keyword">return</span> event.timestamp;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;)</span><br><span class="line">            )</span><br><span class="line">            .process(<span class="keyword">new</span> ProcessFunction&lt;Event, String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(Event value, Context ctx, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (value.user.equals(<span class="string">&quot;Mary&quot;</span>)) &#123;</span><br><span class="line">                        out.collect(value.user);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value.user.equals(<span class="string">&quot;Bob&quot;</span>)) &#123;</span><br><span class="line">                        out.collect(value.user);</span><br><span class="line">                        out.collect(value.user);</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(ctx.timerService().currentWatermark());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象类 ProcessFunction 继承了 AbstractRichFunction，有两个泛型类型参数：I 表示 Input，也就是输入的数据类型；O 表示 Output，也就是处理完成之后输出的数据类型。</p>
<p>内部单独定义了两个方法：一个是必须要实现的抽象方法.processElement()；另一个是非抽象方法.onTimer()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessFunction</span>&lt;<span class="title">I</span>, <span class="title">O</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractRichFunction</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(I value, Context ctx, Collector&lt;O&gt; out)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTimer</span><span class="params">(<span class="keyword">long</span> timestamp, OnTimerContext ctx, Collector&lt;O&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>processElement()：</strong></p>
<p>value：当前流中的输入元素，也就是正在处理的数据，类型与流中数据类型一致。</p>
<p>ctx：类型是ProcessFunction中定义的内部抽象类Context，表示当前运行的上下文，可以获取到当前的时间戳，并提供了用于查询时间和注册定时器的定时服务(TimerService)，以及可以将数据发送到侧输出流(side output)的方法.output()。 Context 抽象类定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Long <span class="title">timestamp</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> TimerService <span class="title">timerService</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;X&gt; <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(OutputTag&lt;X&gt; outputTag, X value)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>out：收集器(类型为Collector)，用于返回输出数据。使用方式与 flatMap 算子中的收集器完全一样，直接调用 out.collect()方法就可以向下游发出一个数据。 这个方法可以多次调用，也可以不调用。</p>
<p><strong>onTimer()：</strong></p>
<p>用于定义定时触发的操作，这是一个非常强大、也非常有趣的功能。<strong>这个方法只有在注册好的定时器触发的时候才会调用，而定时器是通过定时服务TimerService 来注册的</strong>。打个比方，注册定时器(timer)就是设了一个闹钟，到了设定时间就会响；而.onTimer()中定义的， 就是闹钟响的时候要做的事。所以它本质上是一个基于时间的回调(callback)方法，通过时间的进展来触发；在事件时间语义下就是由水位线(watermark)来触发了。</p>
<p>与.processElement()类似，定时方法.onTimer()也有三个参数：时间戳(timestamp)，上下文(ctx)，以及收集器(out)。这里的 timestamp 是指设定好的触发时间，事件时间语义下当然就是水位线了。另外这里同样有上下文和收集器，所以也可以调用定时服务(TimerService)， 以及任意输出处理之后的数据。</p>
<p>既然有.onTimer()方法做定时触发，我们用 ProcessFunction 也可以自定义数据按照时间分组、定时触发计算输出结果；这其实就实现了窗口(window)的功能。所以说 ProcessFunction 是真正意义上的终极奥义，用它可以实现一切功能。</p>
<p>我们也可以看到，处理函数都是基于事件触发的。水位线就如同插入流中的一条数据一样；只不过处理真正的数据事件调用的是.processElement()方法，而处理水位线事件调用的是.onTimer()。</p>
<p>这里需要注意的是，上面的.onTimer()方法只是定时器触发时的操作，而定时器(timer) 真正的设置需要用到上下文 ctx 中的定时服务。在 Flink 中，只有按键分区流 KeyedStream 才支持设置定时器的操作。</p>
<p><strong>Flink 提供了 8 个不同的处理函数：</strong></p>
<h3 id="ProcessFunction"><a href="#ProcessFunction" class="headerlink" title="ProcessFunction"></a>ProcessFunction</h3><p>最基本的处理函数，基于 DataStream 直接调用.process()时作为参数传入。</p>
<h3 id="KeyedProcessFunction"><a href="#KeyedProcessFunction" class="headerlink" title="KeyedProcessFunction"></a>KeyedProcessFunction</h3><p>对流按键分区后的处理函数，基于 KeyedStream 调用.process()时作为参数传入。要想使用定时器，比如基于 KeyedStream。</p>
<h4 id="定时器-Timer-和定时服务-TimerService"><a href="#定时器-Timer-和定时服务-TimerService" class="headerlink" title="定时器(Timer)和定时服务(TimerService)"></a>定时器(Timer)和定时服务(TimerService)</h4><p>定时器(timers)是处理函数中进行时间相关操作的主要机制。在.onTimer()方法中可以实现定时处理的逻辑，而它能触发的前提，就是之前曾经注册过定时器、并且现在已经到了触发时间。注册定时器的功能，是通过上下文中提供的定时服务(TimerService)来实现的。</p>
<p>TimerService 是 Flink 关于时间和定时器的基础服务接口，包含以下六个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前的处理时间</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">currentProcessingTime</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前的水位线(事件时间) </span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">currentWatermark</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册处理时间定时器，当处理时间超过 time 时触发 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerProcessingTimeTimer</span><span class="params">(<span class="keyword">long</span> time)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册事件时间定时器，当水位线超过 time 时触发 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerEventTimeTimer</span><span class="params">(<span class="keyword">long</span> time)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除触发时间为 time 的处理时间定时器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteProcessingTimeTimer</span><span class="params">(<span class="keyword">long</span> time)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除触发时间为 time 的处理时间定时器 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteEventTimeTimer</span><span class="params">(<span class="keyword">long</span> time)</span></span>;</span><br></pre></td></tr></table></figure>

<p>需要注意，尽管处理函数中都可以直接访问 TimerService，不过只有基于 KeyedStream 的处理函数，才能去调用注册和删除定时器的方法；未作按键分区的 DataStream 不支持定时器操作，只能获取当前时间。</p>
<p>基于 KeyedStream 注册定时器时，会传入一个定时器触发的时间戳，这个时间戳的定时器对于每个 key 都是有效的。这样，我们的代码并不需要做额外的处理，底层就可以直接对不同 key 进行独立的处理操作了。</p>
<p>利用这个特性，有时我们可以故意降低时间戳的精度，来减少定时器的数量，从而提高处理性能。比如我们可以在设置定时器时只保留整秒数，那么定时器的触发频率就是最多 1 秒一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> coalescedTime = time / <span class="number">1000</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">ctx.timerService().registerProcessingTimeTimer(coalescedTime);</span><br></pre></td></tr></table></figure>

<p>这里注意<strong>定时器的时间戳必须是毫秒数</strong>，所以我们得到整秒之后还要乘以1000。定时器默认的区分精度是毫秒。</p>
<p><strong>EventTimeTimerTest：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    SingleOutputStreamOperator&lt;Event&gt; stream = env.addSource(<span class="keyword">new</span> CustomSource())</span><br><span class="line">            .assignTimestampsAndWatermarks(WatermarkStrategy.&lt;Event&gt;forMonotonousTimestamps()</span><br><span class="line">                    .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Event&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Event element, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> element.timestamp;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于KeyedStream定义事件时间定时器</span></span><br><span class="line">    stream.keyBy(data -&gt; <span class="keyword">true</span>)</span><br><span class="line">            .process(<span class="keyword">new</span> KeyedProcessFunction&lt;Boolean, Event, String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(Event value, Context ctx, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    out.collect(<span class="string">&quot;数据到达，时间戳为：&quot;</span> + ctx.timestamp());</span><br><span class="line">                    out.collect(<span class="string">&quot;数据到达，水位线为：&quot;</span> + ctx.timerService().currentWatermark() + <span class="string">&quot;\n -------分割线-------&quot;</span>);</span><br><span class="line">                    <span class="comment">// 注册一个10秒后的定时器</span></span><br><span class="line">                    ctx.timerService().registerEventTimeTimer(ctx.timestamp() + <span class="number">10</span> * <span class="number">1000L</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTimer</span><span class="params">(<span class="keyword">long</span> timestamp, OnTimerContext ctx, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    out.collect(<span class="string">&quot;定时器触发，触发时间：&quot;</span> + timestamp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义测试数据源</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomSource</span> <span class="keyword">implements</span> <span class="title">SourceFunction</span>&lt;<span class="title">Event</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(SourceContext&lt;Event&gt; ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 直接发出测试数据</span></span><br><span class="line">        ctx.collect(<span class="keyword">new</span> Event(<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">1000L</span>));</span><br><span class="line">        <span class="comment">// 为了更加明显，中间停顿5秒钟</span></span><br><span class="line">        Thread.sleep(<span class="number">5000L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发出10秒后的数据</span></span><br><span class="line">        ctx.collect(<span class="keyword">new</span> Event(<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">11000L</span>));</span><br><span class="line">        Thread.sleep(<span class="number">5000L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发出10秒+1ms后的数据</span></span><br><span class="line">        ctx.collect(<span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./cart&quot;</span>, <span class="number">11001L</span>));</span><br><span class="line">        Thread.sleep(<span class="number">5000L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ProcessWindowFunction"><a href="#ProcessWindowFunction" class="headerlink" title="ProcessWindowFunction"></a>ProcessWindowFunction</h3><p>开窗之后的处理函数，也是全窗口函数的代表。基于 WindowedStream 调用.process()时作为参数传入。</p>
<p>ProcessWindowFunction 既是处理函数又是全窗口函数。从名字上也可以推测出，它的本质似乎更倾向于窗口函数一些。事实上它的用法也确实跟其他处理函数有很大不同。我们可以从源码中的定义看到这一点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessWindowFunction</span>&lt;<span class="title">IN</span>, <span class="title">OUT</span>, <span class="title">KEY</span>, <span class="title">W</span> <span class="keyword">extends</span> <span class="title">Window</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractRichFunction</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(KEY key, Context context, Iterable&lt;IN&gt; elements, Collector&lt;OUT&gt; out)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="comment">//key:窗口做统计计算基于的键，也就是之前keyBy用来分区的字段</span></span><br><span class="line">  	<span class="comment">//context:当前窗口进行计算的上下文，它的类型就是ProcessWindowFunction内部定义的抽象类Context</span></span><br><span class="line">  	<span class="comment">//elements:窗口收集到用来计算的所有数据，这是一个可迭代的集合类型</span></span><br><span class="line">  	<span class="comment">//out:用来发送数据输出计算结果的收集器，类型为Collector</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(Context context)</span> <span class="keyword">throws</span> Exception </span>&#123;&#125;</span><br><span class="line">		</span><br><span class="line">  	<span class="comment">//上下文context所包含的内容也跟其他处理函数有所差别</span></span><br><span class="line">  	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">		    <span class="comment">/** Returns the window that is being evaluated. */</span></span><br><span class="line">		    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> W <span class="title">window</span><span class="params">()</span></span>;</span><br><span class="line">		</span><br><span class="line">		    <span class="comment">/** Returns the current processing time. */</span></span><br><span class="line">		    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">currentProcessingTime</span><span class="params">()</span></span>;</span><br><span class="line">		</span><br><span class="line">		    <span class="comment">/** Returns the current event-time watermark. */</span></span><br><span class="line">		    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">currentWatermark</span><span class="params">()</span></span>;</span><br><span class="line">		</span><br><span class="line">		    <span class="comment">/**</span></span><br><span class="line"><span class="comment">		     * State accessor for per-key and per-window state.</span></span><br><span class="line"><span class="comment">		     *</span></span><br><span class="line"><span class="comment">		     * &lt;p&gt;&lt;b&gt;<span class="doctag">NOTE:</span>&lt;/b&gt;If you use per-window state you have to ensure that you clean it up by</span></span><br><span class="line"><span class="comment">		     * implementing &#123;<span class="doctag">@link</span> ProcessWindowFunction#clear(Context)&#125;.</span></span><br><span class="line"><span class="comment">		     */</span></span><br><span class="line">		    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> KeyedStateStore <span class="title">windowState</span><span class="params">()</span></span>;</span><br><span class="line">		</span><br><span class="line">		    <span class="comment">/** State accessor for per-key global state. */</span></span><br><span class="line">		    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> KeyedStateStore <span class="title">globalState</span><span class="params">()</span></span>;</span><br><span class="line">		</span><br><span class="line">		    <span class="comment">/**</span></span><br><span class="line"><span class="comment">		     * Emits a record to the side output identified by the &#123;<span class="doctag">@link</span> OutputTag&#125;.</span></span><br><span class="line"><span class="comment">		     *</span></span><br><span class="line"><span class="comment">		     * <span class="doctag">@param</span> outputTag the &#123;<span class="doctag">@code</span> OutputTag&#125; that identifies the side output to emit to.</span></span><br><span class="line"><span class="comment">		     * <span class="doctag">@param</span> value The record to emit.</span></span><br><span class="line"><span class="comment">		     */</span></span><br><span class="line">		    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;X&gt; <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(OutputTag&lt;X&gt; outputTag, X value)</span></span>;</span><br><span class="line">		&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="KeyedProcessTopN"><a href="#KeyedProcessTopN" class="headerlink" title="KeyedProcessTopN"></a>KeyedProcessTopN</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//KeyedProcessTopN</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从自定义数据源读取数据</span></span><br><span class="line">    SingleOutputStreamOperator&lt;Event&gt; eventStream = env.addSource(<span class="keyword">new</span> ClickSource())</span><br><span class="line">            .assignTimestampsAndWatermarks(WatermarkStrategy.&lt;Event&gt;forMonotonousTimestamps()</span><br><span class="line">                    .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Event&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Event element, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> element.timestamp;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要按照url分组，求出每个url的访问量</span></span><br><span class="line">    SingleOutputStreamOperator&lt;UrlViewCount&gt; urlCountStream =</span><br><span class="line">            eventStream.keyBy(data -&gt; data.url)</span><br><span class="line">                    .window(SlidingEventTimeWindows.of(Time.seconds(<span class="number">10</span>), Time.seconds(<span class="number">5</span>)))</span><br><span class="line">                    .aggregate(<span class="keyword">new</span> UrlViewCountAgg(),</span><br><span class="line">                            <span class="keyword">new</span> UrlViewCountResult());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对结果中同一个窗口的统计数据，进行排序处理</span></span><br><span class="line">    SingleOutputStreamOperator&lt;String&gt; result = urlCountStream.keyBy(data -&gt; data.windowEnd)</span><br><span class="line">            .process(<span class="keyword">new</span> TopN(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    result.print(<span class="string">&quot;result&quot;</span>);</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义增量聚合</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UrlViewCountAgg</span> <span class="keyword">implements</span> <span class="title">AggregateFunction</span>&lt;<span class="title">Event</span>, <span class="title">Long</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">createAccumulator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">add</span><span class="params">(Event value, Long accumulator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accumulator + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getResult</span><span class="params">(Long accumulator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accumulator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">merge</span><span class="params">(Long a, Long b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义全窗口函数，只需要包装窗口信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UrlViewCountResult</span> <span class="keyword">extends</span> <span class="title">ProcessWindowFunction</span>&lt;<span class="title">Long</span>, <span class="title">UrlViewCount</span>, <span class="title">String</span>, <span class="title">TimeWindow</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String url, Context context, Iterable&lt;Long&gt; elements, Collector&lt;UrlViewCount&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 结合窗口信息，包装输出内容</span></span><br><span class="line">        Long start = context.window().getStart();</span><br><span class="line">        Long end = context.window().getEnd();</span><br><span class="line">        out.collect(<span class="keyword">new</span> UrlViewCount(url, elements.iterator().next(), start, end));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义处理函数，排序取top n</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TopN</span> <span class="keyword">extends</span> <span class="title">KeyedProcessFunction</span>&lt;<span class="title">Long</span>, <span class="title">UrlViewCount</span>, <span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 将n作为属性</span></span><br><span class="line">    <span class="keyword">private</span> Integer n;</span><br><span class="line">    <span class="comment">// 定义一个列表状态</span></span><br><span class="line">    <span class="keyword">private</span> ListState&lt;UrlViewCount&gt; urlViewCountListState;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TopN</span><span class="params">(Integer n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 从环境中获取列表状态</span></span><br><span class="line">        urlViewCountListState = getRuntimeContext().getListState(</span><br><span class="line">                <span class="keyword">new</span> ListStateDescriptor&lt;UrlViewCount&gt;(<span class="string">&quot;url-view-count-list&quot;</span>,</span><br><span class="line">                        Types.POJO(UrlViewCount.class)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(UrlViewCount value, Context ctx, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 将count数据添加到列表状态中，保存起来</span></span><br><span class="line">        urlViewCountListState.add(value);</span><br><span class="line">        <span class="comment">// 注册 window end + 1ms后的定时器，等待所有数据到齐开始排序</span></span><br><span class="line">        ctx.timerService().registerEventTimeTimer(ctx.getCurrentKey() + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTimer</span><span class="params">(<span class="keyword">long</span> timestamp, OnTimerContext ctx, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 将数据从列表状态变量中取出，放入ArrayList，方便排序</span></span><br><span class="line">        ArrayList&lt;UrlViewCount&gt; urlViewCountArrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (UrlViewCount urlViewCount : urlViewCountListState.get()) &#123;</span><br><span class="line">            urlViewCountArrayList.add(urlViewCount);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 清空状态，释放资源</span></span><br><span class="line">        urlViewCountListState.clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        urlViewCountArrayList.sort(<span class="keyword">new</span> Comparator&lt;UrlViewCount&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(UrlViewCount o1, UrlViewCount o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2.count.intValue() - o1.count.intValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取前两名，构建输出结果</span></span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        result.append(<span class="string">&quot;========================================\n&quot;</span>);</span><br><span class="line">        result.append(<span class="string">&quot;窗口结束时间：&quot;</span> + <span class="keyword">new</span> Timestamp(timestamp - <span class="number">1</span>) + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.n; i++) &#123;</span><br><span class="line">            UrlViewCount UrlViewCount = urlViewCountArrayList.get(i);</span><br><span class="line">            String info = <span class="string">&quot;No.&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot; &quot;</span></span><br><span class="line">                    + <span class="string">&quot;url：&quot;</span> + UrlViewCount.url + <span class="string">&quot; &quot;</span></span><br><span class="line">                    + <span class="string">&quot;浏览量：&quot;</span> + UrlViewCount.count + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            result.append(info);</span><br><span class="line">        &#125;</span><br><span class="line">        result.append(<span class="string">&quot;========================================\n&quot;</span>);</span><br><span class="line">        out.collect(result.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ProcessAllWindowFunction"><a href="#ProcessAllWindowFunction" class="headerlink" title="ProcessAllWindowFunction"></a>ProcessAllWindowFunction</h3><p>同样是开窗之后的处理函数，基于 AllWindowedStream 调用.process()时作为参数传入。</p>
<h4 id="ProcessAllWindowTopN"><a href="#ProcessAllWindowTopN" class="headerlink" title="ProcessAllWindowTopN"></a>ProcessAllWindowTopN</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ProcessAllWindowTopN</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    SingleOutputStreamOperator&lt;Event&gt; eventStream = env.addSource(<span class="keyword">new</span> ClickSource())</span><br><span class="line">            .assignTimestampsAndWatermarks(</span><br><span class="line">                    WatermarkStrategy.&lt;Event&gt;forMonotonousTimestamps()</span><br><span class="line">                            .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Event&gt;() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Event element, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                                    <span class="keyword">return</span> element.timestamp;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;)</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只需要url就可以统计数量，所以转换成String直接开窗统计</span></span><br><span class="line">    SingleOutputStreamOperator&lt;String&gt; result = eventStream</span><br><span class="line">            .map(<span class="keyword">new</span> MapFunction&lt;Event, String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">map</span><span class="params">(Event value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> value.url;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .windowAll(SlidingEventTimeWindows.of(Time.seconds(<span class="number">10</span>), Time.seconds(<span class="number">5</span>)))    <span class="comment">// 开滑动窗口</span></span><br><span class="line">            .process(<span class="keyword">new</span> ProcessAllWindowFunction&lt;String, String, TimeWindow&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Context context, Iterable&lt;String&gt; elements, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    HashMap&lt;String, Long&gt; urlCountMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                    <span class="comment">// 遍历窗口中数据，将浏览量保存到一个 HashMap 中</span></span><br><span class="line">                    <span class="keyword">for</span> (String url : elements) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (urlCountMap.containsKey(url)) &#123;</span><br><span class="line">                            <span class="keyword">long</span> count = urlCountMap.get(url);</span><br><span class="line">                            urlCountMap.put(url, count + <span class="number">1L</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            urlCountMap.put(url, <span class="number">1L</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ArrayList&lt;Tuple2&lt;String, Long&gt;&gt; mapList = <span class="keyword">new</span> ArrayList&lt;Tuple2&lt;String, Long&gt;&gt;();</span><br><span class="line">                    <span class="comment">// 将浏览量数据放入ArrayList，进行排序</span></span><br><span class="line">                    <span class="keyword">for</span> (String key : urlCountMap.keySet()) &#123;</span><br><span class="line">                        mapList.add(Tuple2.of(key, urlCountMap.get(key)));</span><br><span class="line">                    &#125;</span><br><span class="line">                    mapList.sort(<span class="keyword">new</span> Comparator&lt;Tuple2&lt;String, Long&gt;&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Tuple2&lt;String, Long&gt; o1, Tuple2&lt;String, Long&gt; o2)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> o2.f1.intValue() - o1.f1.intValue();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="comment">// 取排序后的前两名，构建输出结果</span></span><br><span class="line">                    StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                    result.append(<span class="string">&quot;========================================\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                        Tuple2&lt;String, Long&gt; temp = mapList.get(i);</span><br><span class="line">                        String info = <span class="string">&quot;浏览量No.&quot;</span> + (i + <span class="number">1</span>) +</span><br><span class="line">                                <span class="string">&quot; url：&quot;</span> + temp.f0 +</span><br><span class="line">                                <span class="string">&quot; 浏览量：&quot;</span> + temp.f1 +</span><br><span class="line">                                <span class="string">&quot; 窗口结束时间：&quot;</span> + <span class="keyword">new</span> Timestamp(context.window().getEnd()) + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">                        result.append(info);</span><br><span class="line">                    &#125;</span><br><span class="line">                    result.append(<span class="string">&quot;========================================\n&quot;</span>);</span><br><span class="line">                    out.collect(result.toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    result.print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CoProcessFunction"><a href="#CoProcessFunction" class="headerlink" title="CoProcessFunction"></a>CoProcessFunction</h3><p>合并(connect)两条流之后的处理函数，基于 ConnectedStreams 调用.process()时作为参数传入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CoProcessFunction</span>&lt;<span class="title">IN1</span>, <span class="title">IN2</span>, <span class="title">OUT</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractRichFunction</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">processElement1</span><span class="params">(IN1 value, Context ctx, Collector&lt;OUT&gt; out)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">processElement2</span><span class="params">(IN2 value, Context ctx, Collector&lt;OUT&gt; out)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTimer</span><span class="params">(<span class="keyword">long</span> timestamp, OnTimerContext ctx, Collector&lt;OUT&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它需要实现的就是 processElement1()、processElement2()两个方法，在每个数据到来时，会根据来源的流调用其中的一个方法进行处理。CoProcessFunction同样可以通过上下文ctx来访问 timestamp、水位线，并通过 TimerService 注册定时器；另外也提供了.onTimer()方法，用于定义定时触发的处理操作。</p>
<h4 id="实时对账"><a href="#实时对账" class="headerlink" title="实时对账"></a>实时对账</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BillCheckExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 来自app的支付日志</span></span><br><span class="line">        SingleOutputStreamOperator&lt;Tuple3&lt;String, String, Long&gt;&gt; appStream = env.fromElements(</span><br><span class="line">                Tuple3.of(<span class="string">&quot;order-1&quot;</span>, <span class="string">&quot;app&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">                Tuple3.of(<span class="string">&quot;order-2&quot;</span>, <span class="string">&quot;app&quot;</span>, <span class="number">2000L</span>)</span><br><span class="line">        ).assignTimestampsAndWatermarks(WatermarkStrategy.&lt;Tuple3&lt;String, String, Long&gt;&gt;forMonotonousTimestamps()</span><br><span class="line">                .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Tuple3&lt;String, String, Long&gt;&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Tuple3&lt;String, String, Long&gt; element, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> element.f2;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 来自第三方支付平台的支付日志</span></span><br><span class="line">        SingleOutputStreamOperator&lt;Tuple4&lt;String, String, String, Long&gt;&gt; thirdpartStream = env.fromElements(</span><br><span class="line">                Tuple4.of(<span class="string">&quot;order-1&quot;</span>, <span class="string">&quot;third-party&quot;</span>, <span class="string">&quot;success&quot;</span>, <span class="number">3000L</span>),</span><br><span class="line">                Tuple4.of(<span class="string">&quot;order-3&quot;</span>, <span class="string">&quot;third-party&quot;</span>, <span class="string">&quot;success&quot;</span>, <span class="number">4000L</span>)</span><br><span class="line">        ).assignTimestampsAndWatermarks(WatermarkStrategy.&lt;Tuple4&lt;String, String, String, Long&gt;&gt;forMonotonousTimestamps()</span><br><span class="line">                .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Tuple4&lt;String, String, String, Long&gt;&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Tuple4&lt;String, String, String, Long&gt; element, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> element.f3;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测同一支付单在两条流中是否匹配，不匹配就报警</span></span><br><span class="line">        appStream.connect(thirdpartStream)</span><br><span class="line">                .keyBy(data -&gt; data.f0, data -&gt; data.f0)</span><br><span class="line">                .process(<span class="keyword">new</span> OrderMatchResult())</span><br><span class="line">                .print();</span><br><span class="line"></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义实现CoProcessFunction</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderMatchResult</span> <span class="keyword">extends</span> <span class="title">CoProcessFunction</span>&lt;<span class="title">Tuple3</span>&lt;<span class="title">String</span>, <span class="title">String</span>, <span class="title">Long</span>&gt;, <span class="title">Tuple4</span>&lt;<span class="title">String</span>, <span class="title">String</span>, <span class="title">String</span>, <span class="title">Long</span>&gt;, <span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 定义状态变量，用来保存已经到达的事件</span></span><br><span class="line">        <span class="keyword">private</span> ValueState&lt;Tuple3&lt;String, String, Long&gt;&gt; appEventState;</span><br><span class="line">        <span class="keyword">private</span> ValueState&lt;Tuple4&lt;String, String, String, Long&gt;&gt; thirdPartyEventState;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            appEventState = getRuntimeContext().getState(</span><br><span class="line">                    <span class="keyword">new</span> ValueStateDescriptor&lt;Tuple3&lt;String, String, Long&gt;&gt;(<span class="string">&quot;app-event&quot;</span>, Types.TUPLE(Types.STRING, Types.STRING, Types.LONG))</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            thirdPartyEventState = getRuntimeContext().getState(</span><br><span class="line">                    <span class="keyword">new</span> ValueStateDescriptor&lt;Tuple4&lt;String, String, String, Long&gt;&gt;(<span class="string">&quot;thirdparty-event&quot;</span>, Types.TUPLE(Types.STRING, Types.STRING, Types.STRING,Types.LONG))</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement1</span><span class="params">(Tuple3&lt;String, String, Long&gt; value, Context ctx, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// 看另一条流中事件是否来过</span></span><br><span class="line">            <span class="keyword">if</span> (thirdPartyEventState.value() != <span class="keyword">null</span>)&#123;</span><br><span class="line">                out.collect(<span class="string">&quot;对账成功：&quot;</span> + value + <span class="string">&quot;  &quot;</span> + thirdPartyEventState.value());</span><br><span class="line">                <span class="comment">// 清空状态</span></span><br><span class="line">                thirdPartyEventState.clear();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 更新状态</span></span><br><span class="line">                appEventState.update(value);</span><br><span class="line">                <span class="comment">// 注册一个5秒后的定时器，开始等待另一条流的事件</span></span><br><span class="line">                ctx.timerService().registerEventTimeTimer(value.f2 + <span class="number">5000L</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement2</span><span class="params">(Tuple4&lt;String, String, String, Long&gt; value, Context ctx, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (appEventState.value() != <span class="keyword">null</span>)&#123;</span><br><span class="line">                out.collect(<span class="string">&quot;对账成功：&quot;</span> + appEventState.value() + <span class="string">&quot;  &quot;</span> + value);</span><br><span class="line">                <span class="comment">// 清空状态</span></span><br><span class="line">                appEventState.clear();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 更新状态</span></span><br><span class="line">                thirdPartyEventState.update(value);</span><br><span class="line">                <span class="comment">// 注册一个5秒后的定时器，开始等待另一条流的事件</span></span><br><span class="line">                ctx.timerService().registerEventTimeTimer(value.f3 + <span class="number">5000L</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTimer</span><span class="params">(<span class="keyword">long</span> timestamp, OnTimerContext ctx, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// 定时器触发，判断状态，如果某个状态不为空，说明另一条流中事件没来</span></span><br><span class="line">            <span class="keyword">if</span> (appEventState.value() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                out.collect(<span class="string">&quot;对账失败：&quot;</span> + appEventState.value() + <span class="string">&quot;  &quot;</span> + <span class="string">&quot;第三方支付平台信息未到&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (thirdPartyEventState.value() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                out.collect(<span class="string">&quot;对账失败：&quot;</span> + thirdPartyEventState.value() + <span class="string">&quot;  &quot;</span> + <span class="string">&quot;app信息未到&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            appEventState.clear();</span><br><span class="line">            thirdPartyEventState.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ProcessJoinFunction"><a href="#ProcessJoinFunction" class="headerlink" title="ProcessJoinFunction"></a>ProcessJoinFunction</h3><p>间隔连接(interval join)两条流之后的处理函数，基于 IntervalJoinedStream 调用.process()时作为参数传入。</p>
<h3 id="BroadcastProcessFunction"><a href="#BroadcastProcessFunction" class="headerlink" title="BroadcastProcessFunction"></a>BroadcastProcessFunction</h3><p>广播连接流处理函数，基于 BroadcastConnectedStream 调用.process()时作为参数传入。这里的广播连接流BroadcastConnectedStream，是一个未 keyBy 的普通 DataStream 与一个广播流(BroadcastStream)做连接(conncet)之后的产物。</p>
<p>这种连接方式往往用在需要动态定义某些规则或配置的场景。因为规则是实时变动的，所以我们可以用一个单独的流来获取规则数据；而这些规则或配置是对整个应用全局有效的，所以不能只把这数据传递给一个下游并行子任务处理，而是要广播(broadcast)给所有的并行子任务。而下游子任务收到广播出来的规则，会把它保存成一个状态，这就是所谓的广播状态(broadcast state)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BroadcastProcessFunction</span>&lt;<span class="title">IN1</span>, <span class="title">IN2</span>, <span class="title">OUT</span>&gt; <span class="keyword">extends</span> <span class="title">BaseBroadcastProcessFunction</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(IN1 value, ReadOnlyContext ctx, Collector&lt;OUT&gt; out)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">processBroadcastElement</span><span class="params">(IN2 value, Context ctx, Collector&lt;OUT&gt; out)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="KeyedBroadcastProcessFunction"><a href="#KeyedBroadcastProcessFunction" class="headerlink" title="KeyedBroadcastProcessFunction"></a>KeyedBroadcastProcessFunction</h3><p>按键分区的广播连接流处理函数，同样是基于 BroadcastConnectedStream 调用.process()时作为参数传入。与 BroadcastProcessFunction 不同的是，这时的广播连接流，是一个 KeyedStream 与广播流(BroadcastStream)做连接之后的产物。</p>
<h3 id="侧输出流-Side-Output"><a href="#侧输出流-Side-Output" class="headerlink" title="侧输出流(Side Output)"></a>侧输出流(Side Output)</h3><p>处理函数还有另外一个特有功能，就是将自定义的数据放入侧输出流(side output)输出。具体应用时，只要在处理函数的.processElement()或者.onTimer()方法中，调用上下文的.output()方法就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;Integer&gt; stream = env.addSource(...);</span><br><span class="line"></span><br><span class="line">SingleOutputStreamOperator&lt;Long&gt; longStream = stream.process(<span class="keyword">new</span> ProcessFunction&lt;Integer, Long&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">( Integer value, Context ctx, Collector&lt;Integer&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 转换成 Long，输出到主流中</span></span><br><span class="line">        out.collect(Long.valueOf(value));</span><br><span class="line">        <span class="comment">// 转换成 String，输出到侧输出流中</span></span><br><span class="line">        ctx.output(outputTag, <span class="string">&quot;side-output: &quot;</span> + String.valueOf(value));</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这里 output()方法需要传入两个参数，第一个是一个输出标签OutputTag，用来标识侧输出流，一般会在外部统一声明；第二个就是要输出的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//部先将 OutputTag 声明出来</span></span><br><span class="line">OutputTag&lt;String&gt; outputTag = <span class="keyword">new</span> OutputTag&lt;String&gt;(<span class="string">&quot;side-output&quot;</span>) &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>如果想要获取这个侧输出流，可以基于处理之后的 DataStream 直接调用.getSideOutput() 方法，传入对应的 OutputTag。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;String&gt; stringStream = longStream.getSideOutput(outputTag);</span><br></pre></td></tr></table></figure>

<h2 id="多流转换"><a href="#多流转换" class="headerlink" title="多流转换"></a>多流转换</h2><p>多流转换可以分为分流和<strong>合流</strong>两大类。目前分流的操作一般是通过侧输出流(side output)来实现，而合流的算子比较丰富，根据不同的需求可以调用 union、 connect、join 以及 coGroup 等接口进行连接合并操作。</p>
<h3 id="分流"><a href="#分流" class="headerlink" title="分流"></a>分流</h3><p>分流就是将一条数据流拆分成完全独立的两条、甚至多条流。也就是基于一个 DataStream，得到完全平等的多个子 DataStream。</p>
<h4 id="filter实现"><a href="#filter实现" class="headerlink" title="filter实现"></a>filter实现</h4><p>只要针对同一条流多次独立调 用.filter()方法进行筛选，就可以得到拆分之后的流了。</p>
<p>例如，我们可以将电商网站收集到的用户行为数据进行一个拆分，根据类型(type)的不同，分为Mary的浏览数据、Bob的浏览数据等等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    SingleOutputStreamOperator&lt;Event&gt; stream = env</span><br><span class="line">            .addSource(<span class="keyword">new</span> ClickSource());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 筛选Mary的浏览行为放入MaryStream流中</span></span><br><span class="line">    DataStream&lt;Event&gt; MaryStream = stream.filter(<span class="keyword">new</span> FilterFunction&lt;Event&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(Event value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value.user.equals(<span class="string">&quot;Mary&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 筛选Bob的购买行为放入BobStream流中</span></span><br><span class="line">    DataStream&lt;Event&gt; BobStream = stream.filter(<span class="keyword">new</span> FilterFunction&lt;Event&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(Event value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value.user.equals(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 筛选其他人的浏览行为放入elseStream流中</span></span><br><span class="line">    DataStream&lt;Event&gt; elseStream = stream.filter(<span class="keyword">new</span> FilterFunction&lt;Event&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(Event value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> !value.user.equals(<span class="string">&quot;Mary&quot;</span>) &amp;&amp; !value.user.equals(<span class="string">&quot;Bob&quot;</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    MaryStream.print(<span class="string">&quot;Mary pv&quot;</span>);</span><br><span class="line">    BobStream.print(<span class="string">&quot;Bob pv&quot;</span>);</span><br><span class="line">    elseStream.print(<span class="string">&quot;else pv&quot;</span>);</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码背后的含义，是将原始数据流 stream 复制三份，然后对每一份分别做筛选；这明显是不够高效的。我们自然想到，能不能不用复制流，直接用一个算子就把它们都拆分开呢?</p>
<h4 id="侧输出流-1"><a href="#侧输出流-1" class="headerlink" title="侧输出流"></a>侧输出流</h4><p>处理函数本身可以认为是一个转换算子，它的输出类型是单一的，处理之后得到的仍然是一个 DataStream；而侧输出流则不受限制，可以任意自定义输出数据，它们就像从主流上分叉出的支流。尽管看起来主流和支流有所区别，不过实际上它们都是某种类型的 DataStream，所以本质上还是平等的。利用侧输出流就可以很方便地实现分流操作，而且得到的多条 DataStream <strong>类型可以不同</strong>，这就给我们的应用带来了极大的便利。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SplitStreamByOutputTag</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义输出标签，侧输出流的数据类型为三元组(user, url, timestamp)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> OutputTag&lt;Tuple3&lt;String, String, Long&gt;&gt; MaryTag = <span class="keyword">new</span> OutputTag&lt;Tuple3&lt;String, String, Long&gt;&gt;(<span class="string">&quot;Mary-pv&quot;</span>)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> OutputTag&lt;Tuple3&lt;String, String, Long&gt;&gt; BobTag = <span class="keyword">new</span> OutputTag&lt;Tuple3&lt;String, String, Long&gt;&gt;(<span class="string">&quot;Bob-pv&quot;</span>)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        SingleOutputStreamOperator&lt;Event&gt; stream = env</span><br><span class="line">                .addSource(<span class="keyword">new</span> ClickSource());</span><br><span class="line"></span><br><span class="line">        SingleOutputStreamOperator&lt;Event&gt; processedStream = stream.process(<span class="keyword">new</span> ProcessFunction&lt;Event, Event&gt;() &#123;</span><br><span class="line">          </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(Event value, Context ctx, Collector&lt;Event&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (value.user.equals(<span class="string">&quot;Mary&quot;</span>))&#123;</span><br><span class="line">                    ctx.output(MaryTag, <span class="keyword">new</span> Tuple3&lt;&gt;(value.user, value.url, value.timestamp));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value.user.equals(<span class="string">&quot;Bob&quot;</span>))&#123;</span><br><span class="line">                    ctx.output(BobTag, <span class="keyword">new</span> Tuple3&lt;&gt;(value.user, value.url, value.timestamp));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    out.collect(value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        processedStream.getSideOutput(MaryTag).print(<span class="string">&quot;Mary pv&quot;</span>);</span><br><span class="line">        processedStream.getSideOutput(BobTag).print(<span class="string">&quot;Bob pv&quot;</span>);</span><br><span class="line">        processedStream.print(<span class="string">&quot;else&quot;</span>);</span><br><span class="line"></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="合流"><a href="#合流" class="headerlink" title="合流"></a>合流</h3><h4 id="联合-Union"><a href="#联合-Union" class="headerlink" title="联合(Union)"></a>联合(Union)</h4><p>联合操作要求必须流中的数据类型必须相同，合并之后的新流会包括所有流中的元素，数据类型不变。这种合流方式非常简单粗暴，就像公路上多个车道汇在一起一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//union()的参数可以是多个 DataStream，所以联合操作可以实现多条流的合并</span></span><br><span class="line">stream1.union(stream2, stream3, ...)</span><br></pre></td></tr></table></figure>

<p>注意，对于合流之后的水位线，也是要以最小的那个为准，这样才可以保证所有流都不会再传来之前的数据。换句话说，多流合并时处理的时效性是以最慢的那个流为准的。我们自然可以想到，这与之前介绍的并行任务水位线传递的规则是完全一致的；多条流的合并，某种意义上也可以看作是多个并行任务向同一个下游任务汇合的过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    SingleOutputStreamOperator&lt;Event&gt; stream1 = env.socketTextStream(<span class="string">&quot;hadoop102&quot;</span>, <span class="number">7777</span>)</span><br><span class="line">            .map(data -&gt; &#123;</span><br><span class="line">                String[] field = data.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Event(field[<span class="number">0</span>].trim(), field[<span class="number">1</span>].trim(), Long.valueOf(field[<span class="number">2</span>].trim()));</span><br><span class="line">            &#125;)</span><br><span class="line">            .assignTimestampsAndWatermarks(WatermarkStrategy.&lt;Event&gt;forBoundedOutOfOrderness(Duration.ofSeconds(<span class="number">2</span>))</span><br><span class="line">                    .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Event&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Event element, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> element.timestamp;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    stream1.print(<span class="string">&quot;stream1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    SingleOutputStreamOperator&lt;Event&gt; stream2 = env.socketTextStream(<span class="string">&quot;hadoop103&quot;</span>, <span class="number">7777</span>)</span><br><span class="line">            .map(data -&gt; &#123;</span><br><span class="line">                String[] field = data.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Event(field[<span class="number">0</span>].trim(), field[<span class="number">1</span>].trim(), Long.valueOf(field[<span class="number">2</span>].trim()));</span><br><span class="line">            &#125;)</span><br><span class="line">            .assignTimestampsAndWatermarks(WatermarkStrategy.&lt;Event&gt;forBoundedOutOfOrderness(Duration.ofSeconds(<span class="number">5</span>))</span><br><span class="line">                    .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Event&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Event element, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> element.timestamp;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    stream2.print(<span class="string">&quot;stream2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并两条流</span></span><br><span class="line">    stream1.union(stream2)</span><br><span class="line">            .process(<span class="keyword">new</span> ProcessFunction&lt;Event, String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(Event value, Context ctx, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    out.collect(<span class="string">&quot;水位线：&quot;</span> + ctx.timerService().currentWatermark());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .print();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="连接-Connect"><a href="#连接-Connect" class="headerlink" title="连接(Connect)"></a>连接(Connect)</h4><p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-03-25%20%E4%B8%8A%E5%8D%8812.08.27.png" alt="截屏2022-03-25 上午12.08.27"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    </span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    DataStream&lt;Integer&gt; stream1 = env.fromElements(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    DataStream&lt;Long&gt; stream2 = env.fromElements(<span class="number">1L</span>,<span class="number">2L</span>,<span class="number">3L</span>);</span><br><span class="line"></span><br><span class="line">    ConnectedStreams&lt;Integer, Long&gt; connectedStreams = stream1.connect(stream2);</span><br><span class="line">    </span><br><span class="line">    SingleOutputStreamOperator&lt;String&gt; result = connectedStreams.map(<span class="keyword">new</span> CoMapFunction&lt;Integer, Long, String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">map1</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Integer: &quot;</span> + value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">map2</span><span class="params">(Long value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Long: &quot;</span> + value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    result.print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们将一 条 Integer 流和一条 Long 流合并，转换成 String 输出。所以当遇到第一条流输入的整型值时， 调用.map1()；而遇到第二条流输入的长整型数据时，调用.map2()：最终都转换为字符串输出，合并成了一条字符串流。</p>
<p>值得一提的是，ConnectedStreams 也可以直接调用.keyBy()进行按键分区的操作，得到的还是一个 ConnectedStreams：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connectedStreams.keyBy(keySelector1, keySelector2);</span><br></pre></td></tr></table></figure>

<p>这里传入两个参数 keySelector1 和 keySelector2，是两条流中各自的键选择器；当然也可以直接传入键的位置值(keyPosition)，或者键的字段名(field)，这与普通的 keyBy 用法完全 一致。ConnectedStreams 进行 keyBy 操作，其实就是把两条流中 key 相同的数据放到了一起，然后针对来源的流再做各自处理，这在一些场景下非常有用。另外，我们也可以在合并之前就将两条流分别进行 keyBy，得到的 KeyedStream 再进行连接(connect)操作，效果是一样的。 要注意两条流定义的键的类型必须相同，否则会抛出异常。</p>
<h4 id="双流联结-Join"><a href="#双流联结-Join" class="headerlink" title="双流联结(Join)"></a>双流联结(Join)</h4><h5 id="窗口联结-Window-Join"><a href="#窗口联结-Window-Join" class="headerlink" title="窗口联结(Window Join)"></a>窗口联结(Window Join)</h5><p>可以定义时间窗口，并将两条流中共享一个公共键(key)的数据放在窗口中进行配对处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stream1.join(stream2)</span><br><span class="line">       .where(&lt;KeySelector&gt;)</span><br><span class="line">       .equalTo(&lt;KeySelector&gt;)</span><br><span class="line">       .window(&lt;WindowAssigner&gt;)</span><br><span class="line">       .apply(&lt;JoinFunction&gt;)</span><br></pre></td></tr></table></figure>

<p>上面代码中.where()的参数是键选择器(KeySelector)，用来指定第一条流中的 key；而.equalTo()传入的 KeySelector 则指定了第二条流中的 key。两者相同的元素，如果在同一窗口中，就可以匹配起来，并通过一个联结函数(JoinFunction)进行处理了。</p>
<p>传入的 JoinFunction 也是一个函数类接口，使用时需要实现内部的.join()方法。这个方法有两个参数，分别表示两条流中成对匹配的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JoinFunction</span>&lt;<span class="title">IN1</span>, <span class="title">IN2</span>, <span class="title">OUT</span>&gt; <span class="keyword">extends</span> <span class="title">Function</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">   <span class="function">OUT <span class="title">join</span><span class="params">(IN1 first, IN2 second)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-03-25%20%E4%B8%8A%E5%8D%889.56.19.png" alt="截屏2022-03-25 上午9.56.19"></p>
<p>除了 JoinFunction，在.apply()方法中还可以传入 FlatJoinFunction，用法非常类似，只是内部需要实现的.join()方法没有返回值。结果的输出是通过收集器(Collector)来实现的，所以对于一对匹配数据可以输出任意条结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    DataStream&lt;Tuple2&lt;String, Long&gt;&gt; stream1 = env</span><br><span class="line">            .fromElements(</span><br><span class="line">                    Tuple2.of(<span class="string">&quot;a&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">                    Tuple2.of(<span class="string">&quot;b&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">                    Tuple2.of(<span class="string">&quot;a&quot;</span>, <span class="number">2000L</span>),</span><br><span class="line">                    Tuple2.of(<span class="string">&quot;b&quot;</span>, <span class="number">2000L</span>)</span><br><span class="line">            )</span><br><span class="line">            .assignTimestampsAndWatermarks(</span><br><span class="line">                    WatermarkStrategy</span><br><span class="line">                            .&lt;Tuple2&lt;String, Long&gt;&gt;forMonotonousTimestamps()</span><br><span class="line">                            .withTimestampAssigner(</span><br><span class="line">                                    <span class="keyword">new</span> SerializableTimestampAssigner&lt;Tuple2&lt;String, Long&gt;&gt;() &#123;</span><br><span class="line">                                        <span class="meta">@Override</span></span><br><span class="line">                                        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Tuple2&lt;String, Long&gt; stringLongTuple2, <span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">                                            <span class="keyword">return</span> stringLongTuple2.f1;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                            )</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    DataStream&lt;Tuple2&lt;String, Long&gt;&gt; stream2 = env</span><br><span class="line">            .fromElements(</span><br><span class="line">                    Tuple2.of(<span class="string">&quot;a&quot;</span>, <span class="number">3000L</span>),</span><br><span class="line">                    Tuple2.of(<span class="string">&quot;b&quot;</span>, <span class="number">3000L</span>),</span><br><span class="line">                    Tuple2.of(<span class="string">&quot;a&quot;</span>, <span class="number">4000L</span>),</span><br><span class="line">                    Tuple2.of(<span class="string">&quot;b&quot;</span>, <span class="number">4000L</span>)</span><br><span class="line">            )</span><br><span class="line">            .assignTimestampsAndWatermarks(</span><br><span class="line">                    WatermarkStrategy</span><br><span class="line">                            .&lt;Tuple2&lt;String, Long&gt;&gt;forMonotonousTimestamps()</span><br><span class="line">                            .withTimestampAssigner(</span><br><span class="line">                                    <span class="keyword">new</span> SerializableTimestampAssigner&lt;Tuple2&lt;String, Long&gt;&gt;() &#123;</span><br><span class="line">                                        <span class="meta">@Override</span></span><br><span class="line">                                        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Tuple2&lt;String, Long&gt; stringLongTuple2, <span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">                                            <span class="keyword">return</span> stringLongTuple2.f1;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                            )</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    stream1</span><br><span class="line">            .join(stream2)</span><br><span class="line">            .where(r -&gt; r.f0)</span><br><span class="line">            .equalTo(r -&gt; r.f0)</span><br><span class="line">            .window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">5</span>)))</span><br><span class="line">            .apply(<span class="keyword">new</span> JoinFunction&lt;Tuple2&lt;String, Long&gt;, Tuple2&lt;String, Long&gt;, String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">join</span><span class="params">(Tuple2&lt;String, Long&gt; left, Tuple2&lt;String, Long&gt; right)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> left + <span class="string">&quot;=&gt;&quot;</span> + right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="间隔联结-Interval-Join"><a href="#间隔联结-Interval-Join" class="headerlink" title="间隔联结(Interval Join)"></a>间隔联结(Interval Join)</h5><p>在有些场景下，我们要处理的时间间隔可能并不是固定的。比如，在交易系统中，需要实时地对每一笔交易进行核验，保证两个账户转入转出数额相等，也就是所谓的实时对账。 两次转账的数据可能写入了不同的日志流，它们的时间戳应该相差不大，所以我们可以考虑只统计一段时间内是否有出账入账的数据匹配。这时显然不应该用滚动窗口或滑动窗口来处理——因为匹配的两个数据有可能刚好卡在窗口边缘两侧，于是窗口内就都没有匹配了；会话窗口虽然时间不固定，但也明显不适合这个场景。 基于时间的窗口联结已经无能为力了。</p>
<p>为了应对这样的需求，Flink 提供了一种叫作间隔联结(interval join)的合流操作。顾名思义，间隔联结的思路就是针对一条流的每个数据，<strong>开辟出其时间戳前后的一段时间间隔</strong>，看这期间是否有来自另一条流的数据匹配。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">stream1</span><br><span class="line">   .keyBy(&lt;KeySelector&gt;)</span><br><span class="line">   .intervalJoin(stream2.keyBy(&lt;KeySelector&gt;))</span><br><span class="line">   .between(Time.milliseconds(-<span class="number">2</span>), Time.milliseconds(<span class="number">1</span>))</span><br><span class="line">   .process (<span class="keyword">new</span> ProcessJoinFunction&lt;Integer, Integer, String()&#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(Integer left, Integer right, Context ctx, Collector&lt;String&gt; out)</span> </span>&#123;</span><br><span class="line">                              out.collect(left + <span class="string">&quot;,&quot;</span> + right);</span><br><span class="line">                           </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<p>抽象类 ProcessJoinFunction 就像是 ProcessFunction 和 JoinFunction 的结合，内部同样有一个抽象方法.processElement()。与其他处理函数不同的是，它多了一个参数，这自然是因为有来自两条流的数据。参数中 left 指的就是第一条流中的数据，right 则是第二条流中与它匹配的数据。每当检测到一组匹配，就会调用这里的.processElement()方法，经处理转换之后输出结果。</p>
<p>举一个例子，我们有两条流，一条是下订单的流，一条是浏览数据的流。我们可以针对同一个用户，来做这样一个联结。也就是使用一个用户的下订单的事件和这个用户的最近十分钟的浏览数据进行一个联结查询：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    SingleOutputStreamOperator&lt;Tuple3&lt;String, String, Long&gt;&gt; orderStream = env.fromElements(</span><br><span class="line">            Tuple3.of(<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;order-1&quot;</span>, <span class="number">5000L</span>),</span><br><span class="line">            Tuple3.of(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;order-2&quot;</span>, <span class="number">5000L</span>),</span><br><span class="line">            Tuple3.of(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;order-3&quot;</span>, <span class="number">20000L</span>),</span><br><span class="line">            Tuple3.of(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;order-4&quot;</span>, <span class="number">20000L</span>),</span><br><span class="line">            Tuple3.of(<span class="string">&quot;Cary&quot;</span>, <span class="string">&quot;order-5&quot;</span>, <span class="number">51000L</span>)</span><br><span class="line">    ).assignTimestampsAndWatermarks(WatermarkStrategy.&lt;Tuple3&lt;String, String, Long&gt;&gt;forMonotonousTimestamps()</span><br><span class="line">            .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Tuple3&lt;String, String, Long&gt;&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Tuple3&lt;String, String, Long&gt; element, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> element.f2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    SingleOutputStreamOperator&lt;Event&gt; clickStream = env.fromElements(</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./cart&quot;</span>, <span class="number">2000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod?id=100&quot;</span>, <span class="number">3000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod?id=200&quot;</span>, <span class="number">3500L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./prod?id=2&quot;</span>, <span class="number">2500L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod?id=300&quot;</span>, <span class="number">36000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">30000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./prod?id=1&quot;</span>, <span class="number">23000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./prod?id=3&quot;</span>, <span class="number">33000L</span>)</span><br><span class="line">    ).assignTimestampsAndWatermarks(WatermarkStrategy.&lt;Event&gt;forMonotonousTimestamps()</span><br><span class="line">            .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Event&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Event element, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> element.timestamp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    orderStream.keyBy(data -&gt; data.f0)</span><br><span class="line">            .intervalJoin(clickStream.keyBy(data -&gt; data.user))</span><br><span class="line">            .between(Time.seconds(-<span class="number">5</span>), Time.seconds(<span class="number">10</span>))</span><br><span class="line">            .process(<span class="keyword">new</span> ProcessJoinFunction&lt;Tuple3&lt;String, String, Long&gt;, Event, String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(Tuple3&lt;String, String, Long&gt; left, Event right, Context ctx, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    out.collect(right + <span class="string">&quot; =&gt; &quot;</span> + left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="窗口同组联结-Window-CoGroup"><a href="#窗口同组联结-Window-CoGroup" class="headerlink" title="窗口同组联结(Window CoGroup)"></a>窗口同组联结(Window CoGroup)</h5><p>除窗口联结和间隔联结之外，Flink 还提供了一个窗口同组联结(window coGroup)操作。它的用法跟 window join 非常类似，也是将两条流合并之后开窗处理匹配的元素，调用时只需要将.join()换为.coGroup()就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stream1.coGroup(stream2)</span><br><span class="line">   .where(&lt;KeySelector&gt;)</span><br><span class="line">   .equalTo(&lt;KeySelector&gt;)</span><br><span class="line">   .window(TumblingEventTimeWindows.of(Time.hours(<span class="number">1</span>)))</span><br><span class="line">   .apply(&lt;CoGroupFunction&gt;)</span><br></pre></td></tr></table></figure>

<p>与 window join 的区别在于，调用.apply()方法定义具体操作时，传入的是一个 CoGroupFunction。这也是一个函数类接口，源码中定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CoGroupFunction</span>&lt;<span class="title">IN1</span>, <span class="title">IN2</span>, <span class="title">O</span>&gt; <span class="keyword">extends</span> <span class="title">Function</span>, <span class="title">Serializable</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">coGroup</span><span class="params">(Iterable&lt;IN1&gt; first, Iterable&lt;IN2&gt; second, Collector&lt;O&gt; out)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>.coGroup()方法，有些类似于 FlatJoinFunction 中.join()的形式，同样有三个参数，分别代表两条流中的数据以及用于输出的收集器(Collector)。不同的是，这里的前两个参数不再是单独的每一组配对数据了，而是传入了可遍历的数据集合。也就是说，现在不会再去计算窗口中两条流数据集的笛卡尔积，而是直接把收集到的所有数据一次性传入，至于要怎样配对完全是自定义的。这样.coGroup()方法只会被调用一次，而且即使一条流的数据没有任何另一条流的数据匹配，也可以出现在集合中、当然也可以定义输出结果了。</p>
<p>coGroup 操作比窗口的 join 更加通用，不仅可以实现类似 SQL 中的内连接(inner join)，也可以实现左外连接(left outer join)、右外连接(right outer join)和全外连接(full outer join)。事实上，窗口 join 的底层，也是通过 coGroup 来实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    DataStream&lt;Tuple2&lt;String, Long&gt;&gt; stream1 = env</span><br><span class="line">            .fromElements(</span><br><span class="line">                    Tuple2.of(<span class="string">&quot;a&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">                    Tuple2.of(<span class="string">&quot;b&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">                    Tuple2.of(<span class="string">&quot;a&quot;</span>, <span class="number">2000L</span>),</span><br><span class="line">                    Tuple2.of(<span class="string">&quot;b&quot;</span>, <span class="number">2000L</span>)</span><br><span class="line">            )</span><br><span class="line">            .assignTimestampsAndWatermarks(</span><br><span class="line">                    WatermarkStrategy</span><br><span class="line">                            .&lt;Tuple2&lt;String, Long&gt;&gt;forMonotonousTimestamps()</span><br><span class="line">                            .withTimestampAssigner(</span><br><span class="line">                                    <span class="keyword">new</span> SerializableTimestampAssigner&lt;Tuple2&lt;String, Long&gt;&gt;() &#123;</span><br><span class="line">                                        <span class="meta">@Override</span></span><br><span class="line">                                        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Tuple2&lt;String, Long&gt; stringLongTuple2, <span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">                                            <span class="keyword">return</span> stringLongTuple2.f1;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                            )</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    DataStream&lt;Tuple2&lt;String, Long&gt;&gt; stream2 = env</span><br><span class="line">            .fromElements(</span><br><span class="line">                    Tuple2.of(<span class="string">&quot;a&quot;</span>, <span class="number">3000L</span>),</span><br><span class="line">                    Tuple2.of(<span class="string">&quot;b&quot;</span>, <span class="number">3000L</span>),</span><br><span class="line">                    Tuple2.of(<span class="string">&quot;a&quot;</span>, <span class="number">4000L</span>),</span><br><span class="line">                    Tuple2.of(<span class="string">&quot;b&quot;</span>, <span class="number">4000L</span>)</span><br><span class="line">            )</span><br><span class="line">            .assignTimestampsAndWatermarks(</span><br><span class="line">                    WatermarkStrategy</span><br><span class="line">                            .&lt;Tuple2&lt;String, Long&gt;&gt;forMonotonousTimestamps()</span><br><span class="line">                            .withTimestampAssigner(</span><br><span class="line">                                    <span class="keyword">new</span> SerializableTimestampAssigner&lt;Tuple2&lt;String, Long&gt;&gt;() &#123;</span><br><span class="line">                                        <span class="meta">@Override</span></span><br><span class="line">                                        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Tuple2&lt;String, Long&gt; stringLongTuple2, <span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">                                            <span class="keyword">return</span> stringLongTuple2.f1;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                            )</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    stream1</span><br><span class="line">            .coGroup(stream2)</span><br><span class="line">            .where(r -&gt; r.f0)</span><br><span class="line">            .equalTo(r -&gt; r.f0)</span><br><span class="line">            .window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">5</span>)))</span><br><span class="line">            .apply(<span class="keyword">new</span> CoGroupFunction&lt;Tuple2&lt;String, Long&gt;, Tuple2&lt;String, Long&gt;, String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">coGroup</span><span class="params">(Iterable&lt;Tuple2&lt;String, Long&gt;&gt; iter1, Iterable&lt;Tuple2&lt;String, Long&gt;&gt; iter2, Collector&lt;String&gt; collector)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    collector.collect(iter1 + <span class="string">&quot;=&gt;&quot;</span> + iter2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="comment">(a,1000)</span>, <span class="comment">(a,2000)</span>]=&gt;[<span class="comment">(a,3000)</span>, <span class="comment">(a,4000)</span>]</span><br><span class="line">[<span class="comment">(b,1000)</span>, <span class="comment">(b,2000)</span>]=&gt;[<span class="comment">(b,3000)</span>, <span class="comment">(b,4000)</span>]</span><br></pre></td></tr></table></figure>

<h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><p>有状态的算子任务，则除当前数据之外，还需要一些其他数据来得到计算结果。这里的其他数据，就是所谓的状态(state)，最常见的就是之前到达的数据，或者由之前数据计算出的某个结果。比如，做求和(sum)计算时，需要保存之前所有数据的和，这就是状态；窗口算子中会保存已经到达的所有数据，这些也都是它的状态。另外，如果我们希望检索到某种事件模式(event pattern)，比如先有下单行为，后有支付行为，那么也应该把之前的行为保存下来，这同样属于状态。容易发现，之前讲过的聚合算子、窗口算子都属于有状态的算子。</p>
<p>有状态算子的一般处理流程：(1)算子任务接收到上游发来的数据；(2)获取当前状态；(3)根据业务逻辑进行计算，更新状态；(4)得到计算结果，输出发送到下游任务。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-03-25%20%E4%B8%8A%E5%8D%8811.24.56.png" alt="截屏2022-03-25 上午11.24.56"></p>
<table>
<thead>
<tr>
<th></th>
<th>ManagedState</th>
<th>RawState</th>
</tr>
</thead>
<tbody><tr>
<td>状态管理方式</td>
<td>Flink Runtime托管, 自动存储, 自动恢复, 自动伸缩</td>
<td>用户自己管理</td>
</tr>
<tr>
<td>状态数据结构</td>
<td>Flink提供多种常用数据结构, 例如:ListState, MapState等</td>
<td>字节数组: byte[]</td>
</tr>
<tr>
<td>使用场景</td>
<td>绝大数Flink算子</td>
<td>所有算子</td>
</tr>
</tbody></table>
<p>对Managed State继续细分，它又有两种类型：</p>
<p>a) Operator State(算子状态)</p>
<p>状态作用范围限定为当前的算子任务实例，也就是只对当前并行子任务实例有效。这就意味着对于一个并行子任务，占据了一个分区，它所处理的所有数据都会访问到相同的状态，状态对于同一任务而言是共享的。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-03-25%20%E4%B8%8B%E5%8D%883.47.50.png" alt="截屏2022-03-25 下午3.47.50"></p>
<p>算子状态可以用在所有算子上，使用的时候其实就跟一个本地变量没什么区别——因为本地变量的作用域也是当前任务实例。在使用时，我们还需进一步实现 CheckpointedFunction 接口。</p>
<p>b) Keyed State(键控状态)</p>
<p>状态是根据输入流中定义的键(key)来维护和访问的，所以只能定义在按键分区流(KeyedStream)中，也就 keyBy 之后才可以使用。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-03-25%20%E4%B8%8B%E5%8D%883.48.55.png" alt="截屏2022-03-25 下午3.48.55"></p>
<p>按键分区状态应用非常广泛。之前讲到的聚合算子必须在 keyBy 之后才能使用，就是因为聚合的结果是以Keyed State的形式保存的。另外，也可以通过富函数类(Rich Function) 来自定义 Keyed State，所以只要提供了富函数类接口的算子，也都可以使用 Keyed State。</p>
<p>所以即使是 map、filter 这样无状态的基本转换算子，我们也可以通过富函数类给它们追加 Keyed State，或者实现 CheckpointedFunction 接口来定义 Operator State；从这个角度讲， Flink 中所有的算子都可以是有状态的，不愧是有状态的流处理。</p>
<p>无论是 Keyed State 还是 Operator State，它们都是在本地实例上维护的，也就是说<strong>每个并行子任务维护着对应的状态</strong>，算子的<strong>子任务之间状态不共享</strong>。关于状态的具体使用。</p>
<table>
<thead>
<tr>
<th></th>
<th>OperatorState</th>
<th>KeyedState</th>
</tr>
</thead>
<tbody><tr>
<td>适用用算子类型</td>
<td>可用于所有算子: 常用于source, 例如 FlinkKafkaConsumer</td>
<td>只适用于KeyedStream上的算子</td>
</tr>
<tr>
<td>状态分配</td>
<td>一个算子的子任务对应一个状态</td>
<td>一个Key对应一个State: 一个算子会处理多个Key, 则访问相应的多个State</td>
</tr>
<tr>
<td>创建和访问方式</td>
<td>实现CheckpointedFunction或ListCheckpointed(已经过时)接口</td>
<td>重写RichFunction, 通过里面的RuntimeContext访问</td>
</tr>
<tr>
<td>横向扩展</td>
<td>并发改变时有多重重写分配方式可选: 均匀分配和合并后每个得到全量</td>
<td>并发改变, State随着Key在实例间迁移</td>
</tr>
<tr>
<td>支持的数据结构</td>
<td>ListState、UnionListState和BroadCastState</td>
<td>ValueState, ListState,MapState ReduceState, AggregatingState</td>
</tr>
</tbody></table>
<h3 id="按键分区状态-Keyed-State"><a href="#按键分区状态-Keyed-State" class="headerlink" title="按键分区状态(Keyed State)"></a>按键分区状态(Keyed State)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stateTest</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    SingleOutputStreamOperator&lt;Event&gt; stream = env.addSource(<span class="keyword">new</span> ClickSource())</span><br><span class="line">            .assignTimestampsAndWatermarks(WatermarkStrategy.&lt;Event&gt;forMonotonousTimestamps()</span><br><span class="line">                    .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Event&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Event element, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> element.timestamp;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    stream.keyBy(data -&gt; data.user)</span><br><span class="line">                    .flatMap(<span class="keyword">new</span> MyFlatMap())</span><br><span class="line">                            .print();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现自定义的FlatMapFunction，用于Keyed State测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFlatMap</span> <span class="keyword">extends</span> <span class="title">RichFlatMapFunction</span>&lt;<span class="title">Event</span>, <span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 定义状态</span></span><br><span class="line">    ValueState&lt;Event&gt; myValueState;</span><br><span class="line">    ListState&lt;Event&gt; myListState;</span><br><span class="line">    MapState&lt;String, Long&gt; myMapState;</span><br><span class="line">    ReducingState&lt;Event&gt; myReducingState;</span><br><span class="line">    AggregatingState&lt;Event, String&gt; myAggregatingState;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加一个本地变量进行对比</span></span><br><span class="line">    Long count = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ValueStateDescriptor&lt;Event&gt; valueStateDescriptor = <span class="keyword">new</span> ValueStateDescriptor&lt;&gt;(<span class="string">&quot;my-state&quot;</span>, Event.class);</span><br><span class="line">        myValueState = getRuntimeContext().getState(valueStateDescriptor);</span><br><span class="line"></span><br><span class="line">        myListState = getRuntimeContext().getListState(<span class="keyword">new</span> ListStateDescriptor&lt;Event&gt;(<span class="string">&quot;my-list&quot;</span>, Event.class));</span><br><span class="line">        myMapState = getRuntimeContext().getMapState(<span class="keyword">new</span> MapStateDescriptor&lt;String, Long&gt;(<span class="string">&quot;my-map&quot;</span>, String.class, Long.class));</span><br><span class="line"></span><br><span class="line">        myReducingState = getRuntimeContext().getReducingState(<span class="keyword">new</span> ReducingStateDescriptor&lt;Event&gt;(<span class="string">&quot;my-reduce&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> ReduceFunction&lt;Event&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Event <span class="title">reduce</span><span class="params">(Event value1, Event value2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> Event(value1.user, value1.url, value2.timestamp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                , Event.class));</span><br><span class="line"></span><br><span class="line">        myAggregatingState = getRuntimeContext().getAggregatingState(<span class="keyword">new</span> AggregatingStateDescriptor&lt;Event, Long, String&gt;(<span class="string">&quot;my-agg&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> AggregateFunction&lt;Event, Long, String&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Long <span class="title">createAccumulator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Long <span class="title">add</span><span class="params">(Event value, Long accmulator)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> accmulator + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> String <span class="title">getResult</span><span class="params">(Long accumulator)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">&quot;count: &quot;</span> + accumulator;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Long <span class="title">merge</span><span class="params">(Long a, Long b)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> a + b;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                , Long.class));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置状态的TTL</span></span><br><span class="line">        StateTtlConfig ttlConfig = StateTtlConfig.newBuilder(Time.hours(<span class="number">1</span>))</span><br><span class="line">                .setUpdateType(StateTtlConfig.UpdateType.OnReadAndWrite)</span><br><span class="line">                .setStateVisibility(StateTtlConfig.StateVisibility.ReturnExpiredIfNotCleanedUp)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        valueStateDescriptor.enableTimeToLive(ttlConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(Event value, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 访问和更新状态</span></span><br><span class="line">        System.out.println(myValueState.value());</span><br><span class="line">        myValueState.update(value);</span><br><span class="line">        System.out.println( <span class="string">&quot;my value: &quot;</span> + myValueState.value() );</span><br><span class="line"></span><br><span class="line">        myListState.add(value);</span><br><span class="line"></span><br><span class="line">        myMapState.put(value.user, myMapState.get(value.user) == <span class="keyword">null</span>? <span class="number">1</span>: myMapState.get(value.user) + <span class="number">1</span>);</span><br><span class="line">        System.out.println( <span class="string">&quot;my map value: &quot;</span> + myMapState.get(value.user) );</span><br><span class="line"></span><br><span class="line">        myReducingState.add(value);</span><br><span class="line">        System.out.println( <span class="string">&quot;my reducing value: &quot;</span> + myReducingState.get() );</span><br><span class="line"></span><br><span class="line">        myAggregatingState.add(value);</span><br><span class="line">        System.out.println( <span class="string">&quot;my agg value: &quot;</span> + myAggregatingState.get() );</span><br><span class="line"></span><br><span class="line">        count ++;</span><br><span class="line">        System.out.println(<span class="string">&quot;count: &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="值状态-ValueState"><a href="#值状态-ValueState" class="headerlink" title="值状态(ValueState)"></a>值状态(ValueState)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ValueState</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">   <span class="function">T <span class="title">value</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(T value)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>T value()：获取当前状态的值。<br>update(Tvalue)：对状态进行更新，传入的参数value就是要覆写的状态值。</p>
<p>在具体使用时，为了让运行时上下文清楚到底是哪个状态，我们还需要创建一个状态描述器(StateDescriptor)来提供状态的基本信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ValueStateDescriptor</span><span class="params">(String name, Class&lt;T&gt; typeClass)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">super</span>(name, typeClass, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要传入状态的名称和类型。</p>
<p>例子：我们这里会使用用户 id 来进行分流，然后分别统计每个用户的 pv 数据，由于我们并不想每次 pv 加一，就将统计结果发送到下游去，所以这里我们注册了一个定时器，用来隔一段时间发送 pv 的统计结果，这样对下游算子的压力不至于太大。具体实现方式是定义一个用来保存定时器时间戳的值状态变量。当定时器触发并向下游发送数据以后，便清空储存定时器时间戳的状态变量，这样当新的数据到来时，发现并没有定时器存在，就可以注册新的定时器了， 注册完定时器之后将定时器的时间戳继续保存在状态变量中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PeriodicPvExample</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    SingleOutputStreamOperator&lt;Event&gt; stream = env.addSource(<span class="keyword">new</span> ClickSource())</span><br><span class="line">            .assignTimestampsAndWatermarks(WatermarkStrategy.&lt;Event&gt;forMonotonousTimestamps()</span><br><span class="line">                    .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Event&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Event element, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> element.timestamp;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    stream.print(<span class="string">&quot;input&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计每个用户的pv，隔一段时间（10s）输出一次结果</span></span><br><span class="line">    stream.keyBy(data -&gt; data.user)</span><br><span class="line">            .process(<span class="keyword">new</span> PeriodicPvResult())</span><br><span class="line">            .print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册定时器，周期性输出pv</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PeriodicPvResult</span> <span class="keyword">extends</span> <span class="title">KeyedProcessFunction</span>&lt;<span class="title">String</span> ,<span class="title">Event</span>, <span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 定义两个状态，保存当前pv值，以及定时器时间戳</span></span><br><span class="line">    ValueState&lt;Long&gt; countState;</span><br><span class="line">    ValueState&lt;Long&gt; timerTsState;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        countState = getRuntimeContext().getState(<span class="keyword">new</span> ValueStateDescriptor&lt;Long&gt;(<span class="string">&quot;count&quot;</span>, Long.class));</span><br><span class="line">        timerTsState = getRuntimeContext().getState(<span class="keyword">new</span> ValueStateDescriptor&lt;Long&gt;(<span class="string">&quot;timerTs&quot;</span>, Long.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(Event value, Context ctx, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 更新count值</span></span><br><span class="line">        Long count = countState.value();</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="keyword">null</span>)&#123;</span><br><span class="line">            countState.update(<span class="number">1L</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            countState.update(count + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注册定时器</span></span><br><span class="line">        <span class="keyword">if</span> (timerTsState.value() == <span class="keyword">null</span>)&#123;</span><br><span class="line">            ctx.timerService().registerEventTimeTimer(value.timestamp + <span class="number">10</span> * <span class="number">1000L</span>);</span><br><span class="line">            timerTsState.update(value.timestamp + <span class="number">10</span> * <span class="number">1000L</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTimer</span><span class="params">(<span class="keyword">long</span> timestamp, OnTimerContext ctx, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        out.collect(ctx.getCurrentKey() + <span class="string">&quot; pv: &quot;</span> + countState.value());</span><br><span class="line">        <span class="comment">// 清空状态</span></span><br><span class="line">        timerTsState.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="列表状态-ListState"><a href="#列表状态-ListState" class="headerlink" title="列表状态(ListState)"></a>列表状态(ListState)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ListState</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">MergingState</span>&lt;<span class="title">T</span>, <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(List&lt;T&gt; values)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(List&lt;T&gt; values)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Iterable<T>get()：获取当前的列表状态，返回的是一个可迭代类型Iterable<T>。</T></T></p>
<p>update(List<T>values)：传入一个列表values，直接对状态进行覆盖。</T></p>
<p>add(Tvalue)：在状态列表中添加一个元素value。</p>
<p>addAll(List<T>values)：向列表中添加多个元素，以列表values形式传入。</T></p>
<p>在 Flink SQL 中，支持两条流的全量 Join，语法如下：SELECT * FROM A INNER JOIN B WHERE A.id = B.id；这样一条 SQL 语句要慎用，因为 Flink 会将 A 流和 B 流的所有数据都保存下来，然后进行 Join。不过在这里我们可以用列表状态变量来实现一下这个 SQL 语句的功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TwoStreamFullJoinExample</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    SingleOutputStreamOperator&lt;Tuple3&lt;String, String, Long&gt;&gt; stream1 = env</span><br><span class="line">            .fromElements(</span><br><span class="line">                    Tuple3.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;stream-1&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">                    Tuple3.of(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;stream-1&quot;</span>, <span class="number">2000L</span>)</span><br><span class="line">            )</span><br><span class="line">            .assignTimestampsAndWatermarks(</span><br><span class="line">                    WatermarkStrategy.&lt;Tuple3&lt;String, String, Long&gt;&gt;forMonotonousTimestamps()</span><br><span class="line">                            .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Tuple3&lt;String, String, Long&gt;&gt;() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Tuple3&lt;String, String, Long&gt; t, <span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">                                    <span class="keyword">return</span> t.f2;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;)</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    SingleOutputStreamOperator&lt;Tuple3&lt;String, String, Long&gt;&gt; stream2 = env</span><br><span class="line">            .fromElements(</span><br><span class="line">                    Tuple3.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;stream-2&quot;</span>, <span class="number">3000L</span>),</span><br><span class="line">                    Tuple3.of(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;stream-2&quot;</span>, <span class="number">4000L</span>)</span><br><span class="line">            )</span><br><span class="line">            .assignTimestampsAndWatermarks(</span><br><span class="line">                    WatermarkStrategy.&lt;Tuple3&lt;String, String, Long&gt;&gt;forMonotonousTimestamps()</span><br><span class="line">                            .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Tuple3&lt;String, String, Long&gt;&gt;() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Tuple3&lt;String, String, Long&gt; t, <span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">                                    <span class="keyword">return</span> t.f2;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;)</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    stream1.keyBy(r -&gt; r.f0)</span><br><span class="line">            .connect(stream2.keyBy(r -&gt; r.f0))</span><br><span class="line">            .process(<span class="keyword">new</span> CoProcessFunction&lt;Tuple3&lt;String, String, Long&gt;, Tuple3&lt;String, String, Long&gt;, String&gt;() &#123;</span><br><span class="line">                <span class="keyword">private</span> ListState&lt;Tuple3&lt;String, String, Long&gt;&gt; stream1ListState;</span><br><span class="line">                <span class="keyword">private</span> ListState&lt;Tuple3&lt;String, String, Long&gt;&gt; stream2ListState;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">super</span>.open(parameters);</span><br><span class="line">                    stream1ListState = getRuntimeContext().getListState(</span><br><span class="line">                            <span class="keyword">new</span> ListStateDescriptor&lt;Tuple3&lt;String, String, Long&gt;&gt;(<span class="string">&quot;stream1-list&quot;</span>, Types.TUPLE(Types.STRING, Types.STRING))</span><br><span class="line">                    );</span><br><span class="line">                    stream2ListState = getRuntimeContext().getListState(</span><br><span class="line">                            <span class="keyword">new</span> ListStateDescriptor&lt;Tuple3&lt;String, String, Long&gt;&gt;(<span class="string">&quot;stream2-list&quot;</span>, Types.TUPLE(Types.STRING, Types.STRING))</span><br><span class="line">                    );</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement1</span><span class="params">(Tuple3&lt;String, String, Long&gt; left, Context context, Collector&lt;String&gt; collector)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    stream1ListState.add(left);</span><br><span class="line">                    <span class="keyword">for</span> (Tuple3&lt;String, String, Long&gt; right : stream2ListState.get()) &#123;</span><br><span class="line">                        collector.collect(left + <span class="string">&quot; =&gt; &quot;</span> + right);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement2</span><span class="params">(Tuple3&lt;String, String, Long&gt; right, Context context, Collector&lt;String&gt; collector)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    stream2ListState.add(right);</span><br><span class="line">                    <span class="keyword">for</span> (Tuple3&lt;String, String, Long&gt; left : stream1ListState.get()) &#123;</span><br><span class="line">                        collector.collect(left + <span class="string">&quot; =&gt; &quot;</span> + right);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="映射状态-MapState"><a href="#映射状态-MapState" class="headerlink" title="映射状态(MapState)"></a>映射状态(MapState)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MapState</span>&lt;<span class="title">UK</span>, <span class="title">UV</span>&gt; <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="function">UV <span class="title">get</span><span class="params">(UK key)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(UK key, UV value)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;UK, UV&gt; map)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(UK key)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(UK key)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    Iterable&lt;Map.Entry&lt;UK, UV&gt;&gt; entries() <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="function">Iterable&lt;UK&gt; <span class="title">keys</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function">Iterable&lt;UV&gt; <span class="title">values</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    Iterator&lt;Map.Entry&lt;UK, UV&gt;&gt; iterator() <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>get(UKkey)：传入一个key作为参数，查询对应的value值。</p>
<p>put(UKkey,UVvalue)：传入一个键值对，更新key对应的value值。</p>
<p>putAll(Map&lt;UK,UV&gt;map)：将传入的映射map中所有的键值对，全部添加到映射状态中。</p>
<p>remove(UKkey)：将指定key对应的键值对删除。</p>
<p>contains(UK key)：判断是否存在指定的 key，返回一个 boolean 值。 另外，MapState 也提供了获取整个映射相关信息的方法。</p>
<p>entries()：获取映射状态中所有的键值对。</p>
<p>keys()：获取映射状态中所有的键(key)，返回一个可迭代 Iterable 类型。</p>
<p>values()：获取映射状态中所有的值(value)，返回一个可迭代 Iterable 类型。</p>
<p>booleanisEmpty()：判断映射是否为空，返回一个boolean值。</p>
<p>映射状态的用法和 Java 中的 HashMap 很相似。在这里我们可以通过 MapState 的使用来探索一下窗口的底层实现，也就是我们要用映射状态来完整模拟窗口的功能。这里我们模拟一个滚动窗口。我们要计算的是每一个 url 在每一个窗口中的 pv 数据。我们之前使用增量聚合和全窗口聚合结合的方式实现过这个需求。这里我们用 MapState 再来实现一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用KeyedProcessFunction模拟滚动窗口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    SingleOutputStreamOperator&lt;Event&gt; stream = env.addSource(<span class="keyword">new</span> ClickSource())</span><br><span class="line">            .assignTimestampsAndWatermarks(WatermarkStrategy.&lt;Event&gt;forMonotonousTimestamps()</span><br><span class="line">                    .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Event&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Event element, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> element.timestamp;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计每10s窗口内，每个url的pv</span></span><br><span class="line">    stream.keyBy(data -&gt; data.url)</span><br><span class="line">            .process(<span class="keyword">new</span> FakeWindowResult(<span class="number">10000L</span>))</span><br><span class="line">            .print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FakeWindowResult</span> <span class="keyword">extends</span> <span class="title">KeyedProcessFunction</span>&lt;<span class="title">String</span>, <span class="title">Event</span>, <span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 定义属性，窗口长度</span></span><br><span class="line">    <span class="keyword">private</span> Long windowSize;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FakeWindowResult</span><span class="params">(Long windowSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.windowSize = windowSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明状态，用map保存pv值（窗口start，count）</span></span><br><span class="line">    MapState&lt;Long, Long&gt; windowPvMapState;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        windowPvMapState = getRuntimeContext().getMapState(<span class="keyword">new</span> MapStateDescriptor&lt;Long, Long&gt;(<span class="string">&quot;window-pv&quot;</span>, Long.class, Long.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(Event value, Context ctx, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 每来一条数据，就根据时间戳判断属于哪个窗口</span></span><br><span class="line">        Long windowStart = value.timestamp / windowSize * windowSize;</span><br><span class="line">        Long windowEnd = windowStart + windowSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册 end -1 的定时器，窗口触发计算</span></span><br><span class="line">        ctx.timerService().registerEventTimeTimer(windowEnd - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新状态中的pv值</span></span><br><span class="line">        <span class="keyword">if</span> (windowPvMapState.contains(windowStart))&#123;</span><br><span class="line">            Long pv = windowPvMapState.get(windowStart);</span><br><span class="line">            windowPvMapState.put(windowStart, pv + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            windowPvMapState.put(windowStart, <span class="number">1L</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定时器触发，直接输出统计的pv结果</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTimer</span><span class="params">(<span class="keyword">long</span> timestamp, OnTimerContext ctx, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Long windowEnd = timestamp + <span class="number">1</span>;</span><br><span class="line">        Long windowStart = windowEnd - windowSize;</span><br><span class="line">        Long pv = windowPvMapState.get(windowStart);</span><br><span class="line">        out.collect( <span class="string">&quot;url: &quot;</span> + ctx.getCurrentKey()</span><br><span class="line">                + <span class="string">&quot; 访问量: &quot;</span> + pv</span><br><span class="line">                + <span class="string">&quot; 窗口：&quot;</span> + <span class="keyword">new</span> Timestamp(windowStart) + <span class="string">&quot; ~ &quot;</span> + <span class="keyword">new</span> Timestamp(windowEnd));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟窗口的销毁，清除map中的key</span></span><br><span class="line">        windowPvMapState.remove(windowStart);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="归约状态-ReducingState"><a href="#归约状态-ReducingState" class="headerlink" title="归约状态(ReducingState)"></a>归约状态(ReducingState)</h4><p>似于值状态(Value)，不过需要对添加进来的所有数据进行归约，将归约聚合之后的值作为状态保存下来。ReducintState<T>这个接口调用的方法类似于 ListState，只不过它保存的只是一个聚合值，所以调用.add()方法时，不是在状态列表里添加元素，而是直接把新数据和之前的状态进行归约，并用得到的结果更新状态。</T></p>
<p>归约逻辑的定义，是在归约状态描述器(ReducingStateDescriptor)中，通过传入一个归 约函数(ReduceFunction)来实现的。这里的归约函数，就是我们之前介绍 reduce 聚合算子时讲到的 ReduceFunction，所以状态类型跟输入的数据类型是一样的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReducingStateDescriptor</span><span class="params">( String name, ReduceFunction&lt;T&gt; reduceFunction, Class&lt;T&gt; typeClass)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>这里的描述器有三个参数，其中第二个参数就是定义了归约聚合逻辑的 ReduceFunction， 另外两个参数则是状态的名称和类型。</p>
<h4 id="聚合状态-AggregatingState"><a href="#聚合状态-AggregatingState" class="headerlink" title="聚合状态(AggregatingState)"></a>聚合状态(AggregatingState)</h4><p>与归约状态非常类似，聚合状态也是一个值，用来保存添加进来的所有数据的聚合结果。与 ReducingState 不同的是，它的聚合逻辑是由在描述器中传入一个更加一般化的聚合函数(AggregateFunction)来定义的；这也就是之前我们讲过的 AggregateFunction，里面通过一个累加器(Accumulator)来表示状态，所以聚合的状态类型可以跟添加进来的数据类型完全不同，使用更加灵活。</p>
<p>同样地，AggregatingState 接口调用方法也与 ReducingState 相同，调用.add()方法添加元素时，会直接使用指定的 AggregateFunction 进行聚合并更新状态。</p>
<p>们举一个简单的例子，对用户点击事件流每 5 个数据统计一次平均时间戳。这是一个类似计数窗口(CountWindow)求平均值的计算，这里我们可以使用一个有聚合状态的 RichFlatMapFunction 来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AverageTimestampExample</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    SingleOutputStreamOperator&lt;Event&gt; stream = env.addSource(<span class="keyword">new</span> ClickSource())</span><br><span class="line">            .assignTimestampsAndWatermarks(WatermarkStrategy.&lt;Event&gt;forMonotonousTimestamps()</span><br><span class="line">                    .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Event&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Event element, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> element.timestamp;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计每个用户的点击频次，到达5次就输出统计结果</span></span><br><span class="line">    stream.keyBy(data -&gt; data.user)</span><br><span class="line">            .flatMap(<span class="keyword">new</span> AvgTsResult())</span><br><span class="line">            .print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AvgTsResult</span> <span class="keyword">extends</span> <span class="title">RichFlatMapFunction</span>&lt;<span class="title">Event</span>, <span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 定义聚合状态，用来计算平均时间戳</span></span><br><span class="line">    AggregatingState&lt;Event, Long&gt; avgTsAggState;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个值状态，用来保存当前用户访问频次</span></span><br><span class="line">    ValueState&lt;Long&gt; countState;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        avgTsAggState = getRuntimeContext().getAggregatingState(<span class="keyword">new</span> AggregatingStateDescriptor&lt;Event, Tuple2&lt;Long, Long&gt;, Long&gt;(</span><br><span class="line">                <span class="string">&quot;avg-ts&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> AggregateFunction&lt;Event, Tuple2&lt;Long, Long&gt;, Long&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Tuple2&lt;Long, Long&gt; <span class="title">createAccumulator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> Tuple2.of(<span class="number">0L</span>, <span class="number">0L</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Tuple2&lt;Long, Long&gt; <span class="title">add</span><span class="params">(Event value, Tuple2&lt;Long, Long&gt; accumulator)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> Tuple2.of(accumulator.f0 + value.timestamp, accumulator.f1 + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Long <span class="title">getResult</span><span class="params">(Tuple2&lt;Long, Long&gt; accumulator)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> accumulator.f0 / accumulator.f1;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Tuple2&lt;Long, Long&gt; <span class="title">merge</span><span class="params">(Tuple2&lt;Long, Long&gt; a, Tuple2&lt;Long, Long&gt; b)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                Types.TUPLE(Types.LONG, Types.LONG)</span><br><span class="line">        ));</span><br><span class="line"></span><br><span class="line">        countState = getRuntimeContext().getState(<span class="keyword">new</span> ValueStateDescriptor&lt;Long&gt;(<span class="string">&quot;count&quot;</span>, Long.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(Event value, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Long count = countState.value();</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="keyword">null</span>)&#123;</span><br><span class="line">            count = <span class="number">1L</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        countState.update(count);</span><br><span class="line">        avgTsAggState.add(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 达到5次就输出结果，并清空状态</span></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">5</span>)&#123;</span><br><span class="line">            out.collect(value.user + <span class="string">&quot; 平均时间戳：&quot;</span> + <span class="keyword">new</span> Timestamp(avgTsAggState.get()));</span><br><span class="line">            countState.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="状态生存时间-TTL"><a href="#状态生存时间-TTL" class="headerlink" title="状态生存时间(TTL)"></a>状态生存时间(TTL)</h4><p>在实际应用中，很多状态会随着时间的推移逐渐增长，如果不加以限制，最终就会导致存储空间的耗尽。一个优化的思路是直接在代码中调用.clear()方法去清除状态，但是有时候我们的逻辑要求不能直接清除。这时就需要配置一个状态的生存时间(time-to-live，TTL)，当状态在内存中存在的时间超出这个值时，就将它清除。</p>
<p>具体实现上，如果用一个进程不停地扫描所有状态看是否过期，显然会占用大量资源做无用功。状态的失效其实不需要立即删除，所以我们可以给状态附加一个属性，也就是状态的失效时间。状态创建的时候，设置 失效时间 = 当前时间 + TTL；之后如果有对状态的访问和修改，我们可以再对失效时间进行更新；当设置的清除条件被触发时(比如，状态被访问的时候、或者每隔一段时间扫描一次失效状态)，就可以判断状态是否失效、从而进行清除了。</p>
<p>配置状态的 TTL 时，需要创建一个 StateTtlConfig 配置对象，然后调用状态描述器的.enableTimeToLive()方法启动 TTL 功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">StateTtlConfig ttlConfig = StateTtlConfig</span><br><span class="line">   .newBuilder(Time.seconds(<span class="number">10</span>))</span><br><span class="line">   .setUpdateType(StateTtlConfig.UpdateType.OnCreateAndWrite)</span><br><span class="line">   .setStateVisibility(StateTtlConfig.StateVisibility.NeverReturnExpired)</span><br><span class="line">   .build();</span><br><span class="line">   </span><br><span class="line">ValueStateDescriptor&lt;String&gt; stateDescriptor = <span class="keyword">new</span> ValueStateDescriptor&lt;&gt;(<span class="string">&quot;my state&quot;</span>, String.class);</span><br><span class="line">stateDescriptor.enableTimeToLive(ttlConfig);</span><br></pre></td></tr></table></figure>

<p><strong>.newBuilder()</strong></p>
<p>状态 TTL 配置的构造器方法，必须调用，返回一个 Builder 之后再调用.build()方法就可以得到 StateTtlConfig 了。方法需要传入一个 Time 作为参数，这就是设定的状态生存时间。</p>
<p><strong>.setUpdateType()</strong></p>
<p>设置更新类型。更新类型指定了什么时候更新状态失效时间，这里的 OnCreateAndWrite 表示只有创建状态和更改状态(写操作)时更新失效时间。另一种类型 OnReadAndWrite 则表示无论读写操作都会更新失效时间，也就是只要对状态进行了访问，就表明它是活跃的，从而延长生存时间。这个配置默认为 OnCreateAndWrite。</p>
<p><strong>.setStateVisibility()</strong></p>
<p>设置状态的可见性。所谓的状态可见性，是指因为清除操作并不是实时的，所以当状态过期之后还有可能继续存在，这时如果对它进行访问，能否正常读取到就是一个问题了。这里设置的 NeverReturnExpired 是默认行为，表示从不返回过期值，也就是只要过期就认为它已经被清除了，应用不能继续读取；这在处理会话或者隐私数据时比较重要。对应的另一种配置是 ReturnExpireDefNotCleanedUp，就是如果过期状态还存在，就返回它的值。</p>
<p>除此之外，TTL 配置还可以设置在保存检查点(checkpoint)时触发清除操作，或者配置增量的清理(incremental cleanup)，还可以针对 RocksDB 状态后端使用压缩过滤器(compaction filter)进行后台清理。</p>
<p>这里需要注意，目前的 TTL 设置只支持处理时间。另外，所有集合类型的状态(例如 ListState、MapState)在设置 TTL 时，都是针对每一项(per-entry)元素的。也就是说，一个列表状态中的每一个元素，都会以自己的失效时间来进行清理，而不是整个列表一起清理。</p>
<h3 id="算子状态-Operator-State"><a href="#算子状态-Operator-State" class="headerlink" title="算子状态(Operator State)"></a>算子状态(Operator State)</h3><p>算子状态(Operator State)就是一个算子并行实例上定义的状态，作用范围被限定为当前算子任务。<strong>算子状态跟数据的 key 无关</strong>，所以不同 key 的数据只要被分发到同一个并行子任务， 就会访问到同一个 Operator State。</p>
<p>算子状态的实际应用场景不如 Keyed State 多，一般用在 Source 或 Sink 等与外部系统连接的算子上，或者完全没有 key 定义的场景。比如 Flink 的 Kafka 连接器中，就用到了算子状态。 在我们给 Source 算子设置并行度后，Kafka 消费者的每一个并行实例，都会为对应的主题topic)分区维护一个偏移量， 作为算子状态保存起来。这在保证 Flink 应用精确一次(exactly-once)状态一致性时非常有用。 当算子的并行度发生变化时，算子状态也支持在并行的算子任务实例之间做重组分配。根据状态的类型不同，重组分配的方案也会不同。</p>
<p>算子状态也支持不同的结构类型，主要有三种：ListState、UnionListState 和 BroadcastState。</p>
<h4 id="列表状态-ListState-1"><a href="#列表状态-ListState-1" class="headerlink" title="列表状态(ListState)"></a>列表状态(ListState)</h4><p>与 Keyed State 中的列表状态的区别是：在算子状态的上下文中，不会按键(key)分别处理状态，所以每一个并行子任务上只会保留一个列表(list)，也就是当前并行子任务上所有状态项的集合。列表中的状态项就是可以重新分配的最细粒度，彼此之间完全独立。</p>
<p>当算子并行度进行缩放调整时，算子的列表状态中的所有元素项会被统一收集起来，相当于把多个分区的列表合并成了一个大列表，然后再均匀地分配给所有并行任务。这种均匀分配的具体方法就是轮询(round-robin)，与之前介绍的 rebanlance 数据传输方式类似， 是通过逐一发牌的方式将状态项平均分配的。这种方式也叫作平均分割重组(even-split redistribution)。</p>
<p>算子状态中不会存在键组(key group)这样的结构，所以为了方便重组分配，就把它直接定义成了列表(list)。这也就解释了，为什么算子状态中没有最简单的值状态(ValueState)。</p>
<h4 id="联合列表状态-UnionListState"><a href="#联合列表状态-UnionListState" class="headerlink" title="联合列表状态(UnionListState)"></a>联合列表状态(UnionListState)</h4><p>与 ListState 类似，联合列表状态也会将状态表示为一个列表。它与常规列表状态的区别在于，算子并行度进行缩放调整时对于状态的分配方式不同。</p>
<p>UnionListState 的重点就在于联合(union)。在并行度调整时，<strong>常规列表状态是轮询分配状态项</strong>，而<strong>联合列表状态的算子则会直接广播状态的完整列表</strong>。这样，并行度缩放之后的并行子任务就获取到了联合后完整的大列表，可以自行选择要使用的状态项和要丢弃的状态项。这种分配也叫作联合重组(union redistribution)。如果列表中状态项数量太多，为资源和效率考虑一般不建议使用联合重组的方式。</p>
<h4 id="广播状态-BroadcastState"><a href="#广播状态-BroadcastState" class="headerlink" title="广播状态(BroadcastState)"></a>广播状态(BroadcastState)</h4><p>有时我们希望<strong>算子并行子任务都保持同一份全局状态</strong>，用来做统一的配置和规则设定。 这时所有分区的所有数据都会访问到同一个状态，状态就像被广播到所有分区一样，这种特殊的算子状态，就叫作广播状态(BroadcastState)。</p>
<p>因为广播状态在每个并行子任务上的实例都一样，所以在并行度调整的时候就比较简单， 只要复制一份到新的并行任务就可以实现扩展；而对于并行度缩小的情况，可以将多余的并行子任务连同状态直接砍掉——因为状态都是复制出来的，并不会丢失。</p>
<p>在底层，广播状态是以类似映射结构(map)的键值对(key-value)来保存的，必须基于一个广播流(BroadcastStream)来创建。</p>
<p>我们举一个广播状态的应用案例。考虑在电商应用中，往往需要判断用户先后发生的行为的组合模式，比如登录-下单或者登录-支付，检测出这些连续的行为进行统计，就可以了解平台的运用状况以及用户的行为习惯。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取用户行为事件流</span></span><br><span class="line">    DataStreamSource&lt;Action&gt; actionStream = env.fromElements(</span><br><span class="line">            <span class="keyword">new</span> Action(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;login&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> Action(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;pay&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> Action(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;login&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> Action(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;buy&quot;</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义行为模式流，代表了要检测的标准</span></span><br><span class="line">    DataStreamSource&lt;Pattern&gt; patternStream = env</span><br><span class="line">            .fromElements(</span><br><span class="line">                    <span class="keyword">new</span> Pattern(<span class="string">&quot;login&quot;</span>, <span class="string">&quot;pay&quot;</span>),</span><br><span class="line">                    <span class="keyword">new</span> Pattern(<span class="string">&quot;login&quot;</span>, <span class="string">&quot;buy&quot;</span>)</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义广播状态的描述器，创建广播流</span></span><br><span class="line">    MapStateDescriptor&lt;Void, Pattern&gt; bcStateDescriptor = <span class="keyword">new</span> MapStateDescriptor&lt;&gt;(</span><br><span class="line">            <span class="string">&quot;patterns&quot;</span>, Types.VOID, Types.POJO(Pattern.class));</span><br><span class="line">    BroadcastStream&lt;Pattern&gt; bcPatterns = patternStream.broadcast(bcStateDescriptor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将事件流和广播流连接起来，进行处理</span></span><br><span class="line">    DataStream&lt;Tuple2&lt;String, Pattern&gt;&gt; matches = actionStream</span><br><span class="line">            .keyBy(data -&gt; data.userId)</span><br><span class="line">            .connect(bcPatterns)</span><br><span class="line">            .process(<span class="keyword">new</span> PatternEvaluator());</span><br><span class="line"></span><br><span class="line">    matches.print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PatternEvaluator</span> <span class="keyword">extends</span> <span class="title">KeyedBroadcastProcessFunction</span>&lt;<span class="title">String</span>, <span class="title">Action</span>, <span class="title">Pattern</span>, <span class="title">Tuple2</span>&lt;<span class="title">String</span>, <span class="title">Pattern</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个值状态，保存上一次用户行为</span></span><br><span class="line">    ValueState&lt;String&gt; prevActionState;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration conf)</span> </span>&#123;</span><br><span class="line">        prevActionState = getRuntimeContext().getState(</span><br><span class="line">                <span class="keyword">new</span> ValueStateDescriptor&lt;&gt;(<span class="string">&quot;lastAction&quot;</span>, Types.STRING));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processBroadcastElement</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            Pattern pattern,</span></span></span><br><span class="line"><span class="params"><span class="function">            Context ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">            Collector&lt;Tuple2&lt;String, Pattern&gt;&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        BroadcastState&lt;Void, Pattern&gt; bcState = ctx.getBroadcastState(</span><br><span class="line">                <span class="keyword">new</span> MapStateDescriptor&lt;&gt;(<span class="string">&quot;patterns&quot;</span>, Types.VOID, Types.POJO(Pattern.class)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将广播状态更新为当前的pattern</span></span><br><span class="line">        bcState.put(<span class="keyword">null</span>, pattern);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(Action action, ReadOnlyContext ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">                               Collector&lt;Tuple2&lt;String, Pattern&gt;&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Pattern pattern = ctx.getBroadcastState(</span><br><span class="line">                <span class="keyword">new</span> MapStateDescriptor&lt;&gt;(<span class="string">&quot;patterns&quot;</span>, Types.VOID, Types.POJO(Pattern.class))).get(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        String prevAction = prevActionState.value();</span><br><span class="line">        <span class="keyword">if</span> (pattern != <span class="keyword">null</span> &amp;&amp; prevAction != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果前后两次行为都符合模式定义，输出一组匹配</span></span><br><span class="line">            <span class="keyword">if</span> (pattern.action1.equals(prevAction) &amp;&amp; pattern.action2.equals(action.action)) &#123;</span><br><span class="line">                out.collect(<span class="keyword">new</span> Tuple2&lt;&gt;(ctx.getCurrentKey(), pattern));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新状态</span></span><br><span class="line">        prevActionState.update(action.action);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义用户行为事件POJO类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String userId;</span><br><span class="line">    <span class="keyword">public</span> String action;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Action</span><span class="params">(String userId, String action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userId = userId;</span><br><span class="line">        <span class="keyword">this</span>.action = action;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Action&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;userId=&quot;</span> + userId +</span><br><span class="line">                <span class="string">&quot;, action=&#x27;&quot;</span> + action + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义行为模式POJO类，包含先后发生的两个行为</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pattern</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String action1;</span><br><span class="line">    <span class="keyword">public</span> String action2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pattern</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pattern</span><span class="params">(String action1, String action2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.action1 = action1;</span><br><span class="line">        <span class="keyword">this</span>.action2 = action2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Pattern&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;action1=&#x27;&quot;</span> + action1 + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, action2=&#x27;&quot;</span> + action2 + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="状态持久化和状态后端"><a href="#状态持久化和状态后端" class="headerlink" title="状态持久化和状态后端"></a>状态持久化和状态后端</h3><h4 id="检查点-Checkpoint"><a href="#检查点-Checkpoint" class="headerlink" title="检查点(Checkpoint)"></a>检查点(Checkpoint)</h4><p>有状态流应用中的检查点(checkpoint)，其实就是所有任务的状态在某个时间点的一个快照(一份拷贝)。</p>
<p>我们对状态进行持久化保存的目的是为了故障恢复；在发生故障、重启应用后，数据还会被发往之前分配的分区吗？显然不是，因为并行度可能发生了调整，不论是按键(key)的哈希值分区，还是直接轮询(round-robin)分区，数据分配到的分区都会发生变化。这很好理解，当打牌的人数 3 个增加到 4 个时，即使牌的次序不变，轮流发到每个人手里的牌也会不同。数据分区发生变化，带来的问题就是，怎么保证原先的状态跟故障恢复后数据的对应关系呢？</p>
<p>对于Keyed State这个问题很好解决：状态都是跟key相关的，而相同key的数据不管发往哪个分区，总是会全部进入一个分区的；于是只要将状态也按照 key 的哈希值计算出对应的分区，进行重组分配就可以了。恢复状态后继续处理数据，就总能按照 key 找到对应之前的状态，就保证了结果的一致性。所以 Flink 对 Keyed State 进行了非常完善的包装，我们不需实现 任何接口就可以直接使用。</p>
<p>而对于 Operator State 来说就会有所不同。因为不存在 key，所有数据发往哪个分区是不可预测的；也就是说，当发生故障重启之后，我们不能保证某个数据跟之前一样，进入到同一个并行子任务、访问同一个状态。所以 Flink 无法直接判断该怎样保存和恢复状态，而是提供了接口，让我们根据业务需求自行设计状态的快照保存(snapshot)和恢复(restore)逻辑。</p>
<p>在 Flink 中，对状态进行持久化保存的快照机制叫作检查点(Checkpoint)。于是使用算子状态时，就需要对检查点的相关操作进行定义，实现一个 CheckpointedFunction 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CheckpointedFunction</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 保存状态快照到检查点时(外部持久化)，调用这个方法</span></span><br><span class="line">   	<span class="function"><span class="keyword">void</span> <span class="title">snapshotState</span><span class="params">(FunctionSnapshotContext context)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">		<span class="comment">// 初始化状态时调用这个方法，也会在恢复状态时调用</span></span></span><br><span class="line"><span class="function">		<span class="keyword">void</span> <span class="title">initializeState</span><span class="params">(FunctionInitializationContext context)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BufferingSinkExample</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    env.enableCheckpointing(<span class="number">10000L</span>);</span><br><span class="line">      <span class="comment">//env.setStateBackend(new EmbeddedRocksDBStateBackend());</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//env.getCheckpointConfig().setCheckpointStorage(new FileSystemCheckpointStorage(&quot;&quot;));</span></span><br><span class="line"></span><br><span class="line">    CheckpointConfig checkpointConfig = env.getCheckpointConfig();</span><br><span class="line">    checkpointConfig.setCheckpointingMode(CheckpointingMode.EXACTLY_ONCE);</span><br><span class="line">    checkpointConfig.setMinPauseBetweenCheckpoints(<span class="number">500</span>);</span><br><span class="line">    checkpointConfig.setCheckpointTimeout(<span class="number">60000</span>);</span><br><span class="line">    checkpointConfig.setMaxConcurrentCheckpoints(<span class="number">1</span>);</span><br><span class="line">    checkpointConfig.enableExternalizedCheckpoints(</span><br><span class="line">            CheckpointConfig.ExternalizedCheckpointCleanup.RETAIN_ON_CANCELLATION);</span><br><span class="line">    checkpointConfig.enableUnalignedCheckpoints();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    SingleOutputStreamOperator&lt;Event&gt; stream = env.addSource(<span class="keyword">new</span> ClickSource())</span><br><span class="line">            .assignTimestampsAndWatermarks(WatermarkStrategy.&lt;Event&gt;forMonotonousTimestamps()</span><br><span class="line">                    .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Event&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Event element, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> element.timestamp;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    stream.print(<span class="string">&quot;input&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 批量缓存输出</span></span><br><span class="line">    stream.addSink(<span class="keyword">new</span> BufferingSink(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferingSink</span> <span class="keyword">implements</span> <span class="title">SinkFunction</span>&lt;<span class="title">Event</span>&gt;, <span class="title">CheckpointedFunction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threshold;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ListState&lt;Event&gt; checkpointedState;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Event&gt; bufferedElements;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BufferingSink</span><span class="params">(<span class="keyword">int</span> threshold)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.threshold = threshold;</span><br><span class="line">        <span class="keyword">this</span>.bufferedElements = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Event value, Context context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        bufferedElements.add(value);</span><br><span class="line">        <span class="keyword">if</span> (bufferedElements.size() == threshold) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Event element: bufferedElements) &#123;</span><br><span class="line">                <span class="comment">// 输出到外部系统，这里用控制台打印模拟</span></span><br><span class="line">                System.out.println(element);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;==========输出完毕=========&quot;</span>);</span><br><span class="line">            bufferedElements.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">snapshotState</span><span class="params">(FunctionSnapshotContext context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        checkpointedState.clear();</span><br><span class="line">        <span class="comment">// 把当前局部变量中的所有元素写入到检查点中</span></span><br><span class="line">        <span class="keyword">for</span> (Event element : bufferedElements) &#123;</span><br><span class="line">            checkpointedState.add(element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initializeState</span><span class="params">(FunctionInitializationContext context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ListStateDescriptor&lt;Event&gt; descriptor = <span class="keyword">new</span> ListStateDescriptor&lt;&gt;(</span><br><span class="line">                <span class="string">&quot;buffered-elements&quot;</span>,</span><br><span class="line">                Types.POJO(Event.class));</span><br><span class="line"></span><br><span class="line">        checkpointedState = context.getOperatorStateStore().getListState(descriptor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是从故障中恢复，就将ListState中的所有元素添加到局部变量中</span></span><br><span class="line">        <span class="keyword">if</span> (context.isRestored()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Event element : checkpointedState.get()) &#123;</span><br><span class="line">                bufferedElements.add(element);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果保存检查点之后又处理了一些数据，然后发生了故障，那么重启恢复状态之后这些数据带来的状态改变会丢失。为了让最终处理结果正确，我们还需要让源(Source)算子重新读取这些数据，再次处理一遍。这就需要流的数据源具有<strong>数据重放</strong>的能力，一个典型的例子就是 Kafka，我们可以通过保存消费数据的偏移量、故障重启后重新提交来实现数据的重放。 这是对**至少一次(at least once)**状态一致性的保证，如果希望实现精确一次(exactly once) 的一致性，还需要数据写入外部系统时的相关保证。</p>
<p>默认情况下，检查点是被禁用的，需要在代码中手动开启。直接调用执行环境 的.enableCheckpointing()方法就可以开启检查点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StreamExecutionEnvironment env = StreamExecutionEnvironment.getEnvironment();</span><br><span class="line"><span class="comment">//这里传入的参数是检查点的间隔时间，单位为毫秒</span></span><br><span class="line">env.enableCheckpointing(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>除了检查点之外，Flink 还提供了保存点(savepoint)的功能。保存点在原理和形式上跟检查点完全一样，也是状态持久化保存的一个快照；区别在于，保存点是自定义的镜像保存，所以不会由 Flink 自动创建，而需要用户手动触发。这在有计划地停止、重启应用时非常有用。</p>
<h4 id="状态后端-State-Backends"><a href="#状态后端-State-Backends" class="headerlink" title="状态后端(State Backends)"></a>状态后端(State Backends)</h4><p>检查点的保存离不开 JobManager 和 TaskManager，以及外部存储系统的协调。在应用进行检查点保存时，首先会由 JobManager 向所有 TaskManager 发出触发检查点的命令；TaskManger 收到之后，将当前任务的所有状态进行快照保存，持久化到远程的存储介质中；完成之后向 JobManager 返回确认信息。这个过程是分布式的，当 JobManger 收到所有 TaskManager 的返回信息后，就会确认当前检查点成功保存，如图 9-5 所示。而这一切工作的协调，就需要一个专职人员来完成。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-03-28%20%E4%B8%8B%E5%8D%883.40.58.png" alt="截屏2022-03-28 下午3.40.58"></p>
<p>在 Flink 中，状态的存储、访问以及维护，都是由一个可插拔的组件决定的，这个组件就叫作状态后端(state backend)。状态后端主要负责两件事：一是本地的状态管理，二是将检查点(checkpoint)写入远程的持久化存储。</p>
<h5 id="状态后端的分类"><a href="#状态后端的分类" class="headerlink" title="状态后端的分类"></a><strong>状态后端的分类</strong></h5><p>状态后端是一个开箱即用的组件，可以在不改变应用程序逻辑的情况下独立配置。 Flink 中提供了两类不同的状态后端，一种是哈希表状态后端(HashMapStateBackend)，另一种是内嵌 RocksDB 状态后端(EmbeddedRocksDBStateBackend)。如果没有特别配置，系统默认的状态后端是 HashMapStateBackend。</p>
<p><strong>哈希表状态后端(HashMapStateBackend)</strong></p>
<p>这种方式就是我们之前所说的，把状态存放在<strong>内存</strong>里。具体实现上，哈希表状态后端在内部会直接把状态当作对象(objects)，保存在 Taskmanager 的 JVM 堆(heap)上。普通的<strong>状态</strong>，以及<strong>窗口中收集的数据</strong>和**触发器(triggers)**，都会以键值对(key-value)的形式存储起来，所以底层是一个哈希表(HashMap)，这种状态后端也因此得名。</p>
<p>对于检查点的保存，一般是放在持久化的分布式文件系统(file system)中，也可以通过配置检查点存储(CheckpointStorage)来另外指定。</p>
<p>HashMapStateBackend 是将本地状态全部放入内存的，这样可以获得最快的读写速度，使计算性能达到最佳；代价则是内存的占用。它适用于具有大状态、长窗口、大键值状态的作业，对所有高可用性设置也是有效的。</p>
<p><strong>内嵌 RocksDB 状态后端(EmbeddedRocksDBStateBackend)</strong></p>
<p>RocksDB 是一种内嵌的 key-value 存储介质，可以把数据持久化到<strong>本地硬盘</strong>。配置 EmbeddedRocksDBStateBackend 后，会将处理中的数据全部放入 RocksDB 数据库中，RocksDB 默认存储在 TaskManager 的本地数据目录里。</p>
<p>与 HashMapStateBackend 直接在堆内存中存储对象不同，这种方式下状态主要是放在 RocksDB 中的。数据被存储为**序列化的字节数组(Byte Arrays)**，读写操作需要序列化/反序列化，因此状态的访问性能要差一些。另外，因为做了序列化，key 的比较也会按照字节进行，而不是直接调用.hashCode()和.equals()方法。</p>
<p>对于检查点，同样会写入到远程的持久化文件系统中。</p>
<p>EmbeddedRocksDBStateBackend 始终执行的是异步快照，也就是不会因为保存检查点而阻塞数据的处理；而且它还提供了增量式保存检查点的机制，这在很多情况下可以大大提升保存效率。</p>
<p>由于它会把状态数据落盘，而且支持增量化的检查点，所以在状态非常大、窗口非常长、 键/值状态很大的应用场景中是一个好选择，同样对所有高可用性设置有效。</p>
<h5 id="如何选择正确的状态后端"><a href="#如何选择正确的状态后端" class="headerlink" title="如何选择正确的状态后端"></a>如何选择正确的状态后端</h5><p>HashMap 和 RocksDB 两种状态后端最大的区别，就在于本地状态存放在哪里：前者是内存，后者是 RocksDB。在实际应用中，选择那种状态后端，主要是需要根据业务需求在处理性能和应用的扩展性上做一个选择。</p>
<p>HashMapStateBackend 是内存计算，读写速度非常快；但是，状态的大小会受到集群可用内存的限制，如果应用的状态随着时间不停地增长，就会耗尽内存资源。</p>
<p>而 RocksDB 是硬盘存储，所以可以根据可用的磁盘空间进行扩展，而且是唯一支持增量检查点的状态后端，所以它非常适合于超级海量状态的存储。不过由于每个状态的读写都需要做序列化/反序列化，而且可能需要直接从磁盘读取数据，这就会导致性能的降低，平均读写性能要比 HashMapStateBackend 慢一个数量级。</p>
<h5 id="状态后端的配置"><a href="#状态后端的配置" class="headerlink" title="状态后端的配置"></a>状态后端的配置</h5><p>在不做配置的时候，应用程序使用的默认状态后端是由集群配置文件 flink-conf.yaml 中指定的，配置的键名称为 state.backend。这个默认配置对集群上运行的所有作业都有效，我们可以通过更改配置值来改变默认的状态后端。另外，我们还可以在代码中为当前作业单独配置状态后端，这个配置会覆盖掉集群配置文件的默认值。</p>
<p>配置默认的状态后端：</p>
<p>在 flink-conf.yaml 中，可以使用 state.backend 来配置默认状态后端。配置项的可能值为 hashmap，这样配置的就是 HashMapStateBackend；也可以是 rocksdb，这样配置的就是 EmbeddedRocksDBStateBackend。另外，也可以是一个实现了状态后端工厂 StateBackendFactory 的类的完全限定类名。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认状态后端</span></span><br><span class="line"><span class="attr">state.backend:</span> <span class="string">hashmap</span></span><br><span class="line"><span class="comment"># 存放检查点的文件路径</span></span><br><span class="line"><span class="attr">state.checkpoints.dir:</span> <span class="string">hdfs://namenode:40010/flink/checkpoints</span></span><br></pre></td></tr></table></figure>

<p>这里的 state.checkpoints.dir 配置项，定义了状态后端将检查点和元数据写入的目录。</p>
<p>为每个作业(Per-job)单独配置状态后端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">env.setStateBackend(<span class="keyword">new</span> HashMapStateBackend());</span><br><span class="line"><span class="comment">//env.setStateBackend(new EmbeddedRocksDBStateBackend());</span></span><br></pre></td></tr></table></figure>

<p>需添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-statebackend-rocksdb_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.13.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="容错机制"><a href="#容错机制" class="headerlink" title="容错机制"></a>容错机制</h2><h3 id="检查点的保存"><a href="#检查点的保存" class="headerlink" title="检查点的保存"></a>检查点的保存</h3><h4 id="周期性的触发保存"><a href="#周期性的触发保存" class="headerlink" title="周期性的触发保存"></a>周期性的触发保存</h4><p>随时存档确实恢复起来方便，可是需要我们不停地做存档操作。如果每处理一条数据就进行检查点的保存，当大量数据同时到来时，就会耗费很多资源来频繁做检查点，数据处理的速度就会受到影响。所以更好的方式是，每隔一段时间去做一次存档，这样既不会影响数据的正常处理，也不会有太大的延迟——毕竟故障恢复的情况不是随时发生的。在 Flink 中，检查点的保存是周期性触发的，间隔时间可以进行设置。</p>
<p>所以检查点作为应用状态的一份存档，其实就是所有任务状态在同一时间点的一个快照(snapshot)，它的触发是周期性的。具体来说，当每隔一段时间检查点保存操作被触发时， 就把每个任务当前的状态复制一份，按照一定的逻辑结构放在一起持久化保存起来，就构成了检查点。</p>
<h4 id="保存的时间点"><a href="#保存的时间点" class="headerlink" title="保存的时间点"></a>保存的时间点</h4><p>这里有一个关键问题：当检查点的保存被触发时，任务有可能正在处理某个数据，这时该怎么办呢？最简单的想法是，可以在某个时刻按下暂停键，让所有任务停止处理数据。这样状态就不再更改，大家可以一起复制保存；保存完毕之后，再同时恢复数据处理就可以了。 然而仔细思考就会发现这有很多问题。这种想法其实是粗暴地停止一切来拍照，在保存检查点的过程中，任务完全中断了，这会造成很大的延迟；我们之前为了实时性做出的所有设计就毁在了做快照上。另一方面，我们做快照的目的是为了故障恢复；现在的快照中，有些任务正在处理数据，那它保存的到底是处理到什么程度的状态呢？举个例子，我们在程序中某一步操作中自定义了一个 ValueState，处理的逻辑是：当遇到一个数据时，状态先加 1；而后经过一些其他步骤后再加 1。现在停止处理数据，状态到底是被加了 1 还是加了 2 呢？这很重要，因为状态恢复之后，我们需要知道当前数据从哪里开始继续处理。要满足这个要求，就必须将暂停时的所有环境信息都保存下来——而这显然是很麻烦的。 为了解决这个问题，我们不应该一刀切把所有任务同时停掉，而是至少得先把手头正在处理的数据弄完。这样的话，我们在检查点中就不需要保存所有上下文信息，只要知道当前处理到哪个数据就可以了。</p>
<p>但这样依然会有问题：分布式系统的节点之间需要通过网络通信来传递数据，如果我们保存检查点的时候刚好有数据在网络传输的路上，那么下游任务是没法将数据保存起来的；故障重启之后，我们只能期待上游任务重新发送这个数据。然而上游任务是无法知道下游任务是否收到数据的，只能盲目地重发，这可能导致下游将数据处理两次，结果就会出现错误。</p>
<p>所以我们最终的选择是；当所有任务都恰好处理完一个相同的输入数据的时候，将它们的状态保存下来。首先，这样避免了除状态之外其他额外信息的存储，提高了检查点保存的效率。 其次，一个数据要么就是被所有任务完整地处理完，状态得到了保存；要么就是没处理完，状态全部没保存：这就相当于构建了一个事务(transaction)。如果出现故障，我们恢复到之前保存的状态，故障时正在处理的所有数据都需要重新处理；所以我们只需要让源(source) 任务向数据源重新提交偏移量、请求重放数据就可以了。这<strong>需要源任务可以把偏移量作为算子状态保存下来</strong>，而且<strong>外部数据源能够重置偏移量</strong>；Kafka 就是满足这些要求的一个最好的例子。</p>
<h4 id="保存的具体流程"><a href="#保存的具体流程" class="headerlink" title="保存的具体流程"></a>保存的具体流程</h4><p>检查点的保存，最关键的就是要等所有任务将同一个数据处理完毕。下面我们通过一个具体的例子，来详细描述一下检查点具体的保存过程。回忆一下我们最初实现的统计词频的程序——WordCount。这里为了方便，我们直接从数据源读入已经分开的一个个单词，例如这里输入的就是：hello world hello flink hello world hello flink …… 对应的代码就可以简化为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SingleOutputStreamOperator&lt;Tuple2&lt;String, Long&gt;&gt; wordCountStream =</span><br><span class="line">   env.addSource(...)</span><br><span class="line">       .map(word -&gt; Tuple2.of(word, <span class="number">1L</span>))</span><br><span class="line">       .returns(Types.TUPLE(Types.STRING, Types.LONG))</span><br><span class="line">       .keyBy(t -&gt; t.f0)</span><br><span class="line">       .sum(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>源(Source)任务从外部数据源读取数据，并<strong>记录当前的偏移量</strong>，作为<strong>算子状态(Operator State)<strong>保存下来。然后将数据发给下游的 Map 任务，它会将一个单词转换成(word, count)二元组，初始 count 都是 1，也就是(“hello”, 1)、(“world”, 1)这样的形式；这是一个无状态的算子任务。进而以 word 作为键(key)进行分区，调用.sum()方法就可以对 count 值进行求和统计了；Sum 算子会把当前</strong>求和的结果</strong>作为**按键分区状态(Keyed State)**保存下来。最后得到的就是当前单词的频次统计(word, count)，如图 10-2 所示。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-07-11%20%E4%B8%8B%E5%8D%883.02.09.png" alt="截屏2022-07-11 下午3.02.09"></p>
<p>当我们需要保存检查点(checkpoint)时，就是在所有任务处理完同一条数据后，对状态做个快照保存下来。例如上图中，已经处理了 3 条数据：”hello” “world” “hello”，所以我们会看到 Source 算子的偏移量为 3；后面的 Sum 算子处理完第三条数据”hello”之后，此时已经有 2 个”hello”和 1 个”world”，所以对应的状态为”hello”-&gt; 2，”world”-&gt; 1(这里 KeyedState 底层会以 key-value 形式存储)。此时所有任务都已经处理完了前三个数据，所以我们可以把当前的状态保存成一个检查点，写入外部存储中。至于具体保存到哪里，这是由状态后端的配置项检查点存储(CheckpointStorage)来决定的，可以有作业管理器的堆内存(JobManagerCheckpointStorage)和文件系统(FileSystemCheckpointStorage)两种选择。一般情况下，我们会将检查点写入持久化的分布式文件系统。</p>
<h3 id="从检查点恢复状态"><a href="#从检查点恢复状态" class="headerlink" title="从检查点恢复状态"></a>从检查点恢复状态</h3><p>在运行流处理程序时，Flink 会周期性地保存检查点。当发生故障时，就需要找到最近一次成功保存的检查点来恢复状态。例如在上节的 word count 示例中，我们处理完三个数据后保存了一个检查点。之后继续运行，又正常处理了一个数据”flink”，在处理第五个数据”hello”时发生了故障，如图 10-3 所示。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-07-11%20%E4%B8%8B%E5%8D%883.09.55.png" alt="截屏2022-07-11 下午3.09.55"></p>
<p>这里 Source 任务已经处理完毕，所以偏移量为 5；Map 任务也处理完成了。而 Sum 任务在处理中发生了故障，此时状态并未保存。</p>
<p>接下来就需要从检查点来恢复状态了。具体的步骤为：</p>
<h4 id="重启应用"><a href="#重启应用" class="headerlink" title="重启应用"></a>重启应用</h4><p>遇到故障之后，第一步当然就是重启。我们将应用重新启动后，<strong>所有任务的状态会清空</strong>， 如图 10-4 所示。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-07-11%20%E4%B8%8B%E5%8D%883.12.40.png" alt="截屏2022-07-11 下午3.12.40"></p>
<h4 id="读取检查点，重置状态"><a href="#读取检查点，重置状态" class="headerlink" title="读取检查点，重置状态"></a>读取检查点，重置状态</h4><p>找到最近一次保存的检查点，从中读出每个算子任务状态的快照，分别填充到对应的状态中。这样，Flink 内部所有任务的状态，就恢复到了保存检查点的那一时刻，也就是刚好处理完第三个数据的时候，如图 10-5 所示。这里 key 为”flink”并没有数据到来，所以初始为 0。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-07-11%20%E4%B8%8B%E5%8D%883.32.10.png" alt="截屏2022-07-11 下午3.32.10"></p>
<h4 id="重放数据"><a href="#重放数据" class="headerlink" title="重放数据"></a>重放数据</h4><p>从检查点恢复状态后还有一个问题：如果直接继续处理数据，那么保存检查点之后、到发生故障这段时间内的数据，也就是第 4、5 个数据(“flink” “hello”)就相当于丢掉了；这会造成计算结果的错误。为了不丢数据，我们应该从保存检查点后开始重新读取数据，这可以通过 Source 任务**向外部数据源重新提交偏移量(offset)**来实现，如图 10-6 所示。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-07-11%20%E4%B8%8B%E5%8D%883.35.06.png" alt="截屏2022-07-11 下午3.35.06"></p>
<h4 id="继续处理数据"><a href="#继续处理数据" class="headerlink" title="继续处理数据"></a>继续处理数据</h4><p>接下来，我们就可以正常处理数据了。首先是重放第 4、5 个数据，然后继续读取后面的数据，如图 10-7 所示。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-07-11%20%E4%B8%8B%E5%8D%883.35.40.png" alt="截屏2022-07-11 下午3.35.40"></p>
<p>当处理到第 5 个数据时，就已经追上了发生故障时的系统状态。之后继续处理，就好像没有发生过故障一样；我们既没有丢掉数据也没有重复计算数据，这就保证了计算结果的正确性。 在分布式系统中，这叫作实现了”精确一次”(exactly-once)的状态一致性保证。</p>
<p>这里我们也可以发现，想要正确地从检查点中读取并恢复状态，必须知道**每个算子任务状态的类型和它们的先后顺序(拓扑结构)**；因此为了可以从之前的检查点中恢复状态，我们在改动程序、修复 bug 时要保证状态的拓扑顺序和类型不变。状态的拓扑结构在 JobManager 上可以由 JobGraph 分析得到，而检查点保存的定期触发也是由 JobManager 控制的；所以故障恢复的过程需要 JobManager 的参与。</p>
<h3 id="检查点算法"><a href="#检查点算法" class="headerlink" title="检查点算法"></a>检查点算法</h3><p>略</p>
<h3 id="检查点配置"><a href="#检查点配置" class="headerlink" title="检查点配置"></a>检查点配置</h3><h4 id="启用检查点"><a href="#启用检查点" class="headerlink" title="启用检查点"></a>启用检查点</h4><p>默认情况下，Flink 程序是禁用检查点的。如果想要为 Flink 应用开启自动保存快照的功能，需要在代码中显式地调用执行环境的.enableCheckpointing()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment(); </span><br><span class="line"><span class="comment">// 每隔1秒启动一次检查点保存 </span></span><br><span class="line">env.enableCheckpointing(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>这里需要传入一个长整型的<strong>毫秒数</strong>，表示周期性保存检查点的间隔时间。如果不传参数直接启用检查点，默认的间隔周期为 500 毫秒，这种方式已经被弃用。检查点的间隔时间是对处理性能和故障恢复速度的一个权衡。如果我们希望对性能的影响更小，可以调大间隔时间；而如果希望故障重启后迅速赶上实时的数据处理，就需要将间隔时间设小一些。</p>
<h4 id="检查点存储-Checkpoint-Storage"><a href="#检查点存储-Checkpoint-Storage" class="headerlink" title="检查点存储(Checkpoint Storage)"></a>检查点存储(Checkpoint Storage)</h4><p>检查点具体的持久化存储位置，取决于”检查点存储”(CheckpointStorage)的设置。默认情况下，检查点存储在 JobManager 的堆(heap)内存中。而对于大状态的持久化保存，Flink 也提供了在其他存储位置进行保存的接口，这就是 CheckpointStorage。具体可以通过调用检查点配置的.setCheckpointStorage()来配置，需要传入一个 CheckpointStorage 的实现类。Flink 主要提供了两种 CheckpointStorage：**作业管理器的堆内存(JobManagerCheckpointStorage)<strong>和</strong>文件系统(FileSystemCheckpointStorage)**。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置存储检查点到JobManager堆内存 </span></span><br><span class="line">env.getCheckpointConfig().setCheckpointStorage(<span class="keyword">new</span> JobManagerCheckpointStorage());</span><br><span class="line"><span class="comment">//配置存储检查点到文件系统 </span></span><br><span class="line">env.getCheckpointConfig().setCheckpointStorage(<span class="keyword">new</span> FileSystemCheckpointStorage(<span class="string">&quot;hdfs://namenode:40010/flink/checkpoints&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>对于实际生产应用，我们一般会将 CheckpointStorage 配置为高可用的分布式文件系统 (HDFS，S3 等)。</p>
<h4 id="其他高级配置"><a href="#其他高级配置" class="headerlink" title="其他高级配置"></a><strong>其他高级配置</strong></h4><p>检查点还有很多可以配置的选项，可以通过获取检查点配置(CheckpointConfig)来进行设置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CheckpointConfig checkpointConfig = env.getCheckpointConfig();</span><br></pre></td></tr></table></figure>

<p>我们这里做一个简单的列举说明：</p>
<h5 id="检查点模式-CheckpointingMode"><a href="#检查点模式-CheckpointingMode" class="headerlink" title="检查点模式(CheckpointingMode)"></a>检查点模式(CheckpointingMode)</h5><p>设置检查点一致性的保证级别，有”精确一次”(exactly-once)和”至少一次”(at-least-once)两个选项。默认级别为 exactly-once，而对于大多数低延迟的流处理程序，at-least-once 就够用了，而且处理效率会更高。</p>
<h5 id="超时时间-checkpointTimeout"><a href="#超时时间-checkpointTimeout" class="headerlink" title="超时时间(checkpointTimeout)"></a>超时时间(checkpointTimeout)</h5><p>用于指定检查点保存的超时时间，超时没完成就会被丢弃掉。传入一个长整型毫秒数作为参数，表示超时时间。</p>
<h5 id="最小间隔时间-minPauseBetweenCheckpoints"><a href="#最小间隔时间-minPauseBetweenCheckpoints" class="headerlink" title="最小间隔时间(minPauseBetweenCheckpoints)"></a>最小间隔时间(minPauseBetweenCheckpoints)</h5><p>用于指定在上一个检查点完成之后，检查点协调器(checkpoint coordinator)最快等多久可以出发保存下一个检查点的指令。这就意味着即使已经达到了周期触发的时间点，只要距离上一个检查点完成的间隔不够，就依然不能开启下一次检查点的保存。这就为正常处理数据留下了充足的间隙。当指定这个参数时，maxConcurrentCheckpoints 的值强制为 1。</p>
<h5 id="最大并发检查点数量-maxConcurrentCheckpoints"><a href="#最大并发检查点数量-maxConcurrentCheckpoints" class="headerlink" title="最大并发检查点数量(maxConcurrentCheckpoints)"></a>最大并发检查点数量(maxConcurrentCheckpoints)</h5><p>用于指定运行中的检查点最多可以有多少个。由于每个任务的处理进度不同，完全可能出现后面的任务还没完成前一个检查点的保存、前面任务已经开始保存下一个检查点了。这个参数就是限制同时进行的最大数量。如果前面设置了 minPauseBetweenCheckpoints，则 maxConcurrentCheckpoints 这个参数就不起作用了。</p>
<h5 id="开启外部持久化存储-enableExternalizedCheckpoints"><a href="#开启外部持久化存储-enableExternalizedCheckpoints" class="headerlink" title="开启外部持久化存储(enableExternalizedCheckpoints)"></a>开启外部持久化存储(enableExternalizedCheckpoints)</h5><p>用于开启检查点的外部持久化，而且默认在作业失败的时候不会自动清理，如果想释放空间需要自己手工清理。里面传入的参数ExternalizedCheckpointCleanup 指定了当作业取消的时候外部的检查点该如何清理。</p>
<p>DELETE_ON_CANCELLATION：在作业取消的时候会自动删除外部检查点，但是如果是作业失败退出，则会保留检查点。</p>
<p>RETAIN_ON_CANCELLATION：作业取消的时候也会保留外部检查点。 </p>
<p><strong>检查点异常时是否让整个任务失败(failOnCheckpointingErrors)</strong></p>
<p>用于指定在检查点发生异常的时候，是否应该让任务直接失败退出。默认为 true，如果设置为 false，则任务会丢弃掉检查点然后继续运行。 </p>
<p><strong>不对齐检查点(enableUnalignedCheckpoints)</strong></p>
<p>不再执行检查点的分界线对齐操作，启用之后可以大大减少产生背压时的检查点保存时间。这个设置要求检查点模式(CheckpointingMode)必须为 exctly-once，并且并发的检查点个数为 1。</p>
<p>代码中具体设置如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"><span class="comment">//启用检查点，间隔时间1秒</span></span><br><span class="line">env.enableCheckpointing(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">CheckpointConfig checkpointConfig = env.getCheckpointConfig();</span><br><span class="line"><span class="comment">//设置精确一次模式</span></span><br><span class="line">checkpointConfig.setCheckpointingMode(CheckpointingMode.EXACTLY_ONCE); </span><br><span class="line"><span class="comment">//最小间隔时间500毫秒</span></span><br><span class="line">checkpointConfig.setMinPauseBetweenCheckpoints(<span class="number">500</span>);</span><br><span class="line"><span class="comment">//超时时间1分钟</span></span><br><span class="line">checkpointConfig.setCheckpointTimeout(<span class="number">60000</span>);</span><br><span class="line"><span class="comment">//同时只能有一个检查点</span></span><br><span class="line">checkpointConfig.setMaxConcurrentCheckpoints(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//开启检查点的外部持久化保存，作业取消后依然保留</span></span><br><span class="line">checkpointConfig.enableExternalizedCheckpoints(ExternalizedCheckpointCleanup.RETAIN_ON_CANCELLATION);</span><br><span class="line"><span class="comment">//启用不对齐的检查点保存方式</span></span><br><span class="line">checkpointConfig.enableUnalignedCheckpoints();</span><br><span class="line"><span class="comment">//设置检查点存储，可以直接传入一个String，指定文件系统的路径</span></span><br><span class="line">checkpointConfig.setCheckpointStorage(<span class="string">&quot;hdfs://my/checkpoint/dir&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="保存点-Savepoint"><a href="#保存点-Savepoint" class="headerlink" title="保存点(Savepoint)"></a>保存点(Savepoint)</h3><p>除了检查点(checkpoint)外，Flink 还提供了另一个非常独特的镜像保存功能——保存点 (Savepoint)。</p>
<p>从名称就可以看出，这也是一个存盘的备份，它的原理和算法与检查点完全相同，只是<strong>多了一些额外的元数据</strong>。事实上，保存点就是通过检查点的机制来创建流式作业状态的一致性镜像(consistent image)的。</p>
<p>保存点中的状态快照，是以算子 ID 和状态名称组织起来的，相当于一个键值对。从保存点启动应用程序时，Flink 会将保存点的状态数据重新分配给相应的算子任务。</p>
<h4 id="保存点的用途"><a href="#保存点的用途" class="headerlink" title="保存点的用途"></a>保存点的用途</h4><p>保存点与检查点最大的区别，就是<strong>触发的时机</strong>。检查点是由 Flink 自动管理的，定期创建， 发生故障之后自动读取进行恢复，这是一个”自动存盘”的功能；而<strong>保存点不会自动创建</strong>，必须由用户明确地<strong>手动触发</strong>保存操作，所以就是”手动存盘”。因此两者尽管原理一致，但用途就有所差别了：检查点主要用来做故障恢复，是容错机制的核心；保存点则更加灵活，可以用来做有计划的手动备份和恢复。</p>
<p>保存点可以当作一个强大的运维工具来使用。我们可以在需要的时候创建一个保存点，然后停止应用，做一些处理调整之后再从保存点重启。它适用的具体场景有：</p>
<p><strong>版本管理和归档存储</strong></p>
<p>对重要的节点进行手动备份，设置为某一版本，归档(archive)存储应用程序的状态。 </p>
<p><strong>更新Flink版本</strong></p>
<p>目前 Flink 的底层架构已经非常稳定，所以当 Flink 版本升级时，程序本身一般是兼容的。</p>
<p>这时不需要重新执行所有的计算，只要创建一个保存点，停掉应用、升级 Flink 后，从保存点重启就可以继续处理了。</p>
<p><strong>更新应用程序</strong></p>
<p>我们不仅可以在应用程序不变的时候，更新 Flink 版本；还可以直接更新应用程序。前提是程序必须是兼容的，也就是说更改之后的程序，状态的拓扑结构和数据类型都是不变的，这样才能正常从之前的保存点去加载。这个功能非常有用。我们可以及时修复应用程序中的逻辑 bug，更新之后接着继续处理；也可以用于有不同业务逻辑的场景，比如 A/B 测试等等。</p>
<p><strong>调整并行度</strong></p>
<p>如果应用运行的过程中，发现需要的资源不足或已经有了大量剩余，也可以通过从保存点重启的方式，将应用程序的并行度增大或减小。</p>
<p><strong>暂停应用程序</strong></p>
<p>有时候我们不需要调整集群或者更新程序，只是单纯地希望把应用暂停、释放一些资源来处理更重要的应用程序。使用保存点就可以灵活实现应用的暂停和重启，可以对有限的集群资源做最好的优化配置。 </p>
<p>需要注意的是，保存点能够在程序更改的时候依然兼容，前提是状态的拓扑结构和数据类型不变。我们知道保存点中状态都是以<strong>算子ID-状态名称</strong>这样的 key-value 组织起来的，算子ID可以在代码中直接调用 SingleOutputStreamOperator 的.uid() 方法来进行指定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;String&gt; stream = env</span><br><span class="line">  .addSource(<span class="keyword">new</span> StatefulSource())</span><br><span class="line">  .uid(<span class="string">&quot;source-id&quot;</span>)</span><br><span class="line">  .map(<span class="keyword">new</span> StatefulMapper())</span><br><span class="line">  .uid(<span class="string">&quot;mapper-id&quot;</span>)</span><br><span class="line">  .print();</span><br></pre></td></tr></table></figure>

<p>对于没有设置 ID 的算子，Flink 默认会自动进行设置，所以在重新启动应用后可能会导致 ID 不同而无法兼容以前的状态。所以为了方便后续的维护，强烈建议在程序中为每一个算子手动指定 ID。</p>
<h4 id="使用保存点"><a href="#使用保存点" class="headerlink" title="使用保存点"></a>使用保存点</h4><p>保存点的使用非常简单，我们可以使用命令行工具来创建保存点，也可以从保存点恢复作业。</p>
<p><strong>创建保存点</strong></p>
<p>要在命令行中为运行的作业创建一个保存点镜像，只需要执行:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/flink savepoint :jobId [:targetDirectory]</span><br></pre></td></tr></table></figure>

<p>这里 jobId 需要填充要做镜像保存的作业 ID，目标路径 targetDirectory 可选，表示保存点存储的路径。</p>
<p>对于保存点的默认路径，可以通过配置文件 flink-conf.yaml 中的 state.savepoints.dir 项来设定：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state.savepoints.dir: hdfs:///flink/savepoints</span><br></pre></td></tr></table></figure>

<p>当然对于单独的作业，我们也可以在程序代码中通过执行环境来设置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env.setDefaultSavepointDir(<span class="string">&quot;hdfs:///flink/savepoints&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>由于创建保存点一般都是希望更改环境之后重启，所以创建之后往往紧接着就是停掉作业的操作。除了对运行的作业创建保存点，我们也可以在停掉一个作业时直接创建保存点：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/flink stop --savepointPath [:targetDirectory] :jobId</span><br></pre></td></tr></table></figure>

<p><strong>从保存点重启应用</strong><br> 我们已经知道，提交启动一个Flink作业，使用的命令是flink run；现在要从保存点重启一个应用，其实本质是一样的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/flink run -s :savepointPath [:runArgs]</span><br></pre></td></tr></table></figure>

<p>这里只要增加一个-s 参数，指定保存点的路径就可以了，其他启动时的参数还是完全一样的。</p>
<h3 id="状态一致性"><a href="#状态一致性" class="headerlink" title="状态一致性"></a>状态一致性</h3><p>完整的流处理应用，应该包括了<strong>数据源</strong>、<strong>流处理器</strong>和<strong>外部存储系统</strong>三个部分。这个完整应用的一致性，就叫作端到端(end-to-end)的状态一致性，它取决于三个组件中最弱的那一环。一般来说，能否达到 at-least-once 一致性级别，主要看数据源能够重放数据；而能否达到 exactly-once 级别，流处理器内部、数据源、外部存储都要有相应的保证机制。</p>
<h4 id="输入端保障"><a href="#输入端保障" class="headerlink" title="输入端保障"></a>输入端保障</h4><p>输入端主要指的就是 Flink 读取的<strong>外部数据源</strong>。对于一些数据源来说，并不提供数据的缓冲或是持久化保存，数据被消费之后就彻底不存在了。例如 socket 文本流就是这样，socket 服务器是不负责存储数据的，发送一条数据之后，我们只能消费一次，是一锤子买卖。对于这样的数据源，故障后我们即使通过检查点恢复之前的状态，可保存检查点之后到发生故障期间的数据已经不能重发了，这就会导致数据丢失。所以就只能保证 at-most-once 的一致性语 义，相当于没有保证。</p>
<p>想要在故障恢复后不丢数据，外部数据源就必须拥有重放数据的能力。常见的做法就是<strong>对数据进行持久化保存</strong>，并且可以<strong>重设数据的读取位置</strong>。一个最经典的应用就是 Kafka。在 Flink 的 Source 任务中将数据读取的偏移量保存为状态，这样就可以在故障恢复时从检查点中读取出来，对数据源重置偏移量，重新获取数据。</p>
<p>数据源可重放数据，或者说可重置读取数据偏移量，加上 Flink 的 Source 算子将偏移量作为状态保存进检查点，就可以保证数据不丢。这是达到 at-least-once 一致性语义的基本要求， 当然也是实现端到端 exactly-once 的基本要求。</p>
<h4 id="输出端保障"><a href="#输出端保障" class="headerlink" title="输出端保障"></a>输出端保障</h4><p>有了 Flink 的检查点机制，以及可重放数据的外部数据源，我们已经能做到 at-least-once 了。但是想要实现 exactly-once 却有更大的困难：数据有可能重复写入外部系统。因为检查点保存之后，继续到来的数据也会一一处理，任务的状态也会更新，最终通过 Sink 任务将计算结果输出到外部系统；只是状态改变还没有存到下一个检查点中。这时如果出现故障，这些数据都会重新来一遍，就计算了两次。我们知道对 Flink 内部状态来说，重复计算的动作是没有影响的，因为状态已经回滚，最终改变只会发生一次；但对于外部系统来说， 已经写入的结果就是泼出去的水，已经无法收回了，再次执行写入就会把同一个数据写入两次。所以这时，我们只保证了端到端的 at-least-once 语义。</p>
<p>为了实现端到端 exactly-once，我们还需要对外部存储系统、以及 Sink 连接器有额外的要求。能够保证 exactly-once 一致性的写入方式有两种：<strong>幂等写入</strong><br>和<strong>事务写入</strong>，我们需要外部存储系统对这两种写入方式的支持，而 Flink 也为提供了一些 Sink 连接器接口。</p>
<h5 id="幂等-idempotent-写入"><a href="#幂等-idempotent-写入" class="headerlink" title="幂等(idempotent)写入"></a><strong>幂等(idempotent)写入</strong></h5><p>所谓幂等操作，就是说一个操作可以重复执行很多次，但只导致一次结果更改。也就是说，后面再重复执行就不会对结果起作用了。</p>
<p>数学中一个典型的例子是，ex 的求导下操作，无论做多少次，得到的都是自身。而在数据处理领域，最典型的就是对 HashMap 的插入操作：如果是相同的键值对，后面的重复插入就都没什么作用了。</p>
<p>这相当于说，我们并没有真正解决数据重复计算、写入的问题；而是说，重复写入也没关系，结果不会改变。所以这种方式主要的限制在于外部存储系统必须支持这样的幂等写入：比如 Redis 中键值存储，或者关系型数据库(如 MySQL)中满足查询条件的更新操作。</p>
<p>需要注意，对于幂等写入，遇到故障进行恢复时，有可能会出现短暂的不一致。因为保存点完成之后到发生故障之间的数据，其实已经写入了一遍，回滚的时候并不能消除它们。如果有一个外部应用读取写入的数据，可能会看到奇怪的现象：短时间内，结果会突然跳回到之前的某个值，然后重播一段之前的数据。不过当数据的重放逐渐超过发生故障的点的时候，最终的结果还是一致的。</p>
<h5 id="事务-transactional-写入"><a href="#事务-transactional-写入" class="headerlink" title="事务(transactional)写入"></a>事务(transactional)写入</h5><p>如果说幂等写入对应用场景限制太多，那么事务写入可以说是更一般化的保证一致性的方式。我们都知道，事务(transaction)是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所做的所有更改都会被撤消。事务有四个基本特性：原子性(Atomicity)、 一致性(Correspondence)、隔离性(Isolation)和持久性(Durability)，这就是著名的 ACID。</p>
<p>在 Flink 流处理的结果写入外部系统时，如果能够构建一个事务，<strong>让写入操作可以随着检查点来提交和回滚</strong>，那么自然就可以解决重复写入的问题了。所以事务写入的基本思想就是：用一个事务来进行数据向外部系统的写入，这个事务是与检查点绑定在一起的。当 Sink 任务遇到 barrier 时，开始保存状态的同时就开启一个事务，接下来所有数据的写入都在这个事务中；待到当前检查点保存完毕时，将事务提交，所有写入的数据就真正可用了。如果中间过程出现故障，状态会回退到上一个检查点，而当前事务没有正常关闭(因为当前检查点没有保存完)，所以也会回滚，写入到外部的数据就被撤销了。</p>
<p>具体来说，又有两种实现方式：<strong>预写日志(WAL)<strong>和</strong>两阶段提交(2PC)</strong> </p>
<p><strong>预写日志(write-ahead-log，WAL)</strong></p>
<p>我们发现，事务提交是需要外部存储系统支持事务的，否则没有办法真正实现写入的回撤。 那对于一般不支持事务的存储系统，能够实现事务写入呢？预写日志(WAL)就是一种非常简单的方式。具体步骤是：1、先把结果数据作为日志(log)状态保存起来 2、进行检查点保存时，也会将这些结果数据一并做持久化存储 3、在收到检查点完成的通知时，将所有结果一次性写入外部系统。 我们会发现，这种方式类似于检查点完成时做一个批处理，一次性的写入会带来一些性能上的问题；而优点就是比较简单，由于数据提前在状态后端中做了缓存，所以无论什么外部存储系统，理论上都能用这种方式一批搞定。在 Flink 中 DataStream API 提供了一个模板类 GenericWriteAheadSink，用来实现这种事务型的写入方式。</p>
<p>需要注意的是，预写日志这种一批写入的方式，有可能会写入失败；所以在执行写入动作之后，必须等待发送成功的返回确认消息。在成功写入所有数据后，在内部再次确认相应的检查点，这才代表着检查点的真正完成。这里需要将确认信息也进行持久化保存，在故障恢复时，只有存在对应的确认信息，才能保证这批数据已经写入，可以恢复到对应的检查点位置。 但这种”再次确认”的方式，也会有一些缺陷。如果我们的检查点已经成功保存、数据也成功地一批写入到了外部系统，但是最终保存确认信息时出现了故障，Flink 最终还是会认为没有成功写入。于是发生故障时，不会使用这个检查点，而是需要回退到上一个；这样就会导致这批数据的重复写入。</p>
<p><strong>两阶段提交(two-phase-commit，2PC)</strong></p>
<p>前面提到的各种实现 exactly-once 的方式，多少都有点缺陷，有没有更好的方法呢？自然是有的，这就是传说中的两阶段提交(2PC)。</p>
<p>顾名思义，它的想法是分成两个阶段：先做”预提交”，等检查点完成之后再正式提交。 这种提交方式是真正基于事务的，它需要外部系统提供事务支持。</p>
<p>具体的实现步骤为：1、当第一条数据到来时，或者收到检查点的分界线时，Sink 任务都会启动一个事务。 2、接下来接收到的所有数据，都通过这个事务写入外部系统；这时由于事务没有提交，所以数据尽管写入了外部系统，但是不可用，是”预提交”的状态。3、当 Sink 任务收到 JobManager 发来检查点完成的通知时，正式提交事务，写入的结果就真正可用了。 当中间发生故障时，当前未提交的事务就会回滚，于是所有写入外部系统的数据也就实现了撤回。这种两阶段提交(2PC)的方式充分利用了 Flink 现有的检查点机制：分界线的到来， 就标志着开始一个新事务；而收到来自 JobManager 的 checkpoint 成功的消息，就是提交事务的指令。每个结果数据的写入，依然是流式的，不再有预写日志时批处理的性能问题；最终提交时，也只需要额外发送一个确认信息。所以 2PC 协议不仅真正意义上实现了 exactly-once，而且通过搭载 Flink 的检查点机制来实现事务，只给系统增加了很少的开销。</p>
<p>Flink 提供了 TwoPhaseCommitSinkFunction 接口，方便我们自定义实现两阶段提交的 SinkFunction 的实现，提供了真正端到端的 exactly-once 保证。</p>
<p>不过两阶段提交虽然精巧，却对外部系统有很高的要求。这里将 2PC 对外部系统的要求列举如下:</p>
<p>1、外部系统必须提供事务支持，或者Sink任务必须能够模拟外部系统上的事务。</p>
<p>2、在检查点的间隔期间里，必须能够开启一个事务并接受数据写入。</p>
<p>3、在收到检查点完成的通知之前，事务必须是“等待提交”的状态。在故障恢复的情况下，这可能需要一些时间。如果这个时候外部系统关闭事务(例如超时了)，那么未提交的数据就会丢失。</p>
<p>4、Sink任务必须能够在进程失败后恢复事务。</p>
<p>5、提交事务必须是幂等操作。也就是说，事务的重复提交应该是无效的。</p>
<p>可见，2PC 在实际应用同样会受到比较大的限制。具体在项目中的选型，最终还应该是一致性级别和处理性能的权衡考量。</p>
<h4 id="Flink-和-Kafka-连接时的精确一次保证"><a href="#Flink-和-Kafka-连接时的精确一次保证" class="headerlink" title="Flink 和 Kafka 连接时的精确一次保证"></a>Flink 和 Kafka 连接时的精确一次保证</h4><p>在流处理的应用中，最佳的数据源当然就是可重置偏移量的消息队列了；它不仅可以提供<strong>数据重放</strong>的功能，而且天生就是以流的方式存储和处理数据的。所以作为大数据工具中消息队列的代表，Kafka 可以说与 Flink 是天作之合，实际项目中也经常会看到以 Kafka 作为<strong>数据源</strong>和<strong>写入的外部系统</strong>的应用。</p>
<h5 id="整体介绍"><a href="#整体介绍" class="headerlink" title="整体介绍"></a>整体介绍</h5><p>既然是端到端的 exactly-once，我们依然可以从三个组件的角度来进行分析：</p>
<p>(1)Flink 内部</p>
<p>Flink 内部可以通过<strong>检查点机制</strong>保证状态和处理结果的 exactly-once 语义。</p>
<p>(2)输入端</p>
<p>输入数据源端的 Kafka 可以对数据进行持久化保存，并可以**重置偏移量(offset)**。所以我们可以在 Source 任务(FlinkKafkaConsumer)中将当前读取的偏移量保存为算子状态，写入到检查点中；当发生故障时，从检查点中读取恢复状态，并由连接器 FlinkKafkaConsumer 向 Kafka 重新提交偏移量，就可以重新消费数据、保证结果的一致性了。</p>
<p>(3)输出端<br>输出端保证 exactly-once 的最佳实现，当然就是**两阶段提交(2PC)**。Flink 官方实现的 Kafka 连接器中，提供了写入到 Kafka 的 FlinkKafkaProducer，它就实现了 TwoPhaseCommitSinkFunction 接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlinkKafkaProducer</span>&lt;<span class="title">IN</span>&gt; <span class="keyword">extends</span> <span class="title">TwoPhaseCommitSinkFunction</span>&lt;<span class="title">IN</span>, <span class="title">FlinkKafkaProducer</span>.<span class="title">KafkaTransactionState</span>, <span class="title">FlinkKafkaProducer</span>.<span class="title">KafkaTransactionContext</span>&gt; </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，我们写入 Kafka 的过程实际上是一个两段式的提交：处理完毕得到结果，写入 Kafka 时是基于事务的”预提交”；等到检查点保存完毕，才会提交事务进行”正式提交”。如果中间出现故障，事务进行回滚，预提交就会被放弃；恢复状态之后，也只能恢复所有已经确认提交的操作。</p>
<h5 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h5><p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-07-11%20%E4%B8%8B%E5%8D%884.33.23.png" alt="截屏2022-07-11 下午4.33.23"></p>
<p>这是一个 Flink 与 Kafka 构建的完整数据管道，Source 任务从 Kafka 读取数据，经过一系列处理(比如窗口计算)，然后由 Sink 任务将结果再写入 Kafka。</p>
<p>Flink 与 Kafka 连接的两阶段提交，离不开检查点的配合，这个过程需要 JobManager 协调各个 TaskManager 进行状态快照，而检查点具体存储位置则是由状态后端(State Backend)来配置管理的。一般情况，我们会将检查点存储到分布式文件系统上。</p>
<p>实现端到端 exactly-once 的具体过程可以分解如下：</p>
<p><strong>(1)启动检查点保存</strong></p>
<p>检查点保存的启动，标志着我们进入了两阶段提交协议的”预提交”阶段。当然，现在还没有具体提交的数据。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-07-11%20%E4%B8%8B%E5%8D%884.35.15.png" alt="截屏2022-07-11 下午4.35.15"></p>
<p>如图 10-15 所示，JobManager 通知各个 TaskManager 启动检查点保存，Source 任务会将检查点分界线(barrier)注入数据流。这个 barrier 可以将数据流中的数据，分为进入当前检查点的集合和进入下一个检查点的集合。</p>
<p><strong>(2)算子任务对状态做快照</strong><br>分界线(barrier)会在算子间传递下去。每个算子收到 barrier 时，会将当前的状态做个快照，保存到状态后端。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-07-11%20%E4%B8%8B%E5%8D%884.36.20.png" alt="截屏2022-07-11 下午4.36.20"></p>
<p>如图 10-16 所示，Source 任务将 barrier 插入数据流后，也会将当前读取数据的偏移量作为状态写入检查点，存入状态后端；然后把 barrier 向下游传递，自己就可以继续读取数据了。接下来 barrier 传递到了内部的 Window 算子，它同样会对自己的状态进行快照保存，写入远程的持久化存储。</p>
<p><strong>(3)Sink 任务开启事务，进行预提交</strong></p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-07-11%20%E4%B8%8B%E5%8D%884.37.24.png" alt="截屏2022-07-11 下午4.37.24"></p>
<p>如图 10-17 所示，分界线(barrier)终于传到了 Sink 任务，这时 Sink 任务会开启一个事务。接下来到来的所有数据，Sink 任务都会通过这个事务来写入 Kafka。这里 barrier 是检查点的分界线，也是事务的分界线。由于之前的检查点可能尚未完成，因此上一个事务也可能尚未提交；此时 barrier 的到来开启了新的事务，上一个事务尽管可能没有被提交，但也不再接收新的数据了。</p>
<p>对于 Kafka 而言，提交的数据会被标记为未确认(uncommitted)。这个过程就是所谓的预提交(pre-commit)。</p>
<p><strong>(4)检查点保存完成，提交事务</strong></p>
<p>当所有算子的快照都完成，也就是这次的检查点保存最终完成时，JobManager 会向所有任务发确认通知，告诉大家当前检查点已成功保存，如图 10-18 所示。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-07-11%20%E4%B8%8B%E5%8D%884.39.01.png" alt="截屏2022-07-11 下午4.39.01"></p>
<p>当 Sink 任务收到确认通知后，就会正式提交之前的事务，把之前未确认的数据标为已确认，接下来就可以正常消费了。</p>
<p>在任务运行中的任何阶段失败，都会从上一次的状态恢复，所有没有正式提交的数据也会回滚。这样，Flink 和 Kafka 连接构成的流处理系统，就实现了端到端的 exactly-once 状态一致性。</p>
<h5 id="需要的配置"><a href="#需要的配置" class="headerlink" title="需要的配置"></a>需要的配置</h5><p>在具体应用中，实现真正的端到端 exactly-once，还需要有一些额外的配置：</p>
<p>(1)必须启用检查点</p>
<p>(2)在 FlinkKafkaProducer 的构造函数中传入参数 Semantic.EXACTLY_ONCE</p>
<p>(3)配置 Kafka 读取数据的消费者的隔离级别</p>
<p>这里所说的 Kafka，是写入的外部系统。预提交阶段数据已经写入，只是被标记为未提交(uncommitted)，而 Kafka 中默认的隔离级别 isolation.level 是 read_uncommitted，也就是可以读取未提交的数据。这样一来，外部应用就可以直接消费未提交的数据，对于事务性的保证就失效了。所以应该将隔离级别配置为 read_committed，表示消费者遇到未提交的消息时，会停止从分区中消费数据，直到消息被标记为已提交才会再次恢复消费。当然，这样做的话，外部应用消费数据就会有显著的延迟。</p>
<p>(4)事务超时配置</p>
<p>Flink 的 Kafka 连接器中配置的事务超时时间 transaction.timeout.ms 默认是 1 小时，而 Kafka集群配置的事务最大超时时间 transaction.max.timeout.ms 默认是 15 分钟。所以在检查点保存时间很长时，有可能出现 Kafka 已经认为事务超时了，丢弃了预提交的数据；而 Sink 任务认为还可以继续等待。如果接下来检查点保存成功，发生故障后回滚到这个检查点的状态，这部分数据就被真正丢掉了。所以这两个超时时间，前者应该小于等于后者。</p>
<h2 id="TableAPI和SQL"><a href="#TableAPI和SQL" class="headerlink" title="TableAPI和SQL"></a>TableAPI和SQL</h2><p>在 Flink 中这两种 API 被集成在一起，SQL 执行的对象也是 Flink 中的表(Table)，所以我们一般会认为它们是一体的。Flink 是批流统一的处理框架，无论是批处理(DataSet API)还是流处理(DataStream API)，在上层应用中都可以直接使用 Table API 或者 SQL 来实现；这两种 API 对于一张表执行相同的查询操作，得到的结果是完全一样的。</p>
<p>如果我们对关系型数据库和 SQL 非常熟悉，那么 Table API 和 SQL 的使用其实非常简单：只要得到一个表(Table)，然后对它调用 Table API，或者直接写 SQL 就可以了。接下来我们就以一个非常简单的例子上手，初步了解一下这种高层级 API 的使用方法。</p>
<p>我们想要在代码中使用 Table API，必须引入相关的依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-table-api-java-bridge_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里的依赖是一个 Java 的桥接器(bridge)，主要就是负责 Table API 和下层 DataStream API 的连接支持，按照不同的语言分为 Java 版和 Scala 版。</p>
<p>如果我们希望在本地的集成开发环境(IDE)里运行Table API和SQL，还需要引入以下依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-table-planner-blink_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-streaming-scala_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里主要添加的依赖是一个”计划器”(planner)，它是 Table API 的核心组件，负责提供运行时环境，并生成程序的执行计划。这里我们用到的是新版的blink planner。由于Flink安装包的 lib 目录下会自带 planner，所以在生产集群环境中提交的作业不需要打包这个依赖。而在 Table API 的内部实现上，部分相关的代码是用 Scala 实现的，所以还需要额外添加一个 Scala 版流处理的相关依赖。</p>
<p>另外，如果想实现自定义的数据格式来做序列化，可以引入下面的依赖:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-table-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h3><p>有了基本的依赖，接下来我们就可以尝试在 Flink 代码中使用 Table API 和 SQL 了。比如， 我们可以自定义一些 Event 类型(包含了 user、url 和 timestamp 三个字段，作为输入的数据源；而后从中提取 url 地址和用户名 user 两个字段作为输出。</p>
<p>如果使用 DataStream API，我们可以直接读取数据源后，用一个简单转换算子 map 来做字段的提取。而这个需求直接写 SQL 的话，实现会更加简单：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> url, <span class="keyword">user</span> <span class="keyword">from</span> EventTable;</span><br></pre></td></tr></table></figure>

<p>这里我们把流中所有数据组成的表叫作 EventTable。在 Flink 代码中直接对这个表执行上面的 SQL，就可以得到想要提取的数据了。</p>
<p>在代码中具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TableExample</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">//获取流执行环境</span></span><br><span class="line">		StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">		env.setParallelism(<span class="number">1</span>);</span><br><span class="line">		<span class="comment">//读取数据源</span></span><br><span class="line">		SingleOutputStreamOperator&lt;Event&gt; eventStream = env.fromElements(</span><br><span class="line">                    <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">										<span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./cart&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">										<span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod?id=1&quot;</span>, <span class="number">5</span> * <span class="number">1000L</span>),</span><br><span class="line">										<span class="keyword">new</span> Event(<span class="string">&quot;Cary&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">60</span> * <span class="number">1000L</span>),</span><br><span class="line">										<span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./prod?id=3&quot;</span>, <span class="number">90</span> * <span class="number">1000L</span>),</span><br><span class="line">										<span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod?id=7&quot;</span>, <span class="number">105</span> * <span class="number">1000L</span>)</span><br><span class="line">		);</span><br><span class="line">		<span class="comment">//获取表环境</span></span><br><span class="line">		StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env);</span><br><span class="line">		<span class="comment">//将数据流转换成表</span></span><br><span class="line">		Table eventTable = tableEnv.fromDataStream(eventStream);</span><br><span class="line">		<span class="comment">//用执行SQL的方式提取数据</span></span><br><span class="line">		Table visitTable = tableEnv.sqlQuery(<span class="string">&quot;select url, user from &quot;</span> + eventTable);</span><br><span class="line">		<span class="comment">//将表转换成数据流，打印输出</span></span><br><span class="line">    tableEnv.toDataStream(visitTable).print();</span><br><span class="line">		<span class="comment">//执行程序</span></span><br><span class="line">		env.execute();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们需要创建一个表环境(TableEnvironment)，然后将数据流(DataStream)转换成一个表(Table)；之后就可以执行 SQL 在这个表中查询数据了。查询得到的结果依然是一个表，把它重新转换成流就可以打印输出了。</p>
<p>代码执行的结果如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+<span class="selector-tag">I</span><span class="selector-attr">[./home, Alice]</span></span><br><span class="line">+<span class="selector-tag">I</span><span class="selector-attr">[./cart, Bob]</span></span><br><span class="line">+<span class="selector-tag">I</span><span class="selector-attr">[./prod?id=1, Alice]</span></span><br><span class="line">+<span class="selector-tag">I</span><span class="selector-attr">[./home, Cary]</span></span><br><span class="line">+<span class="selector-tag">I</span><span class="selector-attr">[./prod?id=3, Bob]</span></span><br><span class="line">+<span class="selector-tag">I</span><span class="selector-attr">[./prod?id=7, Alice]</span></span><br></pre></td></tr></table></figure>

<p>基于 Table 我们也可以调用一系列查询方法直接进行转换，这就是所谓 Table API 的处理方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用Table API方式提取数据</span></span><br><span class="line">Table clickTable2 = eventTable.select($(<span class="string">&quot;url&quot;</span>), $(<span class="string">&quot;user&quot;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="基本API"><a href="#基本API" class="headerlink" title="基本API"></a>基本API</h3><h4 id="程序架构"><a href="#程序架构" class="headerlink" title="程序架构"></a>程序架构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建表环境</span></span><br><span class="line">TableEnvironment tableEnv = ...;</span><br><span class="line"><span class="comment">//创建输入表，连接外部系统读取数据</span></span><br><span class="line">tableEnv.executeSql(<span class="string">&quot;CREATE TEMPORARY TABLE inputTable ... WITH ( &#x27;connector&#x27; = ... )&quot;</span>);</span><br><span class="line"><span class="comment">//注册一个表，连接到外部系统，用于输出</span></span><br><span class="line">tableEnv.executeSql(<span class="string">&quot;CREATE TEMPORARY TABLE outputTable ... WITH ( &#x27;connector&#x27; = ... )&quot;</span>);</span><br><span class="line"><span class="comment">//执行 SQL 对表进行查询转换，得到一个新的表</span></span><br><span class="line">Table table1 = tableEnv.sqlQuery(<span class="string">&quot;SELECT ... FROM inputTable... &quot;</span>);</span><br><span class="line"><span class="comment">//使用 Table API 对表进行查询转换，得到一个新的表</span></span><br><span class="line">Table table2 = tableEnv.from(<span class="string">&quot;inputTable&quot;</span>).select(...);</span><br><span class="line"><span class="comment">//将得到的结果写入输出表</span></span><br><span class="line">TableResult tableResult = table1.executeInsert(<span class="string">&quot;outputTable&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这里不是从一个 DataStream 转换成 Table，而是通过执行 DDL 来直接创建一个表。这里执行的 CREATE 语句中<strong>用 WITH 指定了外部系统的连接器</strong>，于是就可以连接外部系统读取数据了。这其实是更加一般化的程序架构，因为这样我们就可以完全抛开 DataStream API，直接用 SQL 语句实现全部的流处理过程。而后面对于输出表的定义是完全一样的。可以发现，<strong>在创建表的过程中，其实并不区分输入还是输出</strong>，只需要将这个表<strong>注册</strong>进来、连接到外部系统就可以了；这里的 inputTable、 outputTable 只是注册的表名，并不代表处理逻辑，可以随意更换。至于表的具体作用，则要等到执行后面的查询转换操作时才能明确。我们直接从 inputTable 中查询数据，那么 inputTable 就是输入表；而 outputTable 会接收另外表的结果进行写入，那么就是输出表。</p>
<h4 id="创建表环境"><a href="#创建表环境" class="headerlink" title="创建表环境"></a>创建表环境</h4><p>对于 Flink 这样的流处理框架来说，数据流和表在结构上还是有所区别的。所以使用 Table API 和 SQL 需要一个特别的运行时环境，这就是所谓的表环境(TableEnvironment)。它主要负责：</p>
<p>(1)注册 Catalog 和表</p>
<p>(2)执行 SQL 查询</p>
<p>(3)注册用户自定义函数(UDF)</p>
<p>(4)DataStream 和表之间的转换</p>
<p>这里的 Catalog 就是目录，与标准 SQL 中的概念是一致的，主要用来管理所有数据库(database)和表(table)的元数据(metadata)。通过 Catalog 可以方便地对数据库和表进行查询的管理，所以可以认为我们所定义的表都会挂靠在某个目录下，这样就可以快速检索。 在表环境中可以由用户自定义 Catalog，并在其中注册表和自定义函数(UDF)。默认的 Catalog 就叫作 default_catalog。</p>
<p>每个表和 SQL 的执行，都必须绑定在一个表环境(TableEnvironment)中。TableEnvironment 是Table API中提供的基本接口类，可以通过调用静态的create()方法来创建一个表环境实例。 方法需要传入一个环境的配置参数 EnvironmentSettings，它可以指定当前表环境的执行模式和计划器(planner)。执行模式有批处理和流处理两种选择，默认是流处理模式；计划器默认使用 blink planner。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.table.api.EnvironmentSettings;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.table.api.TableEnvironment;</span><br><span class="line"></span><br><span class="line">EnvironmentSettings settings = EnvironmentSettings</span><br><span class="line">  																		.newInstance()</span><br><span class="line">  																		.inStreamingMode() <span class="comment">// 使用流处理模式</span></span><br><span class="line">																			.build();</span><br><span class="line">TableEnvironment tableEnv = TableEnvironment.create(settings);</span><br></pre></td></tr></table></figure>

<p>对于流处理场景，其实默认配置就完全够用了。所以我们也可以用另一种更加简单的方式来创建表环境：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.table.api.EnvironmentSettings;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.table.api.bridge.java.StreamTableEnvironment;</span><br><span class="line"></span><br><span class="line">StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env);</span><br></pre></td></tr></table></figure>

<p>这里我们引入了一个**流式表环境(StreamTableEnvironment)**，它是继承自 TableEnvironment 的子接口。调用它的 create()方法，只需要直接将当前的流执行环境 (StreamExecutionEnvironment)传入，就可以创建出对应的流式表环境了。</p>
<h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><p>表(Table)是我们非常熟悉的一个概念，它是关系型数据库中数据存储的基本形式，也是 SQL 执行的基本对象。Flink 中的表概念也并不特殊，是由多个行数据构成的，每个行(Row) 又可以有定义好的多个列(Column)字段；整体来看，表就是固定类型的数据组成的二维矩阵。</p>
<p>为了方便地查询表，表环境中会维护一个目录(Catalog)和表的对应关系。所以表都是通过 Catalog 来进行注册创建的。表在环境中有一个唯一的 ID，由三部分组成：目录(catalog)名，数据库(database)名，以及表名。在默认情况下，目录名为 default_catalog，数据库名为 default_database。所以如果我们直接创建一个叫作 MyTable 的表，它的 ID 就是：</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span><span class="number">_</span>catalog.<span class="keyword">default</span><span class="number">_</span>database.MyTable</span><br></pre></td></tr></table></figure>

<p>具体创建表的方式，有通过**连接器(connector)<strong>和</strong>虚拟表(virtual tables)**两种。</p>
<h5 id="连接器表-Connector-Tables"><a href="#连接器表-Connector-Tables" class="headerlink" title="连接器表(Connector Tables)"></a>连接器表(Connector Tables)</h5><p>最直观的创建表的方式，就是通过连接器(connector)连接到一个外部系统，然后定义出对应的表结构。例如我们可以连接到 Kafka 或者文件系统，将存储在这些外部系统的数据以表的形式定义出来，这样对表的读写就可以通过连接器转换成对外部系统的读写了。当我们在表环境中读取这张表，连接器就会从外部系统读取数据并进行转换；而当我们向这张表写入数据，连接器就会将数据输出(Sink)到外部系统中。</p>
<p>在代码中，我们可以调用表环境的 executeSql()方法，可以传入一个 DDL 作为参数执行 SQL 操作。这里我们传入一个 CREATE 语句进行表的创建，并通过 WITH 关键字指定连接到外部系统的连接器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tableEnv.executeSql(<span class="string">&quot;CREATE [TEMPORARY] TABLE MyTable ... WITH ( &#x27;connector&#x27;= ... )&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这里的 TEMPORARY 关键字可以省略。这里没有定义 Catalog 和 Database，所以都是默认的，表的完整 ID 就是default_catalog.default_database.MyTable。如果希望使用自定义的目录名和库名，可以在环境中进行设置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tEnv.useCatalog(<span class="string">&quot;custom_catalog&quot;</span>);</span><br><span class="line">tEnv.useDatabase(<span class="string">&quot;custom_database&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这样我们创建的表完整 ID 就变成了 custom_catalog.custom_database.MyTable。之后在表环境中创建的所有表，ID 也会都以 custom_catalog.custom_database 作为前缀。</p>
<h5 id="虚拟表-Virtual-Tables"><a href="#虚拟表-Virtual-Tables" class="headerlink" title="虚拟表(Virtual Tables)"></a>虚拟表(Virtual Tables)</h5><p>在环境中注册之后，我们就可以在 SQL 中直接使用这张表进行查询转换了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Table newTable = tableEnv.sqlQuery(<span class="string">&quot;SELECT ... FROM MyTable... &quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这里调用了表环境的 sqlQuery()方法，直接传入一条 SQL 语句作为参数执行查询，得到的结果是一个 Table 对象。Table 是 Table API 中提供的核心接口类，就代表了一个 Java 中定义的表实例。得到的 newTable 是一个中间转换结果，如果之后又希望直接使用这个表执行 SQL，又该怎么做呢？</p>
<p>由于 newTable 是一个 Table 对象，并没有在表环境中注册；所以我们还需要将这个中间结果表注册到环境中，才能在 SQL 中使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tableEnv.createTemporaryView(<span class="string">&quot;NewTable&quot;</span>, newTable);</span><br></pre></td></tr></table></figure>

<p>我们发现，这里的注册其实是创建了一个虚拟表(Virtual Table)。这个概念与 SQL 语法中的视图(View)非常类似，所以调用的方法也叫作创建虚拟视图(createTemporaryView)。 视图之所以是虚拟的，是因为我们并不会直接保存这个表的内容，并没有实体；只是在用到这张表的时候，会将它对应的查询语句嵌入到 SQL 中。</p>
<p>注册为虚拟表之后，我们就又可以在 SQL 中直接使用 NewTable 进行查询转换了。不难看到，通过虚拟表可以非常方便地让 SQL 分步骤执行得到中间结果，这为代码编写提供了很大的便利。另外，虚拟表也可以让我们在 Table API 和 SQL 之间进行自由切换。一个 Java 中的 Table 对象可以直接调用 Table API 中定义好的查询转换方法，得到一个中间结果表；这跟对注册好的表直接执行 SQL 结果是一样的。</p>
<h4 id="表的查询"><a href="#表的查询" class="headerlink" title="表的查询"></a>表的查询</h4><p>创建好了表，接下来自然就是对表进行查询转换了。对一个表的查询(Query)操作，就对应着流数据的转换(Transform)处理。</p>
<p>Flink 为我们提供了两种查询方式：SQL 和 Table API。</p>
<h5 id="执行-SQL-进行查询"><a href="#执行-SQL-进行查询" class="headerlink" title="执行 SQL 进行查询"></a>执行 SQL 进行查询</h5><p>调用表环境的 sqlQuery()方法，传入一个字符串形式的 SQL 查询语句就可以了。执行得到的结果，是一个 Table 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建表环境</span></span><br><span class="line">TableEnvironment tableEnv = ...;</span><br><span class="line"><span class="comment">//创建表</span></span><br><span class="line">tableEnv.executeSql(<span class="string">&quot;CREATE TABLE EventTable ... WITH ( &#x27;connector&#x27; = ... )&quot;</span>);</span><br><span class="line"><span class="comment">//查询用户Alice的点击事件，并提取表中前两个字段 </span></span><br><span class="line">Table aliceVisitTable = tableEnv.sqlQuery(</span><br><span class="line">   <span class="string">&quot;SELECT user, url &quot;</span> +</span><br><span class="line">   <span class="string">&quot;FROM EventTable &quot;</span> +</span><br><span class="line">   <span class="string">&quot;WHERE user = &#x27;Alice&#x27; &quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>前 Flink 支持标准 SQL 中的绝大部分用法，并提供了丰富的计算函数。这样我们就可以把已有的技术迁移过来，像在 MySQL、Hive 中那样直接通过编写 SQL 实现自己的处理需求，从而大大降低了 Flink 上手的难度。</p>
<p>例如，我们也可以通过 GROUP BY 关键字定义分组聚合，调用 COUNT()、SUM()这样的函数来进行统计计算：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Table urlCountTable = tableEnv.sqlQuery(</span><br><span class="line">   <span class="string">&quot;SELECT user, COUNT(url) &quot;</span> +</span><br><span class="line">   <span class="string">&quot;FROM EventTable &quot;</span> +</span><br><span class="line">   <span class="string">&quot;GROUP BY user &quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面的例子得到的是一个新的 Table 对象，我们可以再次将它注册为虚拟表继续在 SQL 中调用。另外，我们也可以直接将查询的结果写入到已经注册的表中，这需要调用表环境的 executeSql() 方法来执行 DDL，传入的是一个 INSERT 语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册表</span></span><br><span class="line">tableEnv.executeSql(<span class="string">&quot;CREATE TABLE EventTable ... WITH ( &#x27;connector&#x27; = ... )&quot;</span>);</span><br><span class="line">tableEnv.executeSql(<span class="string">&quot;CREATE TABLE OutputTable ... WITH ( &#x27;connector&#x27; = ... )&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将查询结果输出到OutputTable中 </span></span><br><span class="line">tableEnv.executeSql (</span><br><span class="line"><span class="string">&quot;INSERT INTO OutputTable &quot;</span> +</span><br><span class="line">   <span class="string">&quot;SELECT user, url &quot;</span> +</span><br><span class="line">   <span class="string">&quot;FROM EventTable &quot;</span> +</span><br><span class="line">   <span class="string">&quot;WHERE user = &#x27;Alice&#x27; &quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h5 id="调用-Table-API-进行查询"><a href="#调用-Table-API-进行查询" class="headerlink" title="调用 Table API 进行查询"></a>调用 Table API 进行查询</h5><p>另外一种查询方式就是调用Table API。这是嵌入在Java和Scala语言内的查询API，核心就是 Table 接口类，通过一步步链式调用 Table 的方法，就可以定义出所有的查询转换操作。 每一步方法调用的返回结果，都是一个 Table。</p>
<p>由于 Table API 是基于 Table 的 Java 实例进行调用的，因此我们首先要得到表的 Java 对象。 基于环境中已注册的表，可以通过表环境的 from() 方法非常容易地得到一个 Table 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Table eventTable = tableEnv.from(<span class="string">&quot;EventTable&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>传入的参数就是注册好的表名。注意这里 <strong>eventTable 是一个 Table 对象</strong>，而 <strong>EventTable 是在环境中注册的表名</strong>。得到 Table 对象之后，就可以调用 API 进行各种转换操作了，得到的是一个新的 Table 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Table maryClickTable = eventTable</span><br><span class="line">       .where($(<span class="string">&quot;user&quot;</span>).isEqual(<span class="string">&quot;Alice&quot;</span>))</span><br><span class="line">       .select($(<span class="string">&quot;url&quot;</span>), $(<span class="string">&quot;user&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>这里每个方法的参数都是一个表达式(Expression)，用方法调用的形式直观地说明了想要表达的内容；$符号用来指定表中的一个字段。上面的代码和直接执行 SQL 是等效的。 Table API 是嵌入编程语言中的 DSL，SQL 中的很多特性和功能必须要有对应的实现才可以使用，因此跟直接写 SQL 比起来肯定就要麻烦一些。目前 Table API 支持的功能相对更少， 可以预见未来 Flink 社区也会以扩展 SQL 为主，为大家提供更加通用的接口方式。</p>
<h5 id="两种-API-的结合使用"><a href="#两种-API-的结合使用" class="headerlink" title="两种 API 的结合使用"></a>两种 API 的结合使用</h5><p>可以发现，无论是调用 Table API 还是执行 SQL，得到的结果都是一个 Table 对象；所以这两种 API 的查询可以很方便地结合在一起。</p>
<p>(1)无论是那种方式得到的 Table 对象，都可以继续调用 Table API 进行查询转换</p>
<p>(2)如果想要对一个表执行 SQL 操作(用 FROM 关键字引用)，必须先在环境中对它进行注册。所以我们可以通过创建虚拟表的方式实现两者的转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tableEnv.createTemporaryView(<span class="string">&quot;MyTable&quot;</span>, myTable);</span><br></pre></td></tr></table></figure>

<p>注意：这里的<strong>第一个参数MyTable是注册的表名</strong>，而<strong>第二个参数myTable是Java中的Table对象</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Table clickTable = tableEnvironment.sqlQuery(<span class="string">&quot;select url, user from &quot;</span> + eventTable);</span><br></pre></td></tr></table></figure>

<p>这其实是一种简略的写法，我们将 Table 对象名 eventTable 直接以字符串拼接的形式添加到 SQL 语句中，在解析时会自动注册一个同名的虚拟表到环境中，这样就省略了创建虚拟视图的步骤。</p>
<h4 id="输出表"><a href="#输出表" class="headerlink" title="输出表"></a>输出表</h4><p>表的创建和查询，就对应着流处理中的读取数据源(Source)和转换(Transform)；而最后一个步骤 Sink，也就是将结果数据输出到外部系统，就对应着表的输出操作。</p>
<p>在代码上，输出一张表最直接的方法，就是调用 Table 的方法 executeInsert() 方法将一个 Table 写入到注册过的表中，方法传入的参数就是注册的表名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册表，用于输出数据到外部系统</span></span><br><span class="line">tableEnv.executeSql(<span class="string">&quot;CREATE TABLE OutputTable ... WITH ( &#x27;connector&#x27; = ... )&quot;</span>);</span><br><span class="line"><span class="comment">//经过查询转换，得到结果表</span></span><br><span class="line">Table result = ...</span><br><span class="line"><span class="comment">//将结果表写入已注册的输出表中 </span></span><br><span class="line">result.executeInsert(<span class="string">&quot;OutputTable&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在底层，表的输出是通过将数据写入到 TableSink 来实现的。TableSink 是 Table API 中提供的一个向外部系统写入数据的通用接口，可以支持不同的文件格式(比如 CSV、Parquet)、 存储数据库(比如 JDBC、HBase、Elasticsearch)和消息队列(比如 Kafka)。它有些类似于 DataStream API 中调用 addSink()方法时传入的 SinkFunction，有不同的连接器对它进行了实现。 </p>
<p>这里可以发现，我们在环境中注册的表，其实在写入数据的时候就对应着一个 TableSink。</p>
<h4 id="表和流的转换"><a href="#表和流的转换" class="headerlink" title="表和流的转换"></a>表和流的转换</h4><p>创建表环境开始，历经表的创建、查询转换和输出，我们已经可以使用 Table API 和 SQL 进行完整的流处理了。不过在应用的开发过程中，我们测试业务逻辑一般不会将结果直接写入到外部系统，而是在本地控制台打印输出。对于 DataStream 这非常容易，直接调用 print() 方法就可以看到结果数据流的内容了；但对于 Table 就比较悲剧——它没有提供 print() 方法。 这该怎么办呢？</p>
<p>在 Flink 中我们可以将 Table 再转换成 DataStream，然后进行打印输出。这就涉及了表和流的转换。</p>
<h5 id="将表-Table-转换成流-DataStream"><a href="#将表-Table-转换成流-DataStream" class="headerlink" title="将表(Table)转换成流(DataStream)"></a>将表(Table)转换成流(DataStream)</h5><p><strong>(1)调用 toDataStream() 方法</strong></p>
<p>将一个 Table 对象转换成 DataStream 非常简单，只要直接调用表环境的方法 toDataStream() 就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Table aliceVisitTable = tableEnv.sqlQuery(</span><br><span class="line">	<span class="string">&quot;SELECT user, url &quot;</span> +</span><br><span class="line">	<span class="string">&quot;FROM EventTable &quot;</span> +</span><br><span class="line">	<span class="string">&quot;WHERE user = &#x27;Alice&#x27; &quot;</span></span><br><span class="line">  );</span><br><span class="line"><span class="comment">//将表转换成数据流</span></span><br><span class="line">tableEnv.toDataStream(aliceVisitTable).print();</span><br></pre></td></tr></table></figure>

<p><strong>(2)调用 toChangelogStream() 方法</strong></p>
<p>将 maryClickTable 转换成流打印输出是很简单的；然而，如果我们同样希望将用户点击次数统计表 urlCountTable 进行打印输出，就会抛出一个 TableException 异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> org.apache.flink.table.api.TableException: Table sink <span class="string">&#x27;default_catalog.default_database.Unregistered_DataStream_Sink_1&#x27;</span> doesn<span class="string">&#x27;t support consuming update changes ...</span></span><br></pre></td></tr></table></figure>

<p>这表示当前的 TableSink 并不支持表的更新(update)操作。这是什么意思呢？因为 print 本身也可以看作一个 Sink 操作，所以这个异常就是说打印输出的 Sink 操作不支持对数据进行更新。具体来说，urlCountTable 这个表中进行了<strong>分组聚合统计</strong>，所以表中的每一行是会<strong>更新</strong>的。也就是说，Alice的第一个点击事件到来，表中会有一行(Alice, 1)；第二个点击事件到来，这一行就要更新为(Alice, 2)。但之前的(Alice, 1)已经打印输出了，我们怎么能对它进行更改呢？所以就会抛出异常。</p>
<p>解决的思路是，对于这样有更新操作的表，我们不要试图直接把它转换成 DataStream 打印输出，而是记录一下它的更新日志(change log)。这样一来，对于表的所有更新操作， 就变成了一条更新日志的流，我们就可以转换成流打印输出了。</p>
<p>代码中需要调用的是表环境的 toChangelogStream()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Table urlCountTable = tableEnv.sqlQuery(</span><br><span class="line">   <span class="string">&quot;SELECT user, COUNT(url) &quot;</span> +</span><br><span class="line">   <span class="string">&quot;FROM EventTable &quot;</span> +</span><br><span class="line">   <span class="string">&quot;GROUP BY user &quot;</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//将表转换成更新日志流</span></span><br><span class="line">tableEnv.toChangelogStream(urlCountTable).print();</span><br></pre></td></tr></table></figure>

<p>与更新日志流(Changelog Streams)对应的，是那些只做了简单转换、没有进行聚合统计的表，例如前面提到的maryClickTable。它们的特点是数据只会插入、不会更新，所以也被叫作仅插入流(Insert-Only Streams)。</p>
<h5 id="将流-DataStream-转换成表-Table"><a href="#将流-DataStream-转换成表-Table" class="headerlink" title="将流(DataStream)转换成表(Table)"></a>将流(DataStream)转换成表(Table)</h5><p><strong>(1)调用 fromDataStream()方法</strong></p>
<p>想要将一个DataStream转换成表也很简单，可以通过调用表环境的fromDataStream()方法来实现，返回的就是一个Table对象。例如，我们可以直接将事件流 eventStream 转换成一个表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"><span class="comment">// 获取表环境</span></span><br><span class="line">StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env);</span><br><span class="line"><span class="comment">// 读取数据源</span></span><br><span class="line">SingleOutputStreamOperator&lt;Event&gt; eventStream = env.addSource(...)</span><br><span class="line"><span class="comment">// 将数据流转换成表</span></span><br><span class="line">Table eventTable = tableEnv.fromDataStream(eventStream);</span><br></pre></td></tr></table></figure>

<p>由于流中的数据本身就是定义好的 POJO 类型 Event，所以我们将流转换成表之后，每一行数据就对应着一个 Event，而表中的列名就对应着 Event 中的属性。另外，我们还可以在 fromDataStream() 方法中增加参数，用来指定提取哪些属性作为表中的字段名，并可以任意指定位置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提取 Event 中的 timestamp 和 url 作为表中的列</span></span><br><span class="line">Table eventTable2 = tableEnv.fromDataStream(eventStream, $(<span class="string">&quot;timestamp&quot;</span>), $(<span class="string">&quot;url&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>需要注意的是，timestamp 本身是 SQL 中的关键字，所以我们在定义表名、列名时要尽量避免。这时可以通过表达式的 <strong>as()</strong> 方法对字段进行重命名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 timestamp 字段重命名为 ts</span></span><br><span class="line">Table eventTable2 = tableEnv.fromDataStream(eventStream, $(<span class="string">&quot;timestamp&quot;</span>).as(<span class="string">&quot;ts&quot;</span>), $(<span class="string">&quot;url&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><strong>(2)调用 createTemporaryView()方法</strong></p>
<p>调用 fromDataStream() 方法简单直观，可以直接实现 DataStream 到 Table 的转换；不过如果我们希望直接在 SQL 中引用这张表，就还需要调用表环境的 createTemporaryView() 方法来创建虚拟视图了。</p>
<p>对于这种场景，也有一种更简洁的调用方式。我们可以直接调用 createTemporaryView() 方法创建虚拟表，传入的两个参数，第一个依然是注册的表名，而第二个可以直接就是 DataStream。之后仍旧可以传入多个参数，用来指定表中的字段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tableEnv.createTemporaryView(<span class="string">&quot;EventTable&quot;</span>, eventStream,$(<span class="string">&quot;timestamp&quot;</span>).as(<span class="string">&quot;ts&quot;</span>),$(<span class="string">&quot;url&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><strong>(3)调用 fromChangelogStream ()方法</strong></p>
<p>表环境还提供了一个方法 fromChangelogStream()，可以将一个更新日志流转换成表。这个方法要求流中的数据类型只能是 Row，而且每一个数据都需要指定当前行的更新类型 (RowKind)；所以一般是由连接器帮我们实现的，直接应用比较少见。</p>
<h5 id="支持的数据类型"><a href="#支持的数据类型" class="headerlink" title="支持的数据类型"></a>支持的数据类型</h5><p>整体来看，DataStream 中支持的数据类型，Table 中也是都支持的，只不过在进行转换时需要注意一些细节。</p>
<p><strong>(1)原子类型</strong></p>
<p>在 Flink 中，基础数据类型(Integer、Double、String)和通用数据类型(也就是不可再拆分的数据类型)统一称作原子类型。原子类型的 DataStream，转换之后就成了<strong>只有一列</strong>的 Table，列字段(field)的数据类型可以由原子类型推断出。另外，还可以在 fromDataStream() 方法里增加参数，用来重新命名列字段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StreamTableEnvironment tableEnv = ...;</span><br><span class="line">DataStream&lt;Long&gt; stream = ...;</span><br><span class="line"><span class="comment">// 将数据流转换成动态表，动态表只有一个字段，重命名为 myLong</span></span><br><span class="line">Table table = tableEnv.fromDataStream(stream, $(<span class="string">&quot;myLong&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><strong>(2)Tuple 类型</strong></p>
<p>当原子类型不做重命名时，默认的字段名就是f0，容易想到，这其实就是将原子类型看作了一元组 Tuple1 的处理结果。Table 支持 Flink 中定义的元组类型 Tuple，对应在表中字段名默认就是元组中元素的属性名 f0、f1、f2…。所有字段都可以被重新排序，也可以提取其中的一部分字段。字段还可以通过调用表达式的 as() 方法来进行重命名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">StreamTableEnvironment tableEnv = ...;</span><br><span class="line">DataStream&lt;Tuple2&lt;Long, Integer&gt;&gt; stream = ...;</span><br><span class="line"><span class="comment">// 将数据流转换成只包含 f1 字段的表</span></span><br><span class="line">Table table = tableEnv.fromDataStream(stream, $(<span class="string">&quot;f1&quot;</span>));</span><br><span class="line"><span class="comment">// 将数据流转换成包含 f0 和 f1 字段的表，在表中 f0 和 f1 位置交换</span></span><br><span class="line">Table table = tableEnv.fromDataStream(stream, $(<span class="string">&quot;f1&quot;</span>), $(<span class="string">&quot;f0&quot;</span>));</span><br><span class="line"><span class="comment">// 将 f1 字段命名为 myInt，f0 命名为 myLong</span></span><br><span class="line">Table table = tableEnv.fromDataStream(stream, $(<span class="string">&quot;f1&quot;</span>).as(<span class="string">&quot;myInt&quot;</span>), $(<span class="string">&quot;f0&quot;</span>).as(<span class="string">&quot;myLong&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><strong>(3)POJO 类型</strong></p>
<p>Flink 也支持多种数据类型组合成的复合类型，最典型的就是简单 Java 对象(POJO 类型)。由于 POJO 中已经定义好了可读性强的字段名，这种类型的数据流转换成 Table 就显得无比顺畅了。将 POJO 类型的 DataStream 转换成 Table，如果不指定字段名称，就会直接使用原始 POJO 类型中的字段名称。POJO 中的字段同样可以被重新排序、提却和重命名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StreamTableEnvironment tableEnv = ...;</span><br><span class="line">DataStream&lt;Event&gt; stream = ...;</span><br><span class="line">Table table = tableEnv.fromDataStream(stream);</span><br><span class="line">Table table = tableEnv.fromDataStream(stream,$(<span class="string">&quot;user&quot;</span>));</span><br><span class="line">Table table = tableEnv.fromDataStream(stream,$(<span class="string">&quot;user&quot;</span>).as(<span class="string">&quot;myUser&quot;</span>),$(<span class="string">&quot;url&quot;</span>).as(<span class="string">&quot;myUrl&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><strong>(4)Row 类型</strong></p>
<p>Flink 中还定义了一个在关系型表中更加通用的数据类型——行(Row)，它是 Table 中数据的基本组织形式。Row 类型也是一种复合类型，它的长度固定，而且无法直接推断出每个字段的类型，所以在使用时必须指明具体的类型信息；我们在创建 Table 时调用的 CREATE 语句就会将所有的字段名称和类型指定，这在 Flink 中被称为表的模式结构(Schema)。除此之外，Row 类型还附加了一个属性 RowKind，用来表示当前行在更新操作中的类型。这样， Row 就可以用来表示更新日志流(changelog stream)中的数据，从而架起了 Flink 中流和表的转换桥梁。所以在更新日志流中，元素的类型必须是 Row，而且需要调用 ofKind() 方法来指定更新类型。下面是一个具体的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;Row&gt; dataStream =</span><br><span class="line">   env.fromElements(</span><br><span class="line">       Row.ofKind(RowKind.INSERT, <span class="string">&quot;Alice&quot;</span>, <span class="number">12</span>),</span><br><span class="line">       Row.ofKind(RowKind.INSERT, <span class="string">&quot;Bob&quot;</span>, <span class="number">5</span>),</span><br><span class="line">Row.ofKind(RowKind.UPDATE_BEFORE, <span class="string">&quot;Alice&quot;</span>, <span class="number">12</span>),</span><br><span class="line">       Row.ofKind(RowKind.UPDATE_AFTER, <span class="string">&quot;Alice&quot;</span>, <span class="number">100</span>));</span><br><span class="line"><span class="comment">// 将更新日志流转换为表</span></span><br><span class="line">Table table = tableEnv.fromChangelogStream(dataStream);</span><br></pre></td></tr></table></figure>

<h5 id="综合应用示例"><a href="#综合应用示例" class="headerlink" title="综合应用示例"></a>综合应用示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 获取流环境</span></span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取数据源</span></span><br><span class="line">    SingleOutputStreamOperator&lt;Event&gt; eventStream = env</span><br><span class="line">            .fromElements(</span><br><span class="line">                    <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">                    <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./cart&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">                    <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod?id=1&quot;</span>, <span class="number">5</span> * <span class="number">1000L</span>),</span><br><span class="line">                    <span class="keyword">new</span> Event(<span class="string">&quot;Cary&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">60</span> * <span class="number">1000L</span>),</span><br><span class="line">                    <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./prod?id=3&quot;</span>, <span class="number">90</span> * <span class="number">1000L</span>),</span><br><span class="line">                    <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod?id=7&quot;</span>, <span class="number">105</span> * <span class="number">1000L</span>)</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取表环境</span></span><br><span class="line">    StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数据流转换成表</span></span><br><span class="line">    tableEnv.createTemporaryView(<span class="string">&quot;EventTable&quot;</span>, eventStream);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询Alice的访问url列表</span></span><br><span class="line">    Table aliceVisitTable = tableEnv.sqlQuery(<span class="string">&quot;SELECT url, user FROM EventTable WHERE user = &#x27;Alice&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计每个用户的点击次数</span></span><br><span class="line">    Table urlCountTable = tableEnv.sqlQuery(<span class="string">&quot;SELECT user, COUNT(url) FROM EventTable GROUP BY user&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将表转换成数据流，在控制台打印输出</span></span><br><span class="line">    tableEnv.toDataStream(aliceVisitTable).print(<span class="string">&quot;alice visit&quot;</span>);</span><br><span class="line">    tableEnv.toChangelogStream(urlCountTable).print(<span class="string">&quot;count&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行程序</span></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="流处理中的表"><a href="#流处理中的表" class="headerlink" title="流处理中的表"></a>流处理中的表</h3><p>当我们将一个 Table 转换成 DataStream 时，有仅插入流(Insert-Only Streams)和更新日志流(Changelog Streams) 两种不同的方式，具体使用哪种方式取决于表中是否存在更新(update)操作。</p>
<p>这种麻烦其实是不可避免的。我们知道，Table API 和 SQL 本质上都是基于关系型表的操作方式；而关系型表(Table)本身是有界的，更适合批处理的场景。所以在 MySQL、Hive 这样的固定数据集中进行查询，使用 SQL 就会显得得心应手。而对于 Flink 这样的流处理框架来说，要处理的是源源不断到来的无界数据流，我们无法等到数据都到齐再做查询，每来一条数据就应该更新一次结果；这时如果一定要使用表和 SQL 进行处理，就会显得有些别扭了，需要引入一些特殊的概念。</p>
<h4 id="动态表和持续查询"><a href="#动态表和持续查询" class="headerlink" title="动态表和持续查询"></a>动态表和持续查询</h4><p>流处理面对的数据是连续不断的，这导致了流处理中的表跟我们熟悉的关系型数据库中的表完全不同；而基于表执行的查询操作，也就有了新的含义。</p>
<p>如果我们希望把流数据转换成表的形式，那么这<strong>表中的数据就会不断增长</strong>；如果进一步基于表执行 SQL 查询，那么得到的结果就不是一成不变的，而是会随着新数据的到来持续更新。</p>
<p><strong>动态表(Dynamic Tables)</strong></p>
<p>当流中有新数据到来，初始的表中会插入一行；而基于这个表定义的 SQL 查询，就应该在之前的基础上更新结果。这样得到的表就会不断地动态变化，被称为动态表(Dynamic Tables)。动态表是 Flink 在 Table API 和 SQL 中的核心概念，它为流数据处理提供了表和 SQL 支持。 我们所熟悉的表一般用来做批处理，面向的是固定的数据集，可以认为是静态表；而动态表则完全不同，它里面的数据会随时间变化。</p>
<p>其实动态表的概念，我们在传统的关系型数据库中已经有所接触。数据库中的表，其实是一系列 INSERT、UPDATE 和 DELETE 语句执行的结果；在关系型数据库中，我们一般把它称为更新日志流(changelog stream)。如果我们保存了表在某一时刻的快照(snapshot)，那么接下来只要读取更新日志流，就可以得到表之后的变化过程和最终结果了。在很多高级关系型数据库(比如 Oracle、DB2)中都有物化视图(Materialized Views)的概念，可以用来缓存 SQL 查询的结果；它的更新其实就是不停地处理更新日志流的过程。</p>
<p><strong>持续查询(Continuous Query)</strong></p>
<p>动态表可以像静态的批处理表一样进行查询操作。由于数据在不断变化，因此基于它定义的 SQL 查询也不可能执行一次就得到最终结果。这样一来，我们对动态表的查询也就永远不会停止，一直在随着新数据的到来而继续执行。这样的查询就被称作持续查询(Continuous Query)。对动态表定义的查询操作，都是持续查询；而持续查询的结果也会是一个动态表。</p>
<p>由于每次数据到来都会触发查询操作，因此可以认为一次查询面对的数据集，就是当前输入动态表中收到的所有数据。这相当于是对输入动态表做了一个快照(snapshot)，当作有限数据集进行批处理；流式数据的到来会触发连续不断的快照查询，像动画一样连贯起来，就构成了持续查询。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-07-18%20%E4%B8%8B%E5%8D%885.10.28.png" alt="截屏2022-07-18 下午5.10.28"></p>
<p>持续查询的步骤如下：</p>
<p>(1)流(stream)被转换为动态表(dynamic table)；</p>
<p>(2)对动态表进行持续查询(continuous query)，生成新的动态表；</p>
<p>(3)生成的动态表被转换成流。</p>
<p>这样，只要 API 将流和动态表的转换封装起来，我们就可以直接在数据流上执行 SQL 查询，用处理表的方式来做流处理了。</p>
<h4 id="用-SQL-持续查询"><a href="#用-SQL-持续查询" class="headerlink" title="用 SQL 持续查询"></a>用 SQL 持续查询</h4><h5 id="更新-Update-查询"><a href="#更新-Update-查询" class="headerlink" title="更新(Update)查询"></a>更新(Update)查询</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分组聚合统计每个用户的点击次数</span></span><br><span class="line"><span class="comment">//结果表的更新日志(changelog) 流中，包含了 INSERT 和 UPDATE 两种操作</span></span><br><span class="line">Table urlCountTable = tableEnv.sqlQuery(<span class="string">&quot;SELECT user, COUNT(url) as cnt FROM EventTable GROUP BY user&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="追加-Append-查询"><a href="#追加-Append-查询" class="headerlink" title="追加(Append)查询"></a>追加(Append)查询</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结果表的更新日志 (changelog)流中只有 INSERT 操作</span></span><br><span class="line">Table aliceVisitTable = tableEnv.sqlQuery(<span class="string">&quot;SELECT url, user FROM EventTable WHERE user = &#x27;Cary&#x27;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>我们似乎可以总结一个规律：只要用到了聚合，在之前的结果上有叠加，就会产生更新操作，就是一个更新查询。但事实上，更新查询的判断标准是结果表中的数据是否会有 UPDATE 操作，如果聚合的结果不再改变，那么同样也不是更新查询。</p>
<p>什么时候聚合的结果会保持不变呢？一个典型的例子就是窗口聚合。</p>
<p>我们考虑开一个滚动窗口，统计每一小时内所有用户的点击次数，并在结果表中增加一个 endT 字段，表示当前统计窗口的结束时间。这时结果表的字段定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">user: VARCHAR, <span class="comment">// 用户名</span></span><br><span class="line">endT: TIMESTAMP, <span class="comment">// 窗口结束时间 </span></span><br><span class="line">cnt: BIGINT <span class="comment">// 用户访问 url 的次数</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-07-18%20%E4%B8%8B%E5%8D%888.23.04.png" alt="截屏2022-07-18 下午8.23.04"></p>
<p>由于窗口的统计结果是一次性写入结果表的，所以结果表的更新日志流中只会包含插入 INSERT 操作，而没有更新 UPDATE 操作。所以这里的持续查询，依然是一个追加(Append)查询。结果表 result 如果转换成 DataStream，可以直接调用 toDataStream()方 法。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+<span class="selector-tag">I</span><span class="selector-attr">[Alice, 1970-01-01T01:00, 3]</span></span><br><span class="line">+<span class="selector-tag">I</span><span class="selector-attr">[Bob, 1970-01-01T01:00, 1]</span></span><br><span class="line">+<span class="selector-tag">I</span><span class="selector-attr">[Cary, 1970-01-01T02:00, 2]</span></span><br><span class="line">+<span class="selector-tag">I</span><span class="selector-attr">[Bob, 1970-01-01T02:00, 1]</span></span><br></pre></td></tr></table></figure>

<h5 id="查询限制"><a href="#查询限制" class="headerlink" title="查询限制"></a>查询限制</h5><p>在实际应用中，有些持续查询会因为计算代价太高而受到限制。所谓的代价太高，可能是由于需要维护的状态持续增长，也可能是由于更新数据的计算太复杂。</p>
<p><strong>状态大小</strong></p>
<p>用持续查询做流处理，往往会运行至少几周到几个月；所以持续查询处理的数据总量可能非常大。例如我们之前举的更新查询的例子，需要记录每个用户访问 url 的次数。如果随着时间的推移用户数越来越大，那么要维护的状态也将逐渐增长，最终可能会耗尽存储空间导致查询失败。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">user</span>, <span class="built_in">COUNT</span>(url)</span><br><span class="line"><span class="keyword">FROM</span> clicks</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<p><strong>更新计算</strong></p>
<p>于有些查询来说，更新计算的复杂度可能很高。每来一条新的数据，更新结果的时候可能需要全部重新计算，并且对很多已经输出的行进行更新。一个典型的例子就是 RANK() 函数， 它会基于一组数据计算当前值的排名。例如下面的 SQL 查询，会根据用户最后一次点击的时间为每个用户计算一个排名。当我们收到一个新的数据，用户的最后一次点击时间(lastAction)就会更新，进而所有用户必须重新排序计算一个新的排名。当一个用户的排名发生改变时，被他超过的那些用户的排名也会改变；这样的更新操作无疑代价巨大，而且还会随着用户的增多越来越严重。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">user</span>, <span class="built_in">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> lastAction)</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="keyword">user</span>, <span class="built_in">MAX</span>(ts) <span class="keyword">AS</span> lastAction <span class="keyword">FROM</span> EventTable <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">user</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="时间属性和窗口"><a href="#时间属性和窗口" class="headerlink" title="时间属性和窗口"></a>时间属性和窗口</h4><p>基于时间的操作(比如时间窗口)，需要定义相关的时间语义和时间数据来源的信息。在 Table API 和 SQL 中，会给表单独提供一个逻辑上的时间字段，专门用来在表处理程序中指示时间。</p>
<p>所以所谓的时间属性(time attributes)，其实就是每个表模式结构(schema)的一部分。 它可以在创建表的 DDL 里直接定义为一个字段，也可以在 DataStream 转换成表时定义。一旦定义了时间属性，它就可以作为一个普通字段引用，并且可以在基于时间的操作中使用。</p>
<p>时间属性的数据类型为 TIMESTAMP，它的行为类似于常规时间戳，可以直接访问并且进行计算。</p>
<p>按照时间语义的不同，我们可以把时间属性的定义分成事件时间(event time)和处理时间(processing time)两种情况。</p>
<h5 id="事件时间"><a href="#事件时间" class="headerlink" title="事件时间"></a>事件时间</h5><p><strong>在创建表的 DDL 中定义</strong></p>
<p>在创建表的DDL(CREATE TABLE语句)中，可以增加一个字段，通过WATERMARK 语句来定义事件时间属性。WATERMARK 语句主要用来定义水位线(watermark)的生成表达式，这个表达式会将带有事件时间戳的字段标记为事件时间属性，并在它基础上给出水位线的延迟时间。具体定义方式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> EventTable(</span><br><span class="line">  <span class="keyword">user</span> STRING,</span><br><span class="line">  url STRING,</span><br><span class="line">  ts <span class="type">TIMESTAMP</span>(<span class="number">3</span>),</span><br><span class="line">  WATERMARK <span class="keyword">FOR</span> ts <span class="keyword">AS</span> ts <span class="operator">-</span> <span class="type">INTERVAL</span> <span class="string">&#x27;5&#x27;</span> <span class="keyword">SECOND</span></span><br><span class="line">) <span class="keyword">WITH</span> ( ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这里我们把 ts 字段定义为事件时间属性，而且基于 ts 设置了 5 秒的水位线延迟。这里的 5秒 是以时间间隔的形式定义的，格式是 INTERVAL &lt;数值&gt; &lt;时间单位&gt;：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">INTERVAL</span> <span class="string">&#x27;5&#x27;</span> <span class="keyword">SECOND</span></span><br></pre></td></tr></table></figure>

<p>这里的数值必须用<strong>单引号</strong>引起来，而单位用 SECOND 和 SECONDS 是等效的。</p>
<p>Flink 中支持的事件时间属性数据类型必须为 <strong>TIMESTAMP</strong> 或者 <strong>TIMESTAMP_LTZ</strong>。这里 TIMESTAMP_LTZ 是指带有本地时区信息的时间戳(TIMESTAMP WITH LOCAL TIME ZONE)；一般情况下如果数据中的时间戳是”年-月-日-时-分-秒”的形式，那就是不带时区信息的，可以将事件时间属性定义为 TIMESTAMP 类型。</p>
<p>而如果原始的时间戳就是一个长整型的毫秒数，这时就需要另外定义一个字段来表示事件时间属性，类型定义为 TIMESTAMP_LTZ 会更方便：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> events (</span><br><span class="line">  <span class="keyword">user</span> STRING,</span><br><span class="line">  url STRING,</span><br><span class="line">  ts <span class="type">BIGINT</span>,</span><br><span class="line">  ts_ltz <span class="keyword">AS</span> TO_TIMESTAMP_LTZ(ts, <span class="number">3</span>),</span><br><span class="line">  WATERMARK <span class="keyword">FOR</span> ts_ltz <span class="keyword">AS</span> time_ltz <span class="operator">-</span> <span class="type">INTERVAL</span> <span class="string">&#x27;5&#x27;</span> <span class="keyword">SECOND</span></span><br><span class="line">) <span class="keyword">WITH</span> (</span><br><span class="line">... );</span><br></pre></td></tr></table></figure>

<p>这里我们另外定义了一个字段 ts_ltz，是把长整型的 ts 转换为 TIMESTAMP_LTZ 得到的；进而使用 WATERMARK 语句将它设为事件时间属性，并设置 5 秒的水位线延迟。</p>
<p><strong>在数据流转换为表时定义</strong></p>
<p>事件时间属性也可以在将 DataStream 转换为表的时候来定义。我们调用 fromDataStream() 方法创建表时，可以追加参数来定义表中的字段结构；这时可以给某个字段加上 .rowtime() 后缀，就表示将当前字段指定为事件时间属性。这个字段可以是数据中本不存在、额外追加上去的逻辑字段，就像之前 DDL 中定义的第二种情况；也可以是本身固有的字段，那么这个字段就会被事件时间属性所覆盖，类型也会被转换为 TIMESTAMP。不论那种方式，时间属性字段中保存的都是事件的时间戳(TIMESTAMP类型)。</p>
<p>需要注意的是，这种方式只负责指定时间属性，而时间戳的提取和水位线的生成应该之前就在 DataStream 上定义好了。由于 DataStream 中没有时区概念，因此 Flink 会将事件时间属性解析成不带时区的 TIMESTAMP 类型，所有的时间值都被当作 UTC 标准时间。</p>
<p>在代码中的定义方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一:</span></span><br><span class="line"><span class="comment">// 流中数据类型为二元组 Tuple2，包含两个字段；需要自定义提取时间戳并生成水位线 </span></span><br><span class="line">DataStream&lt;Tuple2&lt;String, String&gt;&gt; stream = inputStream.assignTimestampsAndWatermarks(...);</span><br><span class="line"><span class="comment">// 声明一个额外的逻辑字段作为事件时间属性</span></span><br><span class="line">Table table = tEnv.fromDataStream(stream, $(<span class="string">&quot;user&quot;</span>), $(<span class="string">&quot;url&quot;</span>), $(<span class="string">&quot;ts&quot;</span>).rowtime());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二:</span></span><br><span class="line"><span class="comment">// 流中数据类型为三元组 Tuple3，最后一个字段就是事件时间戳 </span></span><br><span class="line">DataStream&lt;Tuple3&lt;String, String, Long&gt;&gt; stream = inputStream.assignTimestampsAndWatermarks(...);</span><br><span class="line"><span class="comment">// 不再声明额外字段，直接用最后一个字段作为事件时间属性</span></span><br><span class="line">Table table = tEnv.fromDataStream(stream, $(<span class="string">&quot;user&quot;</span>), $(<span class="string">&quot;url&quot;</span>), $(<span class="string">&quot;ts&quot;</span>).rowtime());</span><br></pre></td></tr></table></figure>

<h5 id="处理时间"><a href="#处理时间" class="headerlink" title="处理时间"></a>处理时间</h5><p>相比之下处理时间就比较简单了，它就是我们的系统时间，使用时不需要提取时间戳 (timestamp)和生成水位线(watermark)。因此在定义处理时间属性时，必须要额外声明一个字段，专门用来保存当前的处理时间。</p>
<p>类似地，处理时间属性的定义也有两种方式：创建表 DDL 中定义，或者在数据流转换成表时定义。</p>
<p><strong>在创建表的 DDL 中定义</strong></p>
<p>在创建表的 DDL(CREATE TABLE 语句)中，可以增加一个额外的字段，通过调用系统内置的 PROCTIME() 函数来指定当前的处理时间属性，返回的类型是 TIMESTAMP_LTZ。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> EventTable(</span><br><span class="line">  <span class="keyword">user</span> STRING,</span><br><span class="line">  url STRING,</span><br><span class="line">  ts <span class="keyword">AS</span> PROCTIME()</span><br><span class="line">) <span class="keyword">WITH</span> ( ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这里的时间属性，其实是以计算列(computed column)的形式定义出来的。所谓的计算列是Flink SQL中引入的特殊概念，可以用一个AS语句来在表中产生数据中不存在的列， 并且可以利用原有的列、各种运算符及内置函数。在前面事件时间属性的定义中，将 ts 字段转换成 TIMESTAMP_LTZ 类型的 ts_ltz，也是计算列的定义方式。</p>
<p><strong>在数据流转换为表时定义</strong></p>
<p>处理时间属性同样可以在将 DataStream 转换为表的时候来定义。我们调用 fromDataStream() 方法创建表时，可以用.proctime()后缀来指定处理时间属性字段。由于处理时间是系统时间，原始数据中并没有这个字段，所以处理时间属性一定不能定义在一个已有字段上，只能定义在表结构<strong>所有字段的最后</strong>，作为额外的逻辑字段出现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;Tuple2&lt;String, String&gt;&gt; stream = ...; </span><br><span class="line"><span class="comment">// 声明一个额外的字段作为处理时间属性字段</span></span><br><span class="line">Table table = tEnv.fromDataStream(stream, $(<span class="string">&quot;user&quot;</span>), $(<span class="string">&quot;url&quot;</span>), $(<span class="string">&quot;ts&quot;</span>).proctime());</span><br></pre></td></tr></table></figure>

<h5 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h5><p>窗口可以将无界流切割成大小有限的桶(bucket)来做计算，通过截取有限数据集来处理无限的流数据。在 DataStream API 中提供了对不同类型的窗口进行定义和处理的接口，而在 Table API 和 SQL 中，类似的功能也都可以实现。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/Flume/" rel="prev" title="Flume">
      <i class="fa fa-chevron-left"></i> Flume
    </a></div>
      <div class="post-nav-item">
    <a href="/Redis/" rel="next" title="Redis">
      Redis <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Flink%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">Flink概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%80%A7"><span class="nav-number">1.1.</span> <span class="nav-text">特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B1%82API"><span class="nav-number">1.2.</span> <span class="nav-text">分层API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%83%A8%E7%BD%B2%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.3.</span> <span class="nav-text">部署模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%9A%E8%AF%9D%E6%A8%A1%E5%BC%8F-Session-Mode"><span class="nav-number">1.3.1.</span> <span class="nav-text">会话模式(Session Mode)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E4%BD%9C%E4%B8%9A%E6%A8%A1%E5%BC%8F-Per-Job-Mode"><span class="nav-number">1.3.2.</span> <span class="nav-text">单作业模式(Per-Job Mode)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E6%A8%A1%E5%BC%8F-Application-Mode"><span class="nav-number">1.3.3.</span> <span class="nav-text">应用模式(Application Mode)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8B%AC%E7%AB%8B%E6%A8%A1%E5%BC%8F-Standalone"><span class="nav-number">1.4.</span> <span class="nav-text">独立模式(Standalone)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#YARN-%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.5.</span> <span class="nav-text">YARN 模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"><span class="nav-number">1.6.</span> <span class="nav-text">系统架构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86%E5%99%A8-JobManager"><span class="nav-number">1.6.1.</span> <span class="nav-text">作业管理器(JobManager)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#JobMaster"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">JobMaster</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ResourceManager"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">ResourceManager</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Dispatcher"><span class="nav-number">1.6.1.3.</span> <span class="nav-text">Dispatcher</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8-TaskManager"><span class="nav-number">1.6.2.</span> <span class="nav-text">任务管理器(TaskManager)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E4%B8%9A%E6%8F%90%E4%BA%A4%E6%B5%81%E7%A8%8B"><span class="nav-number">1.6.3.</span> <span class="nav-text">作业提交流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE-Dataflow-Graph"><span class="nav-number">1.6.4.</span> <span class="nav-text">数据流图(Dataflow Graph)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E5%BA%A6-Parallelism"><span class="nav-number">1.6.5.</span> <span class="nav-text">并行度(Parallelism)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E5%AD%90%E9%93%BE-Operator-Chain"><span class="nav-number">1.6.6.</span> <span class="nav-text">算子链(Operator Chain)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E5%AF%B9%E4%B8%80-one-to-one"><span class="nav-number">1.6.6.1.</span> <span class="nav-text">一对一(one-to-one)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E5%88%86%E5%8C%BA-Redistributing"><span class="nav-number">1.6.6.2.</span> <span class="nav-text">重分区(Redistributing)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E7%AE%97%E5%AD%90%E9%93%BE"><span class="nav-number">1.6.6.3.</span> <span class="nav-text">合并算子链</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E4%B8%9A%E5%9B%BE-JobGraph-%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%9B%BE-ExecutionGraph"><span class="nav-number">1.6.7.</span> <span class="nav-text">作业图(JobGraph)与执行图(ExecutionGraph)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1-Tasks-%E5%92%8C%E4%BB%BB%E5%8A%A1%E6%A7%BD-Task-Slots"><span class="nav-number">1.6.8.</span> <span class="nav-text">任务(Tasks)和任务槽(Task Slots)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Maven"><span class="nav-number">2.</span> <span class="nav-text">Maven</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WordCount"><span class="nav-number">3.</span> <span class="nav-text">WordCount</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#batch"><span class="nav-number">3.1.</span> <span class="nav-text">batch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bounded-stream"><span class="nav-number">3.2.</span> <span class="nav-text">bounded_stream</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unbounded-stream"><span class="nav-number">3.3.</span> <span class="nav-text">unbounded_stream</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Source"><span class="nav-number">4.</span> <span class="nav-text">Source</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#collection"><span class="nav-number">4.1.</span> <span class="nav-text">collection</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#file"><span class="nav-number">4.2.</span> <span class="nav-text">file</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#socket"><span class="nav-number">4.3.</span> <span class="nav-text">socket</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kafka"><span class="nav-number">4.4.</span> <span class="nav-text">kafka</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#custom-parallel"><span class="nav-number">4.5.</span> <span class="nav-text">custom_parallel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#custom-source"><span class="nav-number">4.6.</span> <span class="nav-text">custom_source</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Transform"><span class="nav-number">5.</span> <span class="nav-text">Transform</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#map"><span class="nav-number">5.1.</span> <span class="nav-text">map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#richFunction"><span class="nav-number">5.2.</span> <span class="nav-text">richFunction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#flatMap"><span class="nav-number">5.3.</span> <span class="nav-text">flatMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#filter"><span class="nav-number">5.4.</span> <span class="nav-text">filter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#connect"><span class="nav-number">5.5.</span> <span class="nav-text">connect</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#union"><span class="nav-number">5.6.</span> <span class="nav-text">union</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#max-maxBy"><span class="nav-number">5.7.</span> <span class="nav-text">max&#x2F;maxBy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reduce"><span class="nav-number">5.8.</span> <span class="nav-text">reduce</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#returnType"><span class="nav-number">5.9.</span> <span class="nav-text">returnType</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tupleAggreation"><span class="nav-number">5.10.</span> <span class="nav-text">tupleAggreation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#process"><span class="nav-number">5.11.</span> <span class="nav-text">process</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#physicalPartitioning"><span class="nav-number">5.12.</span> <span class="nav-text">physicalPartitioning</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PojoAggregation"><span class="nav-number">5.13.</span> <span class="nav-text">PojoAggregation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#udf"><span class="nav-number">5.14.</span> <span class="nav-text">udf</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sink"><span class="nav-number">6.</span> <span class="nav-text">Sink</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#kafka-1"><span class="nav-number">6.1.</span> <span class="nav-text">kafka</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis"><span class="nav-number">6.2.</span> <span class="nav-text">redis</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#elasticsearch"><span class="nav-number">6.3.</span> <span class="nav-text">elasticsearch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jdbc"><span class="nav-number">6.4.</span> <span class="nav-text">jdbc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#file-1"><span class="nav-number">6.5.</span> <span class="nav-text">file</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#custome-sink"><span class="nav-number">6.6.</span> <span class="nav-text">custome_sink</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Window"><span class="nav-number">7.</span> <span class="nav-text">Window</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E7%AA%97%E5%8F%A3-Time-Window"><span class="nav-number">7.1.</span> <span class="nav-text">时间窗口(Time Window)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TimeTumbling"><span class="nav-number">7.1.1.</span> <span class="nav-text">TimeTumbling</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TimeSliding"><span class="nav-number">7.1.2.</span> <span class="nav-text">TimeSliding</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TimeSession"><span class="nav-number">7.1.3.</span> <span class="nav-text">TimeSession</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E6%95%B0%E7%AA%97%E5%8F%A3-Count-Window"><span class="nav-number">7.2.</span> <span class="nav-text">计数窗口(Count Window)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CountTumbling"><span class="nav-number">7.2.1.</span> <span class="nav-text">CountTumbling</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CountSliding"><span class="nav-number">7.2.2.</span> <span class="nav-text">CountSliding</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E7%AA%97%E5%8F%A3-Global-Windows"><span class="nav-number">7.3.</span> <span class="nav-text">全局窗口(Global Windows)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0-Window-Functions"><span class="nav-number">7.4.</span> <span class="nav-text">窗口函数(Window Functions)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A2%9E%E9%87%8F%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0-incremental-aggregation-functions"><span class="nav-number">7.4.1.</span> <span class="nav-text">增量聚合函数(incremental aggregation functions)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A8%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0-full-window-functions"><span class="nav-number">7.4.2.</span> <span class="nav-text">全窗口函数(full window functions)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A2%9E%E9%87%8F%E8%81%9A%E5%90%88%E5%92%8C%E5%85%A8%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8"><span class="nav-number">7.4.3.</span> <span class="nav-text">增量聚合和全窗口函数的结合使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96API"><span class="nav-number">7.5.</span> <span class="nav-text">其他API</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8-Trigger"><span class="nav-number">7.5.1.</span> <span class="nav-text">触发器(Trigger)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A7%BB%E9%99%A4%E5%99%A8-Evictor"><span class="nav-number">7.5.2.</span> <span class="nav-text">移除器(Evictor)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%81%E8%AE%B8%E5%BB%B6%E8%BF%9F-Allowed-Lateness"><span class="nav-number">7.5.3.</span> <span class="nav-text">允许延迟(Allowed Lateness)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%A7%E8%BE%93%E5%87%BA%E6%B5%81"><span class="nav-number">7.5.4.</span> <span class="nav-text">侧输出流</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">7.6.</span> <span class="nav-text">窗口的生命周期</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WaterMark"><span class="nav-number">8.</span> <span class="nav-text">WaterMark</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#WatermarkTest"><span class="nav-number">8.1.</span> <span class="nav-text">WatermarkTest</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CustomWatermarkTest"><span class="nav-number">8.2.</span> <span class="nav-text">CustomWatermarkTest</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EmitWatermarkInSourceFunction"><span class="nav-number">8.3.</span> <span class="nav-text">EmitWatermarkInSourceFunction</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ProcessFunction-API"><span class="nav-number">9.</span> <span class="nav-text">ProcessFunction API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ProcessFunction"><span class="nav-number">9.1.</span> <span class="nav-text">ProcessFunction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KeyedProcessFunction"><span class="nav-number">9.2.</span> <span class="nav-text">KeyedProcessFunction</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8-Timer-%E5%92%8C%E5%AE%9A%E6%97%B6%E6%9C%8D%E5%8A%A1-TimerService"><span class="nav-number">9.2.1.</span> <span class="nav-text">定时器(Timer)和定时服务(TimerService)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ProcessWindowFunction"><span class="nav-number">9.3.</span> <span class="nav-text">ProcessWindowFunction</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#KeyedProcessTopN"><span class="nav-number">9.3.1.</span> <span class="nav-text">KeyedProcessTopN</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ProcessAllWindowFunction"><span class="nav-number">9.4.</span> <span class="nav-text">ProcessAllWindowFunction</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ProcessAllWindowTopN"><span class="nav-number">9.4.1.</span> <span class="nav-text">ProcessAllWindowTopN</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CoProcessFunction"><span class="nav-number">9.5.</span> <span class="nav-text">CoProcessFunction</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E6%97%B6%E5%AF%B9%E8%B4%A6"><span class="nav-number">9.5.1.</span> <span class="nav-text">实时对账</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ProcessJoinFunction"><span class="nav-number">9.6.</span> <span class="nav-text">ProcessJoinFunction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BroadcastProcessFunction"><span class="nav-number">9.7.</span> <span class="nav-text">BroadcastProcessFunction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KeyedBroadcastProcessFunction"><span class="nav-number">9.8.</span> <span class="nav-text">KeyedBroadcastProcessFunction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%A7%E8%BE%93%E5%87%BA%E6%B5%81-Side-Output"><span class="nav-number">9.9.</span> <span class="nav-text">侧输出流(Side Output)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%B5%81%E8%BD%AC%E6%8D%A2"><span class="nav-number">10.</span> <span class="nav-text">多流转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%B5%81"><span class="nav-number">10.1.</span> <span class="nav-text">分流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#filter%E5%AE%9E%E7%8E%B0"><span class="nav-number">10.1.1.</span> <span class="nav-text">filter实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%A7%E8%BE%93%E5%87%BA%E6%B5%81-1"><span class="nav-number">10.1.2.</span> <span class="nav-text">侧输出流</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%88%E6%B5%81"><span class="nav-number">10.2.</span> <span class="nav-text">合流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%81%94%E5%90%88-Union"><span class="nav-number">10.2.1.</span> <span class="nav-text">联合(Union)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5-Connect"><span class="nav-number">10.2.2.</span> <span class="nav-text">连接(Connect)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E6%B5%81%E8%81%94%E7%BB%93-Join"><span class="nav-number">10.2.3.</span> <span class="nav-text">双流联结(Join)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E8%81%94%E7%BB%93-Window-Join"><span class="nav-number">10.2.3.1.</span> <span class="nav-text">窗口联结(Window Join)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%97%B4%E9%9A%94%E8%81%94%E7%BB%93-Interval-Join"><span class="nav-number">10.2.3.2.</span> <span class="nav-text">间隔联结(Interval Join)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E5%90%8C%E7%BB%84%E8%81%94%E7%BB%93-Window-CoGroup"><span class="nav-number">10.2.3.3.</span> <span class="nav-text">窗口同组联结(Window CoGroup)</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#State"><span class="nav-number">11.</span> <span class="nav-text">State</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%89%E9%94%AE%E5%88%86%E5%8C%BA%E7%8A%B6%E6%80%81-Keyed-State"><span class="nav-number">11.1.</span> <span class="nav-text">按键分区状态(Keyed State)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%80%BC%E7%8A%B6%E6%80%81-ValueState"><span class="nav-number">11.1.1.</span> <span class="nav-text">值状态(ValueState)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E7%8A%B6%E6%80%81-ListState"><span class="nav-number">11.1.2.</span> <span class="nav-text">列表状态(ListState)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%A0%E5%B0%84%E7%8A%B6%E6%80%81-MapState"><span class="nav-number">11.1.3.</span> <span class="nav-text">映射状态(MapState)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%92%E7%BA%A6%E7%8A%B6%E6%80%81-ReducingState"><span class="nav-number">11.1.4.</span> <span class="nav-text">归约状态(ReducingState)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%81%9A%E5%90%88%E7%8A%B6%E6%80%81-AggregatingState"><span class="nav-number">11.1.5.</span> <span class="nav-text">聚合状态(AggregatingState)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E7%94%9F%E5%AD%98%E6%97%B6%E9%97%B4-TTL"><span class="nav-number">11.1.6.</span> <span class="nav-text">状态生存时间(TTL)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E5%AD%90%E7%8A%B6%E6%80%81-Operator-State"><span class="nav-number">11.2.</span> <span class="nav-text">算子状态(Operator State)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E7%8A%B6%E6%80%81-ListState-1"><span class="nav-number">11.2.1.</span> <span class="nav-text">列表状态(ListState)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%81%94%E5%90%88%E5%88%97%E8%A1%A8%E7%8A%B6%E6%80%81-UnionListState"><span class="nav-number">11.2.2.</span> <span class="nav-text">联合列表状态(UnionListState)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%BF%E6%92%AD%E7%8A%B6%E6%80%81-BroadcastState"><span class="nav-number">11.2.3.</span> <span class="nav-text">广播状态(BroadcastState)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E6%8C%81%E4%B9%85%E5%8C%96%E5%92%8C%E7%8A%B6%E6%80%81%E5%90%8E%E7%AB%AF"><span class="nav-number">11.3.</span> <span class="nav-text">状态持久化和状态后端</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E7%82%B9-Checkpoint"><span class="nav-number">11.3.1.</span> <span class="nav-text">检查点(Checkpoint)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E5%90%8E%E7%AB%AF-State-Backends"><span class="nav-number">11.3.2.</span> <span class="nav-text">状态后端(State Backends)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E5%90%8E%E7%AB%AF%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">11.3.2.1.</span> <span class="nav-text">状态后端的分类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E6%AD%A3%E7%A1%AE%E7%9A%84%E7%8A%B6%E6%80%81%E5%90%8E%E7%AB%AF"><span class="nav-number">11.3.2.2.</span> <span class="nav-text">如何选择正确的状态后端</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E5%90%8E%E7%AB%AF%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="nav-number">11.3.2.3.</span> <span class="nav-text">状态后端的配置</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E9%94%99%E6%9C%BA%E5%88%B6"><span class="nav-number">12.</span> <span class="nav-text">容错机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E7%82%B9%E7%9A%84%E4%BF%9D%E5%AD%98"><span class="nav-number">12.1.</span> <span class="nav-text">检查点的保存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%A8%E6%9C%9F%E6%80%A7%E7%9A%84%E8%A7%A6%E5%8F%91%E4%BF%9D%E5%AD%98"><span class="nav-number">12.1.1.</span> <span class="nav-text">周期性的触发保存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%9D%E5%AD%98%E7%9A%84%E6%97%B6%E9%97%B4%E7%82%B9"><span class="nav-number">12.1.2.</span> <span class="nav-text">保存的时间点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%9D%E5%AD%98%E7%9A%84%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="nav-number">12.1.3.</span> <span class="nav-text">保存的具体流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E6%A3%80%E6%9F%A5%E7%82%B9%E6%81%A2%E5%A4%8D%E7%8A%B6%E6%80%81"><span class="nav-number">12.2.</span> <span class="nav-text">从检查点恢复状态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%90%AF%E5%BA%94%E7%94%A8"><span class="nav-number">12.2.1.</span> <span class="nav-text">重启应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E6%A3%80%E6%9F%A5%E7%82%B9%EF%BC%8C%E9%87%8D%E7%BD%AE%E7%8A%B6%E6%80%81"><span class="nav-number">12.2.2.</span> <span class="nav-text">读取检查点，重置状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E6%94%BE%E6%95%B0%E6%8D%AE"><span class="nav-number">12.2.3.</span> <span class="nav-text">重放数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%A7%E7%BB%AD%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE"><span class="nav-number">12.2.4.</span> <span class="nav-text">继续处理数据</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E7%82%B9%E7%AE%97%E6%B3%95"><span class="nav-number">12.3.</span> <span class="nav-text">检查点算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E7%82%B9%E9%85%8D%E7%BD%AE"><span class="nav-number">12.4.</span> <span class="nav-text">检查点配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%AF%E7%94%A8%E6%A3%80%E6%9F%A5%E7%82%B9"><span class="nav-number">12.4.1.</span> <span class="nav-text">启用检查点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E7%82%B9%E5%AD%98%E5%82%A8-Checkpoint-Storage"><span class="nav-number">12.4.2.</span> <span class="nav-text">检查点存储(Checkpoint Storage)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE"><span class="nav-number">12.4.3.</span> <span class="nav-text">其他高级配置</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E7%82%B9%E6%A8%A1%E5%BC%8F-CheckpointingMode"><span class="nav-number">12.4.3.1.</span> <span class="nav-text">检查点模式(CheckpointingMode)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4-checkpointTimeout"><span class="nav-number">12.4.3.2.</span> <span class="nav-text">超时时间(checkpointTimeout)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E9%97%B4%E9%9A%94%E6%97%B6%E9%97%B4-minPauseBetweenCheckpoints"><span class="nav-number">12.4.3.3.</span> <span class="nav-text">最小间隔时间(minPauseBetweenCheckpoints)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%A3%80%E6%9F%A5%E7%82%B9%E6%95%B0%E9%87%8F-maxConcurrentCheckpoints"><span class="nav-number">12.4.3.4.</span> <span class="nav-text">最大并发检查点数量(maxConcurrentCheckpoints)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%80%E5%90%AF%E5%A4%96%E9%83%A8%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8-enableExternalizedCheckpoints"><span class="nav-number">12.4.3.5.</span> <span class="nav-text">开启外部持久化存储(enableExternalizedCheckpoints)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%9D%E5%AD%98%E7%82%B9-Savepoint"><span class="nav-number">12.5.</span> <span class="nav-text">保存点(Savepoint)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%9D%E5%AD%98%E7%82%B9%E7%9A%84%E7%94%A8%E9%80%94"><span class="nav-number">12.5.1.</span> <span class="nav-text">保存点的用途</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%BF%9D%E5%AD%98%E7%82%B9"><span class="nav-number">12.5.2.</span> <span class="nav-text">使用保存点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number">12.6.</span> <span class="nav-text">状态一致性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E7%AB%AF%E4%BF%9D%E9%9A%9C"><span class="nav-number">12.6.1.</span> <span class="nav-text">输入端保障</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E7%AB%AF%E4%BF%9D%E9%9A%9C"><span class="nav-number">12.6.2.</span> <span class="nav-text">输出端保障</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B9%82%E7%AD%89-idempotent-%E5%86%99%E5%85%A5"><span class="nav-number">12.6.2.1.</span> <span class="nav-text">幂等(idempotent)写入</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1-transactional-%E5%86%99%E5%85%A5"><span class="nav-number">12.6.2.2.</span> <span class="nav-text">事务(transactional)写入</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Flink-%E5%92%8C-Kafka-%E8%BF%9E%E6%8E%A5%E6%97%B6%E7%9A%84%E7%B2%BE%E7%A1%AE%E4%B8%80%E6%AC%A1%E4%BF%9D%E8%AF%81"><span class="nav-number">12.6.3.</span> <span class="nav-text">Flink 和 Kafka 连接时的精确一次保证</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B4%E4%BD%93%E4%BB%8B%E7%BB%8D"><span class="nav-number">12.6.3.1.</span> <span class="nav-text">整体介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4"><span class="nav-number">12.6.3.2.</span> <span class="nav-text">具体步骤</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9C%80%E8%A6%81%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="nav-number">12.6.3.3.</span> <span class="nav-text">需要的配置</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TableAPI%E5%92%8CSQL"><span class="nav-number">13.</span> <span class="nav-text">TableAPI和SQL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B"><span class="nav-number">13.1.</span> <span class="nav-text">简单实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%ACAPI"><span class="nav-number">13.2.</span> <span class="nav-text">基本API</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E6%9E%B6%E6%9E%84"><span class="nav-number">13.2.1.</span> <span class="nav-text">程序架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%A1%A8%E7%8E%AF%E5%A2%83"><span class="nav-number">13.2.2.</span> <span class="nav-text">创建表环境</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%A1%A8"><span class="nav-number">13.2.3.</span> <span class="nav-text">创建表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E5%99%A8%E8%A1%A8-Connector-Tables"><span class="nav-number">13.2.3.1.</span> <span class="nav-text">连接器表(Connector Tables)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E8%A1%A8-Virtual-Tables"><span class="nav-number">13.2.3.2.</span> <span class="nav-text">虚拟表(Virtual Tables)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%E7%9A%84%E6%9F%A5%E8%AF%A2"><span class="nav-number">13.2.4.</span> <span class="nav-text">表的查询</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C-SQL-%E8%BF%9B%E8%A1%8C%E6%9F%A5%E8%AF%A2"><span class="nav-number">13.2.4.1.</span> <span class="nav-text">执行 SQL 进行查询</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B0%83%E7%94%A8-Table-API-%E8%BF%9B%E8%A1%8C%E6%9F%A5%E8%AF%A2"><span class="nav-number">13.2.4.2.</span> <span class="nav-text">调用 Table API 进行查询</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8D-API-%E7%9A%84%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8"><span class="nav-number">13.2.4.3.</span> <span class="nav-text">两种 API 的结合使用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E8%A1%A8"><span class="nav-number">13.2.5.</span> <span class="nav-text">输出表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%E5%92%8C%E6%B5%81%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">13.2.6.</span> <span class="nav-text">表和流的转换</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%86%E8%A1%A8-Table-%E8%BD%AC%E6%8D%A2%E6%88%90%E6%B5%81-DataStream"><span class="nav-number">13.2.6.1.</span> <span class="nav-text">将表(Table)转换成流(DataStream)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%86%E6%B5%81-DataStream-%E8%BD%AC%E6%8D%A2%E6%88%90%E8%A1%A8-Table"><span class="nav-number">13.2.6.2.</span> <span class="nav-text">将流(DataStream)转换成表(Table)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%94%AF%E6%8C%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">13.2.6.3.</span> <span class="nav-text">支持的数据类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="nav-number">13.2.6.4.</span> <span class="nav-text">综合应用示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E5%A4%84%E7%90%86%E4%B8%AD%E7%9A%84%E8%A1%A8"><span class="nav-number">13.3.</span> <span class="nav-text">流处理中的表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A1%A8%E5%92%8C%E6%8C%81%E7%BB%AD%E6%9F%A5%E8%AF%A2"><span class="nav-number">13.3.1.</span> <span class="nav-text">动态表和持续查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8-SQL-%E6%8C%81%E7%BB%AD%E6%9F%A5%E8%AF%A2"><span class="nav-number">13.3.2.</span> <span class="nav-text">用 SQL 持续查询</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0-Update-%E6%9F%A5%E8%AF%A2"><span class="nav-number">13.3.2.1.</span> <span class="nav-text">更新(Update)查询</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%BD%E5%8A%A0-Append-%E6%9F%A5%E8%AF%A2"><span class="nav-number">13.3.2.2.</span> <span class="nav-text">追加(Append)查询</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E9%99%90%E5%88%B6"><span class="nav-number">13.3.2.3.</span> <span class="nav-text">查询限制</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%B1%9E%E6%80%A7%E5%92%8C%E7%AA%97%E5%8F%A3"><span class="nav-number">13.3.3.</span> <span class="nav-text">时间属性和窗口</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E6%97%B6%E9%97%B4"><span class="nav-number">13.3.3.1.</span> <span class="nav-text">事件时间</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E6%97%B6%E9%97%B4"><span class="nav-number">13.3.3.2.</span> <span class="nav-text">处理时间</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3"><span class="nav-number">13.3.3.3.</span> <span class="nav-text">窗口</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Vincent"
      src="/images/cute.jpeg">
  <p class="site-author-name" itemprop="name">Vincent</p>
  <div class="site-description" itemprop="description">nice</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Vincent</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
