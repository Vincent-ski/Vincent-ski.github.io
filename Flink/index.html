<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/cute.jpeg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/cute.jpeg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/cute.jpeg">
  <link rel="mask-icon" href="/images/cute.jpeg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Flink从入门到大神">
<meta property="og:type" content="article">
<meta property="og:title" content="Flink">
<meta property="og:url" content="http://example.com/Flink/index.html">
<meta property="og:site_name" content="Vincent&#39;s Learning Journey">
<meta property="og:description" content="Flink从入门到大神">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8A%E5%8D%8811.27.50.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8A%E5%8D%8811.41.01.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8A%E5%8D%8811.44.13.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8A%E5%8D%8811.51.54.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8B%E5%8D%881.45.50.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8B%E5%8D%882.20.24.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8B%E5%8D%882.26.46.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8B%E5%8D%882.28.07.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8B%E5%8D%882.41.21.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8B%E5%8D%884.36.32.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8B%E5%8D%885.01.43.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8B%E5%8D%885.28.05.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8B%E5%8D%889.46.48.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8B%E5%8D%8810.22.59.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8B%E5%8D%8810.35.04.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-03-23%20%E4%B8%8B%E5%8D%883.31.54.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-03-23%20%E4%B8%8B%E5%8D%888.50.24.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-03-25%20%E4%B8%8A%E5%8D%8812.08.27.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-03-25%20%E4%B8%8A%E5%8D%889.56.19.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-03-25%20%E4%B8%8A%E5%8D%8811.24.56.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-03-25%20%E4%B8%8B%E5%8D%883.47.50.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-03-25%20%E4%B8%8B%E5%8D%883.48.55.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-03-28%20%E4%B8%8B%E5%8D%883.40.58.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-07-11%20%E4%B8%8B%E5%8D%883.02.09.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-07-11%20%E4%B8%8B%E5%8D%883.09.55.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-07-11%20%E4%B8%8B%E5%8D%883.12.40.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-07-11%20%E4%B8%8B%E5%8D%883.32.10.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-07-11%20%E4%B8%8B%E5%8D%883.35.06.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-07-11%20%E4%B8%8B%E5%8D%883.35.40.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-07-11%20%E4%B8%8B%E5%8D%884.33.23.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-07-11%20%E4%B8%8B%E5%8D%884.35.15.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-07-11%20%E4%B8%8B%E5%8D%884.36.20.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-07-11%20%E4%B8%8B%E5%8D%884.37.24.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-07-11%20%E4%B8%8B%E5%8D%884.39.01.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-07-18%20%E4%B8%8B%E5%8D%885.10.28.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-07-18%20%E4%B8%8B%E5%8D%888.23.04.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-07-22%20%E4%B8%8B%E5%8D%885.44.19.png">
<meta property="og:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-07-26%20%E4%B8%8B%E5%8D%885.05.03.png">
<meta property="article:published_time" content="2021-12-17T10:35:47.000Z">
<meta property="article:modified_time" content="2023-03-07T14:53:10.923Z">
<meta property="article:author" content="Vincent">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8A%E5%8D%8811.27.50.png">

<link rel="canonical" href="http://example.com/Flink/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Flink | Vincent's Learning Journey</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Vincent's Learning Journey</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">DayDayUp</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section">Home</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section">Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section">Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger">Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/Flink/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/cute.jpeg">
      <meta itemprop="name" content="Vincent">
      <meta itemprop="description" content="nice">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Vincent's Learning Journey">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Flink
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-12-17 18:35:47" itemprop="dateCreated datePublished" datetime="2021-12-17T18:35:47+08:00">2021-12-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-07 22:53:10" itemprop="dateModified" datetime="2023-03-07T22:53:10+08:00">2023-03-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AE%9E%E6%97%B6%E8%AE%A1%E7%AE%97/" itemprop="url" rel="index"><span itemprop="name">实时计算</span></a>
                </span>
            </span>

          
            <div class="post-description">Flink从入门到大神</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="Flink概述"><a href="#Flink概述" class="headerlink" title="Flink概述"></a>Flink概述</h2><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>1、高吞吐和低延迟。每秒处理数百万个事件，毫秒级延迟。</p>
<p>2、结果的准确性。Flink 提供了事件时间(event-time)和处理时间(processing-time) 语义。对于乱序事件流，事件时间语义仍然能提供一致且准确的结果。</p>
<p>3、精确一次(exactly-once)的状态一致性保证。</p>
<p>4、可以连接到最常用的存储系统，如 Apache Kafka、Apache Cassandra、Elasticsearch、JDBC、Kinesis 和(分布式)文件系统，如 HDFS 和 S3。</p>
<p>5、高可用。本身高可用的设置，加上与K8s，YARN和Mesos的紧密集成，再加上从故障中快速恢复和动态扩展任务的能力，Flink 能做到以极少的停机时间 7×24 全天候运行。</p>
<p>6、能够更新应用程序代码并将作业(jobs)迁移到不同的 Flink 集群，而不会丢失应用程序的状态。</p>
<h3 id="分层API"><a href="#分层API" class="headerlink" title="分层API"></a>分层API</h3><p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8A%E5%8D%8811.27.50.png" alt="截屏2022-03-22 上午11.27.50"></p>
<h3 id="部署模式"><a href="#部署模式" class="headerlink" title="部署模式"></a>部署模式</h3><p>它们的区别主要在于：集群的生命周期以及资源的分配方式；以及应用的 main 方法到底在哪里执行——客户端(Client)还是 JobManager。</p>
<h4 id="会话模式-Session-Mode"><a href="#会话模式-Session-Mode" class="headerlink" title="会话模式(Session Mode)"></a>会话模式(Session Mode)</h4><p>集群启动时所有资源就都已经确定，所以所有提交的作业会竞争集群中的资源。会话模式比较适合于单个规模小、执行时间短的大量作业。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8A%E5%8D%8811.41.01.png" alt="截屏2022-03-22 上午11.41.01"></p>
<p>这样的好处很明显，我们只需要一个集群，就像一个大箱子，所有的作业提交之后都塞进去；集群的生命周期是超越于作业之上的，铁打的营盘流水的兵，作业结束了就释放资源，集群依然正常运行。当然缺点也是显而易见的：因为资源是共享的，所以资源不够了，提交新的作业就会失败。另外，同一个 TaskManager 上可能运行了很多作业，如果其中一个发生故障导致 TaskManager 宕机，那么所有作业都会受到影响。</p>
<h4 id="单作业模式-Per-Job-Mode"><a href="#单作业模式-Per-Job-Mode" class="headerlink" title="单作业模式(Per-Job Mode)"></a>单作业模式(Per-Job Mode)</h4><p>会话模式因为资源共享会导致很多问题，所以为了更好地隔离资源，我们可以考虑为每个提交的作业启动一个集群，这就是所谓的单作业(Per-Job)模式。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8A%E5%8D%8811.44.13.png" alt="截屏2022-03-22 上午11.44.13"></p>
<p>单作业模式也很好理解，就是严格的一对一，集群只为这个作业而生。同样由客户端运行应用程序，然后启动集群，作业被提交给 JobManager，进而分发给 TaskManager 执行。作业完成后，集群就会关闭，所有资源也会释放。这样一来，每个作业都有它自己的 JobManager 管理，占用独享的资源，即使发生故障，它的 TaskManager 宕机也不会影响其他作业。</p>
<p>这些特性使得单作业模式在生产环境运行更加稳定，所以是实际应用的首选模式。</p>
<p>需要注意的是，Flink 本身无法直接这样运行，所以单作业模式一般需要借助一些资源管理框架来启动集群，比如 YARN、Kubernetes。</p>
<h4 id="应用模式-Application-Mode"><a href="#应用模式-Application-Mode" class="headerlink" title="应用模式(Application Mode)"></a>应用模式(Application Mode)</h4><p>前面提到的两种模式下，应用代码都是在客户端上执行，然后由客户端提交给 JobManager 的。但是这种方式客户端需要占用大量网络带宽，去下载依赖和把二进制数据发送给 JobManager；加上很多情况下我们提交作业用的是同一个客户端，就会加重客户端所在节点的资源消耗。</p>
<p>所以解决办法就是，我们<strong>不要客户端</strong>了，直接把应用提交到 JobManger 上运行。而这也就代表着，我们需要为每一个提交的应用单独启动一个JobManager，也就是创建一个集群。这个 JobManager 只为执行这一个应用而存在，执行结束之后 JobManager 也就关闭了，这就是所谓的应用模式。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8A%E5%8D%8811.51.54.png" alt="截屏2022-03-22 上午11.51.54"></p>
<p>应用模式与单作业模式，都是提交作业之后才创建集群；单作业模式是通过客户端来提交的，客户端解析出的每一个作业对应一个集群；而应用模式下，是直接由 JobManager 执行应用程序的，并且即使应用包含了多个作业，也只创建一个集群。</p>
<p>总结一下，在会话模式下，集群的生命周期独立于集群上运行的任何作业的生命周期，并且提交的所有作业共享资源。而单作业模式为每个提交的作业创建一个集群，带来了更好的资源隔离，这时集群的生命周期与作业的生命周期绑定。最后，应用模式为每个应用程序创建一个会话集群，在 JobManager 上直接调用应用程序的 main() 方法。</p>
<h3 id="独立模式-Standalone"><a href="#独立模式-Standalone" class="headerlink" title="独立模式(Standalone)"></a>独立模式(Standalone)</h3><p>独立模式(Standalone)是部署 Flink 最基本也是最简单的方式：所需要的所有 Flink 组件，都只是操作系统上运行的一个 JVM 进程。</p>
<p>独立模式是独立运行的，不依赖任何外部的资源管理平台；当然独立也是有代价的：如果资源不足，或者出现故障，没有自动扩展或重分配资源的保证，必须手动处理。所以独立模式 一般只用在开发测试或作业非常少的场景下。</p>
<p>另外，我们也可以将独立模式的集群放在容器中运行。Flink 提供了独立模式的容器化部署方式，可以在 Docker 或者 Kubernetes 上进行部署。</p>
<h3 id="YARN-模式"><a href="#YARN-模式" class="headerlink" title="YARN 模式"></a>YARN 模式</h3><p>独立模式(Standalone)由 Flink 自身提供资源，无需其他框架，这种方式降低了和其他第三方资源框架的耦合性，独立性非常强。但我们知道，Flink 是大数据计算框架，不是资源调度框架，这并不是它的强项；所以还是应该让专业的框架做专业的事，和其他资源调度框架集成更靠谱。而在目前大数据生态中，国内应用最为广泛的资源管理平台就是 YARN 了。</p>
<p>整体来说，YARN 上部署的过程是：客户端把 Flink 应用提交给 Yarn 的 ResourceManager, Yarn 的 ResourceManager 会向 Yarn 的 NodeManager 申请容器。在这些容器上，Flink 会部署 JobManager 和 TaskManager 的实例，从而启动集群。Flink 会根据运行在 JobManger 上的作业所需要的 Slot 数量动态分配 TaskManager 资源。</p>
<h3 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h3><p>Flink 就是一个分布式的并行流处理系统。简单来说，它会由多个进程构成，这些进程一般会分布运行在不同的机器上。</p>
<p>Flink 可以配置为独立(Standalone)集群运行，也可以方便地跟一些集群资源管理工具集成使用，比如 YARN、Kubernetes 和 Mesos。Flink 也不会自己去提供持久化的分布式存储，而是直接利用了已有的分布式文件系统(比如HDFS)或者对象存储(比如S3)。而对于高可用的配置，Flink 是依靠 Apache ZooKeeper 来完成的。</p>
<p>Flink 的运行时架构中，最重要的就是两大组件：作业管理器(<strong>JobManger</strong>)和任务管理器 (<strong>TaskManager</strong>)。对于一个提交执行的作业，JobManager 是真正意义上的管理者(Master)， 负责管理调度，所以在不考虑高可用的情况下只能有一个；而 TaskManager 是工作者(Worker、Slave)，负责执行任务处理数据，所以可以有一个或多个。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8B%E5%8D%881.45.50.png" alt="截屏2022-03-22 下午1.45.50"></p>
<p>这里首先要说明一下”客户端”。其实客户端并不是处理系统的一部分，它<strong>只负责作业的提交</strong>。具体来说，就是调用程序的 main 方法，将代码转换成”数据流图”(<strong>Dataflow Graph</strong>)， 并最终生成作业图(<strong>JobGraph</strong>)，一并发送给 JobManager。提交之后，任务的执行其实就跟客户端没有关系了；我们可以在客户端选择断开与 JobManager 的连接，也可以继续保持连接。 之前我们在命令提交作业时，加上的-d 参数，就是表示分离模式(detached mode)，也就是断开连接。</p>
<p>当然，客户端可以随时连接到 JobManager，获取当前作业的状态和执行结果，也可以发送请求取消作业。不论通过 Web UI 还是命令行执行”flink run”的相关操作，都是通过客户端实现的。</p>
<p>TaskManager 启动之后，JobManager 会与它建立连接，并将作业图(<strong>JobGraph</strong>)转换成可执行的”执行图”(<strong>ExecutionGraph</strong>)分发给可用的 TaskManager，然后就由 TaskManager 具体执行任务。</p>
<h4 id="作业管理器-JobManager"><a href="#作业管理器-JobManager" class="headerlink" title="作业管理器(JobManager)"></a>作业管理器(JobManager)</h4><p>JobManager 是一个 Flink 集群中任务管理和调度的核心，是控制应用执行的主进程。也就是说，每个应用都应该被唯一的 JobManager 所控制执行。当然，在高可用(HA)的场景下，可能会出现多个 JobManager；这时只有一个是正在运行的领导节点(leader)，其他都是备用节点(standby)。</p>
<p>JobManger 又包含 3 个不同的组件：JobMaster，ResourceManager，Dispatcher</p>
<h5 id="JobMaster"><a href="#JobMaster" class="headerlink" title="JobMaster"></a>JobMaster</h5><p>JobMaster 是 JobManager 中最核心的组件，<strong>负责处理单独的作业</strong>(Job)。所以 JobMaster 和具体的 Job 是一一对应的，多个 Job 可以同时运行在一个 Flink 集群中，每个 Job 都有一个自己的 JobMaster。需要注意在早期版本的 Flink 中，没有 JobMaster 的概念；而 JobManager 的概念范围较小，实际指的就是现在所说的 JobMaster。</p>
<p>在作业提交时，JobMaster 会先接收到要执行的应用。这里所说”应用”一般是客户端提交来的，包括：Jar包、数据流图(dataflow graph)、作业图(JobGraph)。</p>
<p>JobMaster 会把 JobGraph 转换成一个物理层面的数据流图，这个图被叫作”执行图”(ExecutionGraph)，它包含了所有可以并发执行的任务。JobMaster 会向资源管理器 (ResourceManager)发出请求，申请执行任务必要的资源。一旦它获取到了足够的资源，就会将执行图分发到真正运行它们的 TaskManager 上。而在运行过程中，JobMaster 会负责所有需要中央协调的操作，比如说检查点(checkpoints)的协调。</p>
<h5 id="ResourceManager"><a href="#ResourceManager" class="headerlink" title="ResourceManager"></a>ResourceManager</h5><p>ResourceManager 主要<strong>负责资源的分配和管理</strong>，在 Flink 集群中只有一个。所谓资源，主要是指 TaskManager 的任务槽(task slots)。任务槽就是 Flink 集群中的资源调配单元，包含了机器用来执行计算的一组CPU和内存资源。每一个任务(Task)都需要分配到一个 slot 上执行。</p>
<p>这里注意要把 Flink 内置的 ResourceManager 和其他资源管理平台(比如 YARN)的 ResourceManager 区分开。</p>
<p>Flink 的 ResourceManager，针对不同的环境和资源管理平台(比如 Standalone 部署，或者 YARN)，有不同的具体实现。在 Standalone 部署时，因为 TaskManager 是单独启动的(没有 Per-Job 模式)，所以 ResourceManager 只能分发可用 TaskManager 的任务槽，不能单独启动新 TaskManager。</p>
<p>而在有资源管理平台时，就不受此限制。当新的作业申请资源时，ResourceManager 会将有空闲槽位的 TaskManager 分配给 JobMaster。如果 ResourceManager 没有足够的任务槽，它还可以向资源提供平台发起会话，请求提供启动 TaskManager 进程的容器。另外，ResourceManager 还负责停掉空闲的 TaskManager，释放计算资源。</p>
<h5 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h5><p>Dispatcher 主要负责提供一个 REST 接口，用来提交应用，并且负责为每一个新提交的作业启动一个新的 JobMaster 组件。Dispatcher 也会启动一个 Web UI，用来方便地展示和监控作业执行的信息。Dispatcher 在架构中并不是必需的，在不同的部署模式下可能会被忽略掉。</p>
<h4 id="任务管理器-TaskManager"><a href="#任务管理器-TaskManager" class="headerlink" title="任务管理器(TaskManager)"></a>任务管理器(TaskManager)</h4><p>TaskManager 是 Flink 中的工作进程，<strong>数据流的具体计算就是它来做的</strong>，所以也被称为 Worker。Flink 集群中必须至少有一个 TaskManager；当然由于分布式计算的考虑，通常会有多个 TaskManager 运行，每一个 TaskManager 都包含了一定数量的任务槽(task slots)。Slot 是资源调度的最小单位，slot 的数量限制了 TaskManager 能够并行处理的任务数量。</p>
<p>启动之后，TaskManager 会向 ResourceManager 注册它的 slots；收到 ResourceManager 的指令后，TaskManager 就会将一个或者多个槽位提供给 JobMaster 调用，JobMaster 就可以分配任务来执行了。在执行过程中，TaskManager 可以缓冲数据，还可以跟其他运行同一应用的 TaskManager 交换数据。</p>
<h4 id="作业提交流程"><a href="#作业提交流程" class="headerlink" title="作业提交流程"></a>作业提交流程</h4><p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8B%E5%8D%882.20.24.png" alt="截屏2022-03-22 下午2.20.24"></p>
<p>(1) 一般情况下，由客户端(App)通过分发器提供的 REST 接口，将作业提交给JobManager。</p>
<p>(2) 由分发器启动 JobMaster，并将作业(包含 JobGraph)提交给 JobMaster。</p>
<p>(3) JobMaster 将 JobGraph 解析为可执行的 ExecutionGraph，得到所需的资源数量，然后向资源管理器请求资源(slots)。</p>
<p>(4) 资源管理器判断当前是否由足够的可用资源；如果没有，启动新的 TaskManager。 </p>
<p>(5) TaskManager 启动之后，向 ResourceManager 注册自己的可用任务槽(slots)。</p>
<p>(6) 资源管理器通知 TaskManager 为新的作业提供 slots。</p>
<p>(7) TaskManager 连接到对应的 JobMaster，提供 slots。 </p>
<p>(8) JobMaster 将需要执行的任务分发给 TaskManager。 </p>
<p>(9) TaskManager 执行任务，互相之间可以交换数据。</p>
<p><strong>YARN集群 会话(Session)模式：</strong></p>
<p>在会话模式下，我们需要先启动一个 YARN session，这个会话会创建一个 Flink 集群。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8B%E5%8D%882.26.46.png" alt="截屏2022-03-22 下午2.26.46"></p>
<p>这里只启动了 JobManager，而 TaskManager 可以根据需要动态地启动。在 JobManager 内部，由于还没有提交作业，所以只有 ResourceManager 和 Dispatcher 在运行。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8B%E5%8D%882.28.07.png" alt="截屏2022-03-22 下午2.28.07"></p>
<p>接下来就是真正提交作业的流程：</p>
<p>(1) 客户端通过 REST 接口，将作业提交给分发器。</p>
<p>(2) 分发器启动 JobMaster，并将作业(包含 JobGraph)提交给 JobMaster。</p>
<p>(3)JobMaster 向资源管理器请求资源(slots)。</p>
<p>(4) 资源管理器向 YARN 的资源管理器请求 container 资源。</p>
<p>(5) YARN 启动新的 TaskManager 容器。</p>
<p>(6) TaskManager 启动之后，向 Flink 的资源管理器注册自己的可用任务槽。 </p>
<p>(7) 资源管理器通知 TaskManager 为新的作业提供 slots。 </p>
<p>(8) TaskManager 连接到对应的 JobMaster，提供 slots。</p>
<p>(9) JobMaster 将需要执行的任务分发给 TaskManager，执行任务。</p>
<p>注意：请求资源时要上报YARN的资源管理器。</p>
<p><strong>YARN集群 单作业(Per-Job)模式：</strong></p>
<p>在单作业模式下，Flink 集群不会预先启动，而是在提交作业时，才启动新的 JobManager。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8B%E5%8D%882.41.21.png" alt="截屏2022-03-22 下午2.41.21"></p>
<p>(1) 客户端将作业提交给 YARN 的资源管理器，这一步中会同时将 Flink 的 Jar 包和配置 上传到 HDFS，以便后续启动 Flink 相关组件的容器。</p>
<p>(2) YARN的资源管理器分配Container资源，启动Flink JobManager，并将作业提交给 JobMaster。这里省略了 Dispatcher 组件。</p>
<p>(3) JobMaster 向资源管理器请求资源(slots)。</p>
<p>(4) 资源管理器向 YARN 的资源管理器请求 container 资源。</p>
<p>(5) YARN 启动新的 TaskManager 容器。</p>
<p>(6) TaskManager 启动之后，向 Flink 的资源管理器注册自己的可用任务槽。 </p>
<p>(7) 资源管理器通知 TaskManager 为新的作业提供 slots。 </p>
<p>(8) TaskManager 连接到对应的 JobMaster，提供 slots。</p>
<p>(9) JobMaster 将需要执行的任务分发给 TaskManager，执行任务。</p>
<p>区别只在于 JobManager 的启动方式，以及省去了分发器。当第 2 步作业提交给 JobMaster，之后的流程就与会话模式完全一样了。</p>
<p><strong>YARN集群的应用(Application)模式：</strong></p>
<p>应用模式与单作业模式的提交流程非常相似，只是初始提交给 YARN 资源管理器的不再 是具体的作业，而是整个应用。一个应用中可能包含了多个作业，这些作业都将在 Flink 集群 中启动各自对应的 JobMaster。</p>
<h4 id="数据流图-Dataflow-Graph"><a href="#数据流图-Dataflow-Graph" class="headerlink" title="数据流图(Dataflow Graph)"></a>数据流图(Dataflow Graph)</h4><p>所有的 Flink 程序都可以归纳为由三部分构成：Source、Transformation 和 Sink。 </p>
<p>Source表示源算子，负责读取数据源。</p>
<p>Transformation表示转换算子，利用各种算子进行处理加工。</p>
<p>Sink表示下沉算子，负责数据的输出。</p>
<p>在运行时，Flink 程序会被映射成所有算子按照逻辑顺序连接在一起的一张图，这被称为逻辑数据流(logical dataflow)，或者叫数据流图(dataflow graph)。我们提交作业之后， 打开 Flink 自带的 Web UI，点击作业就能看到对应的 dataflow。</p>
<h4 id="并行度-Parallelism"><a href="#并行度-Parallelism" class="headerlink" title="并行度(Parallelism)"></a>并行度(Parallelism)</h4><p>在 Flink 执行过程中，每一个算子(operator)可以包含一个或多个子任务(operator subtask)，<strong>这些子任务在不同的线程、不同的物理机或不同的容器中完全独立地执行</strong>。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8B%E5%8D%884.36.32.png" alt="截屏2022-03-22 下午4.36.32"></p>
<p>**一个特定算子的子任务(subtask)的个数被称之为其并行度(parallelism)**。这样，包含并行子任务的数据流，就是并行数据流，它需要多个分区(stream partition)来分配并行任务。 一般情况下，一个流程序的并行度，可以认为就是其所有算子中最大的并行度。一个程序中， 不同的算子可能具有不同的并行度。</p>
<p>如图 4-8 所示，当前数据流中有 source、map、window、sink 四个算子，除最后 sink，其他算子的并行度都为 2。整个程序包含了 7 个子任务，至少需要 2 个分区来并行执行。我们可以说，这段流处理程序的并行度就是 2。</p>
<p><strong>并行度的设置：</strong></p>
<p>可以用不同的方法来设置并行度，它们的有效范围和优先级别也是不同的。</p>
<p>1、代码中设置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只针对当前算子有效</span></span><br><span class="line">stream.map(word -&gt; Tuple2.of(word, <span class="number">1L</span>)).setParallelism(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局设定并行度</span></span><br><span class="line"><span class="comment">//这样代码中所有算子，默认的并行度就都为2了</span></span><br><span class="line">env.setParallelism(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//keyBy不是算子，所以无法对keyBy设置并行度</span></span><br></pre></td></tr></table></figure>

<p>2、提交应用时设置</p>
<p>在使用flink run命令提交应用时，可以增加-p参数来指定当前应用程序执行的并行度，它的作用类似于执行环境的全局设置。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/flink run –p 2 –c com.vincent.wc.StreamWordCount ./FlinkTutorial-1.0-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>

<p>3、配置文件中设置</p>
<p>我们还可以直接在集群的配置文件 flink-conf.yaml 中直接更改默认并行度。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">parallelism.default:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>这个设置对于整个集群上提交的所有作业有效，初始值为 1。无论在代码中设置、还是提交时的 -p 参数，都不是必须的；所以在没有指定并行度的时候，就会采用配置文件中的集群 默认并行度。在开发环境中，没有配置文件，默认并行度就是当前机器的 CPU 核心数。</p>
<p><strong>优先级：</strong></p>
<p>(1) 对于一个算子，首先看在<strong>代码中是否单独指定了它的并行度</strong>，这个特定的设置优先级最高，会覆盖后面所有的设置。 </p>
<p>(2) 如果没有单独设置，那么采用当前<strong>代码中执行环境全局设置的并行度</strong>。 </p>
<p>(3) 如果代码中完全没有设置，那么采用<strong>提交时-p 参数指定的并行度</strong>。</p>
<p>(4) 如果提交时也未指定-p 参数，那么采用集群<strong>配置文件</strong>中的默认并行度。</p>
<h4 id="算子链-Operator-Chain"><a href="#算子链-Operator-Chain" class="headerlink" title="算子链(Operator Chain)"></a>算子链(Operator Chain)</h4><p>一个数据流在算子之间传输数据的形式可以是一对一(one-to-one)的直通 (forwarding)模式，也可以是打乱的重分区(redistributing)模式，具体是哪一种形式，取决于算子的种类。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8B%E5%8D%885.01.43.png" alt="截屏2022-03-22 下午5.01.43"></p>
<h5 id="一对一-one-to-one"><a href="#一对一-one-to-one" class="headerlink" title="一对一(one-to-one)"></a>一对一(one-to-one)</h5><p>这种模式下，<strong>数据流维护着分区以及元素的顺序</strong>。比如图中的 source 和 map 算子，source 算子读取数据之后，可以直接发送给 map 算子做处理，它们之间不需要重新分区，也不需要调整数据的顺序。这就意味着 map 算子的子任务，看到的元素个数和顺序跟 source 算子的子任务产生的完全一样，保证着一对一的关系。map、filter、flatMap 等算子都是这种 one-to-one 的对应关系。</p>
<h5 id="重分区-Redistributing"><a href="#重分区-Redistributing" class="headerlink" title="重分区(Redistributing)"></a>重分区(Redistributing)</h5><p>在这种模式下，<strong>数据流的分区会发生改变</strong>。比图中的 map 和后面的 keyBy/window 算子之间(这里的 keyBy 是数据传输算子，后面的 window、apply 方法共同构成了 window 算子)，以及 keyBy/window 算子和 Sink 算子之间，都是这样的关系。</p>
<p>每一个算子的子任务，会根据数据传输的策略，把数据发送到不同的下游目标任务。例如，keyBy()是分组操作，<strong>本质上基于键(key)的哈希值(hashCode)进行了重分区</strong>；而当并行度改变时，比如从并行度为 2 的 window 算子，要传递到并行度为 1 的 Sink 算子，这时的数据传输方式是再平衡(rebalance)，会把数据均匀地向下游子任务分发出去。这些传输方式都会引起重分区(redistribute)的过程，这一过程类似于 Spark 中的 shuffle。</p>
<h5 id="合并算子链"><a href="#合并算子链" class="headerlink" title="合并算子链"></a>合并算子链</h5><p>在 Flink 中，并行度相同的一对一(one to one)算子操作，可以直接链接在一起形成一个大的任务(task)，这样原来的算子就成为了真正任务里的一部分。每个 task 会被一个<strong>线程</strong>执行。这样的技术被称为“算子链”(Operator Chain)。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8B%E5%8D%885.28.05.png" alt="截屏2022-03-22 下午5.28.05"></p>
<p>比如在图 4-11 中的例子中，Source 和 map 之间满足了算子链的要求，所以可以直接合并在一起，形成了一个任务；因为并行度为 2，所以合并后的任务也有两个并行子任务。这样，这个数据流图所表示的作业最终会有 5 个任务，由 5 个线程并行执行。</p>
<p>Flink 为什么要有算子链这样一个设计呢？这是因为将算子链接成 task 是非常有效的优化：可以减少线程之间的切换和基于缓存区的数据交换，在减少时延的同时提升吞吐量。</p>
<p>Flink 默认会按照算子链的原则进行链接合并，如果我们想要禁止合并或者自行定义，也可以在代码中对算子做一些特定的设置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 禁用算子链</span></span><br><span class="line">.map(word -&gt; Tuple2.of(word, <span class="number">1L</span>)).disableChaining(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 从当前算子开始新链</span></span><br><span class="line">.map(word -&gt; Tuple2.of(word, <span class="number">1L</span>)).startNewChain();</span><br></pre></td></tr></table></figure>

<h4 id="作业图-JobGraph-与执行图-ExecutionGraph"><a href="#作业图-JobGraph-与执行图-ExecutionGraph" class="headerlink" title="作业图(JobGraph)与执行图(ExecutionGraph)"></a>作业图(JobGraph)与执行图(ExecutionGraph)</h4><p>逻辑流图(StreamGraph)→ 作业图(JobGraph)→ 执行图(ExecutionGraph)→ 物理图(Physical Graph)</p>
<p>处理 socket 文本流的 StreamWordCount 程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env.socketTextStream().flatMap(...).keyBy(<span class="number">0</span>).sum(<span class="number">1</span>).print();</span><br></pre></td></tr></table></figure>

<p>提交时设置并行度为 2：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/flink run –p 2 –c com.vincent.wc.StreamWordCount ./FlinkTutorial-1.0-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>

<p>除了 socketTextStream() 是非并行的 Source 算子，它的并行度始终 为 1，其他算子的并行度都为 2。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8B%E5%8D%889.46.48.png" alt="截屏2022-03-22 下午9.46.48"></p>
<ol>
<li>逻辑流图(StreamGraph)</li>
</ol>
<p>这是根据用户通过 DataStream API 编写的代码生成的最初的 DAG 图，用来表示程序的拓扑结构。这一步一般在<strong>客户端</strong>完成。我们可以看到，逻辑流图中的节点，完全对应着代码中的四步算子操作：源算子 Source(socketTextStream())→扁平映射算子 Flat Map(flatMap()) →分组聚合算子 Keyed Aggregation(keyBy/sum()) →输出算子 Sink(print())。</p>
<ol start="2">
<li>作业图(JobGraph)</li>
</ol>
<p>StreamGraph 经过优化后生成的就是作业图(JobGraph)，这是提交给 JobManager 的数据结构，确定了当前作业中所有任务的划分。主要的优化为：将多个符合条件的节点链接在一起合并成一个任务节点，形成<strong>算子链</strong>，这样可以减少数据交换的消耗。JobGraph 一般也是在<strong>客户端</strong>生成的，在作业提交时传递给 JobMaster。在图 4-12 中，分组聚合算子(Keyed Aggregation)和输出算子 Sink(print)并行度都为 2， 而且是一对一的关系，满足算子链的要求，所以会合并在一起，成为一个任务节点。</p>
<ol start="3">
<li>执行图(ExecutionGraph)</li>
</ol>
<p>JobMaster 收到 JobGraph 后，会根据它来生成执行图(ExecutionGraph)。ExecutionGraph 是 JobGraph 的并行化版本，是调度层最核心的数据结构。从图 4-12 中可以看到，与 JobGraph 最大的区别就是<strong>按照并行度对并行子任务进行了拆分</strong>， 并明确了任务间数据传输的方式。</p>
<ol start="4">
<li>物理图(Physical Graph)</li>
</ol>
<p>JobMaster 生成执行图后， 会将它分发给 TaskManager；各个 TaskManager 会根据执行图部署任务，最终的物理执行过程也会形成一张图，一般就叫作物理图(Physical Graph)。 这只是具体执行层面的图，并不是一个具体的数据结构。对应在上图 4-12 中，物理图主要就是在执行图的基础上，进一步<strong>确定数据存放的位置和收发的具体方式</strong>。有了物理图，TaskManager 就可以对传递来的数据进行处理计算了。所以我们可以看到，程序里定义了<strong>四个算子</strong>操作：源(Source)-&gt;转换(flatMap)-&gt;分组聚合(keyBy/sum)-&gt;输出(print)；合并算子链进行优化之后，就只有<strong>三个任务节点</strong>了；再考虑并行度后，一共有 <strong>5 个并行子任务</strong>，最终需要 <strong>5 个线程来</strong>执行。</p>
<h4 id="任务-Tasks-和任务槽-Task-Slots"><a href="#任务-Tasks-和任务槽-Task-Slots" class="headerlink" title="任务(Tasks)和任务槽(Task Slots)"></a>任务(Tasks)和任务槽(Task Slots)</h4><p>Flink 中每一个 worker(也就是 TaskManager)都是一个 <strong>JVM 进程</strong>，它可以启动<strong>多个独立的线程</strong>，来**并行执行多个子任务(subtask)**。</p>
<p>所以如果想要执行 5 个任务，并不一定非要 5 个 TaskManager，我们可以让 TaskManager 多线程执行任务。如果可以同时运行 5 个线程，那么只要一个 TaskManager 就可以满足我们之前程序的运行需求了。</p>
<p>很显然，TaskManager 的计算资源是有限的，并不是所有任务都可以放在一个 TaskManager 上并行执行。并行的任务越多，每个线程的资源就会越少。那一个 TaskManager 到底能并行处理多少个任务呢？为了控制并发量，我们需要在 TaskManager 上对每个任务运行所占用的资源做出明确的划分，这就是所谓的任务槽(task slots)。</p>
<p>每个任务槽(task slot)其实表示了<strong>TaskManager</strong>拥有计算资源的一个<strong>固定大小的子集</strong>。这些资源就是用来独立执行一个<strong>子任务</strong>的。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8B%E5%8D%8810.22.59.png" alt="截屏2022-03-22 下午10.22.59"></p>
<p>假如一个 TaskManager 有三个 slot，那么它会将管理的内存平均分成三份，每个 slot 独自占据一份。这样一来，我们在 slot 上执行一个子任务时，相当于划定了一块内存”专款专用”，就不需要跟来自其他作业的任务去竞争内存资源了。所以现在我们只要 2 个 TaskManager，就可以并行处理分配好的 5 个任务了。</p>
<p><strong>任务槽数量的设置</strong></p>
<p>我们可以通过集群的配置文件来设定 TaskManager 的 slot 数量：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskmanager.numberOfTaskSlots: 8</span><br></pre></td></tr></table></figure>

<p>通过调整 slot 的数量，我们就可以控制子任务之间的隔离级别。</p>
<p>具体来说，如果一个 TaskManager 只有一个 slot，那将意味着每个任务都会运行在独立的 JVM 中(当然，该 JVM 可能是通过一个特定的容器启动的)；而一个 TaskManager 设置多个 slot 则意味着多个子任务可以共享同一个 JVM。它们的区别在于：前者任务之间完全独立运行， 隔离级别更高、彼此间的影响可以降到最小；而后者在同一个 JVM 进程中运行的任务，将<strong>共享 TCP 连接和心跳消息</strong>，也可能<strong>共享数据集和数据结构</strong>，这就减少了每个任务的运行开销， 在降低隔离级别的同时提升了性能。</p>
<p>需要注意的是，<strong>slot 目前仅仅用来隔离内存</strong>，不会涉及 CPU 的隔离。在具体应用时，可以将 slot 数量配置为机器的 CPU 核心数，尽量避免不同任务之间对 CPU 的竞争。这也是开发环境默认并行度设为机器 CPU 数量的原因。</p>
<p><strong>任务对任务槽的共享</strong></p>
<p>这样看来，一共有多少子任务，我们就需要有多少 slot 来并行处理它们。不过实际提交作业进行测试就会发现，我们之前的WordCount 程序设置并行度为 2 提交，一共有 5 个并行子任务，可集群即使只有 2 个 task slot 也是可以成功提交并运行的。这又是为什么呢？</p>
<p>我们可以基于之前的例子继续扩展。如果我们保持 sink 任务并行度为 1 不变，而作业提交时设置全局并行度为 6，那么前两个任务节点就会各自有 6 个并行子任务，整个流处理程序 则有 13 个子任务。那对于 2 个 TaskManager、每个有 3 个 slot 的集群配置来说，还能否正常运行呢?</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-03-22%20%E4%B8%8B%E5%8D%8810.35.04.png" alt="截屏2022-03-22 下午10.35.04"></p>
<p>完全没有问题。这是因为默认情况下，Flink 是允许子任务共享 slot 的。只要属于同一个作业，那么对于不同任务节点的并行子任务，就可以放到同一个 slot 上执行。 所以对于第一个任务节点 source→map，它的 6 个并行子任务必须分到不同的 slot 上(如果在 同一 slot 就没法数据并行了)，而第二个任务节点 keyBy/window/apply 的并行子任务却可以和第一个任务节点共享 slot。</p>
<p>这个特性看起来有点奇怪：我们不是希望并行处理、任务之间相互隔离吗，为什么这里又允许共享 slot 呢?</p>
<p>我们知道，一个 slot 对应了一组独立的计算资源。在之前不做共享的时候，每个任务都平等地占据了一个 slot，但其实<strong>不同的任务对资源的占用是不同的</strong>。例如这里的前两个任务， source/map 尽管是两个算子合并算子链得到的，但它只是基本的数据读取和简单转换，计算耗时极短，一般也不需要太大的内存空间；而 window 算子所做的窗口操作，往往会涉及大量的数据、状态存储和计算，我们一般把这类任务叫作<strong>资源密集型(intensive)任务</strong>。当它们被平等地分配到独立的 slot 上时，实际运行我们就会发现，大量数据到来时 source/map 和 sink 任务很快就可以完成，但 window 任务却耗时很久；于是<strong>下游的 sink 任务占据的 slot 就会等待闲置</strong>，而上游的 source/map 任务受限于下游的处理能力，也会在快速处理完一部分数据后阻塞对应的资源开始等待(相当于处理背压)。这样资源的利用就出现了极大的不平衡，忙的忙死，闲的闲死。</p>
<p>解决这一问题的思路就是允许 slot 共享。当我们<strong>将资源密集型和非密集型的任务同时放到 一个 slot 中</strong>，它们就可以自行分配对资源占用的比例，从而保证最重的活平均分配给所有的 TaskManager。</p>
<p>slot 共享另一个好处就是允许我们保存完整的作业管道。这样一来，即使某个 TaskManager 出现故障宕机，其他节点也可以完全不受影响，作业的任务可以继续执行。</p>
<p>另外，同一个任务节点的并行子任务是不能共享 slot 的。所以允许 slot 共享之后，运行作业所需的 slot 数量正好就是作业中所有算子并行度的最大值。这样一来，我们考虑当前集群需要配置多少 slot 资源时，就不需要再去详细计算一个作业总共包含多少个并行子任务了，只看<strong>最大的并行度</strong>就够了。</p>
<p>Flink 默认是允许 slot 共享的，如果希望某个算子对应的任务完全独占一个 slot，或者只有某一部分算子共享 slot，我们也可以通过设置slot 共享组(SlotSharingGroup)手动指定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.map(word -&gt; Tuple2.of(word, <span class="number">1L</span>)).slotSharingGroup(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="comment">//如果下游算子没有设置分组，它继承上游算子的分组</span></span><br></pre></td></tr></table></figure>

<p>这样，只有属于同一个 slot 共享组的子任务，才会开启 slot 共享；不同组之间的任务是完全隔离的，必须分配到不同的 slot 上。在这种场景下，总共需要的 slot 数量，就是各个 slot 共享组最大并行度的总和。</p>
<p><strong>任务槽和并行度的关系</strong></p>
<p>Slot 和并行度确实都跟程序的并行执行有关，但两者是完全不同的概念。简单来说，task slot 是静态的概念，是指 TaskManager 具有的并发执行能力，可以通过参数 taskmanager.numberOfTaskSlots 进行配置；而并行度(parallelism)是动态概念，也就是 TaskManager 运行程序时实际使用的并发能力，可以通过参数 parallelism.default 进行配置。换句话说，并行度如果小于等于集群中可用 slot 的总数，程序是可以正常执行的，因为 slot 不一定要全部占用，有十分力气可以只用八分；而如果并行度大于可用 slot 总数，导致超出了并行能力上限，那么心有余力不足，程序就只好等待资源管理器分配更多的资源了。</p>
<h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">flink.version</span>&gt;</span>1.12.0<span class="tag">&lt;/<span class="name">flink.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scala.binary.version</span>&gt;</span>2.11<span class="tag">&lt;/<span class="name">scala.binary.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slf4j.version</span>&gt;</span>1.7.30<span class="tag">&lt;/<span class="name">slf4j.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-streaming-java_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-clients_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-runtime-web_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-to-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.14.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-kafka_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.75<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-redis_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-elasticsearch6_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.49<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-jdbc_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-statebackend-rocksdb_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-hdfs<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-cep_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-table-planner_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-table-planner-blink_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-streaming-scala_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-csv<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-json<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-hive_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- Hive Dependency --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hive<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hive-exec<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="WordCount"><a href="#WordCount" class="headerlink" title="WordCount"></a>WordCount</h2><h3 id="batch"><a href="#batch" class="headerlink" title="batch"></a>batch</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.获取执行环境</span></span><br><span class="line">    ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.读取文件</span></span><br><span class="line">    DataSource&lt;String&gt; input = env.readTextFile(<span class="string">&quot;/Users/vincent/Documents/flink/input/word.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.用flatmap压平 1行hello world 变成 1行hello 1行world</span></span><br><span class="line">    FlatMapOperator&lt;String, String&gt; stringObjectFlatMapOperator = input.flatMap(<span class="keyword">new</span> FlatMapFunction&lt;String, String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(String s, Collector&lt;String&gt; collector)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">//按照空格切割</span></span><br><span class="line">            String[] words = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (String word: words</span><br><span class="line">                 ) &#123;</span><br><span class="line">                collector.collect(word);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.单词变元组 hello -&gt; (hello,1)</span></span><br><span class="line">    MapOperator&lt;String, Tuple2&lt;String,Integer&gt;&gt; stringObjectMapOperator = stringObjectFlatMapOperator.map(<span class="keyword">new</span> MapFunction&lt;String, Tuple2&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Tuple2&lt;String, Integer&gt; <span class="title">map</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">//return new Tuple2&lt;&gt;(s,1);</span></span><br><span class="line">            <span class="keyword">return</span> Tuple2.of(s,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.分组</span></span><br><span class="line">    UnsortedGrouping&lt;Tuple2&lt;String, Integer&gt;&gt; tuple2UnsortedGrouping = stringObjectMapOperator.groupBy(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.聚合</span></span><br><span class="line">    AggregateOperator&lt;Tuple2&lt;String, Integer&gt;&gt; tuple2AggregateOperator = tuple2UnsortedGrouping.sum(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.显示</span></span><br><span class="line">    tuple2AggregateOperator.print();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建执行环境</span></span><br><span class="line">    ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    <span class="comment">// 2. 从文件读取数据  按行读取(存储的元素就是每行的文本)</span></span><br><span class="line">    DataSource&lt;String&gt; lineDS = env.readTextFile(<span class="string">&quot;/Users/vincent/Documents/flink/input/word.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 3. 转换数据格式</span></span><br><span class="line">    FlatMapOperator&lt;String, Tuple2&lt;String, Long&gt;&gt; wordAndOne = lineDS</span><br><span class="line">            .flatMap((String line, Collector&lt;Tuple2&lt;String, Long&gt;&gt; out) -&gt; &#123;</span><br><span class="line">                String[] words = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">                    out.collect(Tuple2.of(word, <span class="number">1L</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .returns(Types.TUPLE(Types.STRING, Types.LONG));  <span class="comment">//当Lambda表达式使用 Java 泛型的时候, 由于泛型擦除的存在, 需要显示的声明类型信息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 按照 word 进行分组</span></span><br><span class="line">    UnsortedGrouping&lt;Tuple2&lt;String, Long&gt;&gt; wordAndOneUG = wordAndOne.groupBy(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 5. 分组内聚合统计</span></span><br><span class="line">    AggregateOperator&lt;Tuple2&lt;String, Long&gt;&gt; sum = wordAndOneUG.sum(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 打印结果</span></span><br><span class="line">    sum.print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="bounded-stream"><a href="#bounded-stream" class="headerlink" title="bounded_stream"></a>bounded_stream</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、创建执行环境，设置并行度为1</span></span><br><span class="line">    StreamExecutionEnvironment executionEnvironment = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    executionEnvironment.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、读取文件流</span></span><br><span class="line">    DataStreamSource&lt;String&gt; stringDataStreamSource = executionEnvironment.readTextFile(<span class="string">&quot;/Users/vincent/Documents/flink/input/word.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.hello world 转换为 (hello,1) (world,1)</span></span><br><span class="line">    SingleOutputStreamOperator&lt;Tuple2&lt;String, Integer&gt;&gt; objectSingleOutputStreamOperator = stringDataStreamSource.flatMap(<span class="keyword">new</span> FlatMapFunction&lt;String, Tuple2&lt;String,Integer&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(String s, Collector&lt;Tuple2&lt;String,Integer&gt;&gt; collector)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            String[] words = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (String word: words</span><br><span class="line">                 ) &#123;</span><br><span class="line">                collector.collect(Tuple2.of(word, <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.分组</span></span><br><span class="line">    KeyedStream&lt;Tuple2&lt;String, Integer&gt;, String&gt; tuple2TupleKeyedStream = objectSingleOutputStreamOperator.keyBy(<span class="keyword">new</span> KeySelector&lt;Tuple2&lt;String, Integer&gt;, String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getKey</span><span class="params">(Tuple2&lt;String, Integer&gt; stringIntegerTuple2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> stringIntegerTuple2.f0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.聚合</span></span><br><span class="line">    SingleOutputStreamOperator&lt;Tuple2&lt;String, Integer&gt;&gt; sum = tuple2TupleKeyedStream.sum(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.显示</span></span><br><span class="line">    sum.print();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.启动任务</span></span><br><span class="line">    JobExecutionResult execute = executionEnvironment.execute(<span class="string">&quot;start&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建流式执行环境</span></span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    <span class="comment">// 2. 读取文件</span></span><br><span class="line">    DataStreamSource&lt;String&gt; lineDSS = env.readTextFile(<span class="string">&quot;/Users/vincent/Documents/flink/input/word.txt&quot;</span>);</span><br><span class="line">    <span class="comment">// 3. 转换数据格式</span></span><br><span class="line">    SingleOutputStreamOperator&lt;Tuple2&lt;String, Long&gt;&gt; wordAndOne = lineDSS</span><br><span class="line">            .flatMap((String line, Collector&lt;String&gt; words) -&gt; &#123;</span><br><span class="line">                Arrays.stream(line.split(<span class="string">&quot; &quot;</span>)).forEach(words::collect);</span><br><span class="line">            &#125;)</span><br><span class="line">            .returns(Types.STRING)</span><br><span class="line">            .map(word -&gt; Tuple2.of(word, <span class="number">1L</span>))</span><br><span class="line">            .returns(Types.TUPLE(Types.STRING, Types.LONG));</span><br><span class="line">    <span class="comment">// 4. 分组</span></span><br><span class="line">    KeyedStream&lt;Tuple2&lt;String, Long&gt;, String&gt; wordAndOneKS = wordAndOne</span><br><span class="line">            .keyBy(t -&gt; t.f0);</span><br><span class="line">    <span class="comment">// 5. 求和</span></span><br><span class="line">    SingleOutputStreamOperator&lt;Tuple2&lt;String, Long&gt;&gt; result = wordAndOneKS</span><br><span class="line">            .sum(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 6. 打印</span></span><br><span class="line">    result.print();</span><br><span class="line">    <span class="comment">// 7. 执行</span></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="unbounded-stream"><a href="#unbounded-stream" class="headerlink" title="unbounded_stream"></a>unbounded_stream</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.获取执行环境</span></span><br><span class="line">    StreamExecutionEnvironment executionEnvironment = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    executionEnvironment.setParallelism(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.读取端口数据流</span></span><br><span class="line">    DataStreamSource&lt;String&gt; stringDataStreamSource = executionEnvironment.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">1234</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.转换为元组</span></span><br><span class="line">    SingleOutputStreamOperator&lt;Tuple2&lt;String, Integer&gt;&gt; objectSingleOutputStreamOperator = stringDataStreamSource.flatMap(<span class="keyword">new</span> FlatMapFunction&lt;String, Tuple2&lt;String,Integer&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(String s, Collector&lt;Tuple2&lt;String,Integer&gt;&gt; collector)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            String[] words = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (String word: words</span><br><span class="line">            ) &#123;</span><br><span class="line">                collector.collect(Tuple2.of(word, <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.分组</span></span><br><span class="line">    KeyedStream&lt;Tuple2&lt;String, Integer&gt;, String&gt; tuple2TupleKeyedStream = objectSingleOutputStreamOperator.keyBy(<span class="keyword">new</span> KeySelector&lt;Tuple2&lt;String, Integer&gt;, String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getKey</span><span class="params">(Tuple2&lt;String, Integer&gt; stringIntegerTuple2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> stringIntegerTuple2.f0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5.聚合</span></span><br><span class="line">    SingleOutputStreamOperator&lt;Tuple2&lt;String, Integer&gt;&gt; sum = tuple2TupleKeyedStream.sum(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//6.显示</span></span><br><span class="line">    sum.print();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//7.启动任务</span></span><br><span class="line">    executionEnvironment.execute();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建流式执行环境</span></span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    <span class="comment">// 2. 读取文本流</span></span><br><span class="line">    DataStreamSource&lt;String&gt; lineDSS = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">7777</span>);</span><br><span class="line">    <span class="comment">// 3. 转换数据格式</span></span><br><span class="line">    SingleOutputStreamOperator&lt;Tuple2&lt;String, Long&gt;&gt; wordAndOne = lineDSS</span><br><span class="line">            .flatMap((String line, Collector&lt;String&gt; words) -&gt; &#123;</span><br><span class="line">                Arrays.stream(line.split(<span class="string">&quot; &quot;</span>)).forEach(words::collect);</span><br><span class="line">            &#125;)</span><br><span class="line">            .returns(Types.STRING)</span><br><span class="line">            .map(word -&gt; Tuple2.of(word, <span class="number">1L</span>))</span><br><span class="line">            .returns(Types.TUPLE(Types.STRING, Types.LONG));</span><br><span class="line">    <span class="comment">// 4. 分组</span></span><br><span class="line">    KeyedStream&lt;Tuple2&lt;String, Long&gt;, String&gt; wordAndOneKS = wordAndOne</span><br><span class="line">            .keyBy(t -&gt; t.f0);</span><br><span class="line">    <span class="comment">// 5. 求和</span></span><br><span class="line">    SingleOutputStreamOperator&lt;Tuple2&lt;String, Long&gt;&gt; result = wordAndOneKS</span><br><span class="line">            .sum(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 6. 打印</span></span><br><span class="line">    result.print();</span><br><span class="line">    <span class="comment">// 7. 执行</span></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h2><h3 id="collection"><a href="#collection" class="headerlink" title="collection"></a>collection</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">StreamExecutionEnvironment executionEnvironment = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">executionEnvironment.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">List&lt;WaterSensor&gt; list = Arrays.asList(</span><br><span class="line">  <span class="keyword">new</span> WaterSensor(<span class="string">&quot;a&quot;</span>,<span class="number">12345678910L</span>,<span class="number">56</span>),</span><br><span class="line">  <span class="keyword">new</span> WaterSensor(<span class="string">&quot;b&quot;</span>,<span class="number">12354657829L</span>,<span class="number">57</span>),</span><br><span class="line">  <span class="keyword">new</span> WaterSensor(<span class="string">&quot;c&quot;</span>,<span class="number">12362457829L</span>,<span class="number">52</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">DataStreamSource&lt;WaterSensor&gt; waterSensorDataStreamSource = executionEnvironment.fromCollection(list);</span><br><span class="line"></span><br><span class="line">waterSensorDataStreamSource.print();</span><br><span class="line"></span><br><span class="line">executionEnvironment.execute();</span><br></pre></td></tr></table></figure>

<h3 id="file"><a href="#file" class="headerlink" title="file"></a>file</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">StreamExecutionEnvironment executionEnvironment = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">executionEnvironment.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">DataStreamSource&lt;String&gt; stringDataStreamSource = executionEnvironment.readTextFile(<span class="string">&quot;input/sensor.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">SingleOutputStreamOperator&lt;WaterSensor&gt; map = stringDataStreamSource.map(<span class="keyword">new</span> MapFunction&lt;String, WaterSensor&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WaterSensor <span class="title">map</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String[] split = s.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WaterSensor(split[<span class="number">0</span>],Long.parseLong(split[<span class="number">1</span>]),Integer.parseInt(split[<span class="number">2</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">map.print();</span><br><span class="line"></span><br><span class="line">executionEnvironment.execute();</span><br></pre></td></tr></table></figure>

<h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">DataStreamSource&lt;String&gt; socketTextStream = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">1234</span>);</span><br><span class="line"></span><br><span class="line">socketTextStream.print();</span><br><span class="line"></span><br><span class="line">env.execute();</span><br></pre></td></tr></table></figure>

<h3 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-console-producer.sh --broker-list linux1:9092 --topic clicks</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">    properties.setProperty(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;linux1:9092&quot;</span>);</span><br><span class="line">    properties.setProperty(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;consumer-group&quot;</span>);</span><br><span class="line">    properties.setProperty(<span class="string">&quot;key.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">    properties.setProperty(<span class="string">&quot;value.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">    properties.setProperty(<span class="string">&quot;auto.offset.reset&quot;</span>, <span class="string">&quot;latest&quot;</span>);</span><br><span class="line"></span><br><span class="line">    DataStreamSource&lt;String&gt; stream = env.addSource(<span class="keyword">new</span> FlinkKafkaConsumer&lt;String&gt;(</span><br><span class="line">            <span class="string">&quot;clicks&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> SimpleStringSchema(),</span><br><span class="line">            properties</span><br><span class="line">    ));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    stream.print(<span class="string">&quot;Kafka&quot;</span>);</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="custom-parallel"><a href="#custom-parallel" class="headerlink" title="custom_parallel"></a>custom_parallel</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">    env.addSource(<span class="keyword">new</span> CustomSource()).setParallelism(<span class="number">2</span>).print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomSource</span> <span class="keyword">implements</span> <span class="title">ParallelSourceFunction</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> running = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(SourceContext&lt;Integer&gt; sourceContext)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            sourceContext.collect(random.nextInt());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        running = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="custom-source"><a href="#custom-source" class="headerlink" title="custom_source"></a>custom_source</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    StreamExecutionEnvironment executionEnvironment = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    executionEnvironment.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    DataStreamSource&lt;WaterSensor&gt; objectDataStreamSource = executionEnvironment.addSource(<span class="keyword">new</span> MySource(<span class="string">&quot;localhost&quot;</span>,<span class="number">2345</span>));</span><br><span class="line"></span><br><span class="line">    objectDataStreamSource.print();</span><br><span class="line"></span><br><span class="line">    executionEnvironment.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MySource</span> <span class="keyword">implements</span> <span class="title">SourceFunction</span>&lt;<span class="title">WaterSensor</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Boolean running = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySource</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(SourceContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        socket = <span class="keyword">new</span> Socket(host,port);</span><br><span class="line">        reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket.getInputStream(), UTF_8));</span><br><span class="line"></span><br><span class="line">        String s = reader.readLine();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(running &amp;&amp; s != <span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            String[] split = s.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            WaterSensor waterSensor = <span class="keyword">new</span> WaterSensor(split[<span class="number">0</span>], Long.parseLong(split[<span class="number">1</span>]), Integer.parseInt(split[<span class="number">2</span>]));</span><br><span class="line">            ctx.collect(waterSensor);</span><br><span class="line">            s = reader.readLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        running = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            reader.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h2><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    DataStreamSource&lt;Event&gt; stream = env.fromElements(</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./cart&quot;</span>, <span class="number">2000L</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传入匿名实现类的匿名对象，实现MapFunction</span></span><br><span class="line">    stream.map(<span class="keyword">new</span> MapFunction&lt;Event, String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">map</span><span class="params">(Event e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> e.user;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传入MapFunction的实现类的匿名对象</span></span><br><span class="line">    stream.map(<span class="keyword">new</span> UserExtractor()).print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserExtractor</span> <span class="keyword">implements</span> <span class="title">MapFunction</span>&lt;<span class="title">Event</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">map</span><span class="params">(Event e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> e.user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="richFunction"><a href="#richFunction" class="headerlink" title="richFunction"></a>richFunction</h3><p>RichFunction富有的地方在于：1、生命周期方法 2、可以获取上下文执行环境，做状态编程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An base interface for all rich user-defined functions. This class defines methods for the life</span></span><br><span class="line"><span class="comment"> * cycle of the functions, as well as methods to access the context in which the functions are</span></span><br><span class="line"><span class="comment"> * executed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Public</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RichFunction</span> <span class="keyword">extends</span> <span class="title">Function</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initialization method for the function. It is called before the actual working methods (like</span></span><br><span class="line"><span class="comment">     * &lt;i&gt;map&lt;/i&gt; or &lt;i&gt;join&lt;/i&gt;) and thus suitable for one time setup work. For functions that are</span></span><br><span class="line"><span class="comment">     * part of an iteration, this method will be invoked at the beginning of each iteration</span></span><br><span class="line"><span class="comment">     * superstep.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The configuration object passed to the function can be used for configuration and</span></span><br><span class="line"><span class="comment">     * initialization. The configuration contains all parameters that were configured on the</span></span><br><span class="line"><span class="comment">     * function in the program composition.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;&#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">     * public class MyFilter extends RichFilterFunction&lt;String&gt; &#123;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     private String searchString;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     public void open(Configuration parameters) &#123;</span></span><br><span class="line"><span class="comment">     *         this.searchString = parameters.getString(&quot;foo&quot;);</span></span><br><span class="line"><span class="comment">     *     &#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *     public boolean filter(String value) &#123;</span></span><br><span class="line"><span class="comment">     *         return value.equals(searchString);</span></span><br><span class="line"><span class="comment">     *     &#125;</span></span><br><span class="line"><span class="comment">     * &#125;</span></span><br><span class="line"><span class="comment">     * &#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;By default, this method does nothing.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parameters The configuration containing the parameters attached to the contract.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception Implementations may forward exceptions, which are caught by the runtime.</span></span><br><span class="line"><span class="comment">     *     When the runtime catches an exception, it aborts the task and lets the fail-over logic</span></span><br><span class="line"><span class="comment">     *     decide whether to retry the task execution.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> org.apache.flink.configuration.Configuration</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tear-down method for the user code. It is called after the last call to the main working</span></span><br><span class="line"><span class="comment">     * methods (e.g. &lt;i&gt;map&lt;/i&gt; or &lt;i&gt;join&lt;/i&gt;). For functions that are part of an iteration, this</span></span><br><span class="line"><span class="comment">     * method will be invoked after each iteration superstep.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This method can be used for clean up work.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception Implementations may forward exceptions, which are caught by the runtime.</span></span><br><span class="line"><span class="comment">     *     When the runtime catches an exception, it aborts the task and lets the fail-over logic</span></span><br><span class="line"><span class="comment">     *     decide whether to retry the task execution.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">//  Runtime context</span></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets the context that contains information about the UDF&#x27;s runtime, such as the parallelism</span></span><br><span class="line"><span class="comment">     * of the function, the subtask index of the function, or the name of the task that executes the</span></span><br><span class="line"><span class="comment">     * function.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The RuntimeContext also gives access to the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * org.apache.flink.api.common.accumulators.Accumulator&#125;s and the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * org.apache.flink.api.common.cache.DistributedCache&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The UDF&#x27;s runtime context.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">RuntimeContext <span class="title">getRuntimeContext</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets a specialized version of the &#123;<span class="doctag">@link</span> RuntimeContext&#125;, which has additional information</span></span><br><span class="line"><span class="comment">     * about the iteration in which the function is executed. This IterationRuntimeContext is only</span></span><br><span class="line"><span class="comment">     * available if the function is part of an iteration. Otherwise, this method throws an</span></span><br><span class="line"><span class="comment">     * exception.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The IterationRuntimeContext.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> java.lang.IllegalStateException Thrown, if the function is not executed as part of an</span></span><br><span class="line"><span class="comment">     *     iteration.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">IterationRuntimeContext <span class="title">getIterationRuntimeContext</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the function&#x27;s runtime context. Called by the framework when creating a parallel</span></span><br><span class="line"><span class="comment">     * instance of the function.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t The runtime context.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRuntimeContext</span><span class="params">(RuntimeContext t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    DataStreamSource&lt;Event&gt; clicks = env.fromElements(</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./cart&quot;</span>, <span class="number">2000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod?id=1&quot;</span>, <span class="number">5</span> * <span class="number">1000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Cary&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">60</span> * <span class="number">1000L</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将点击事件转换成长整型的时间戳输出</span></span><br><span class="line">    clicks.map(<span class="keyword">new</span> RichMapFunction&lt;Event, Long&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">super</span>.open(parameters);</span><br><span class="line">                    System.out.println(<span class="string">&quot;索引为 &quot;</span> + getRuntimeContext().getIndexOfThisSubtask() + <span class="string">&quot; 的任务开始&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Long <span class="title">map</span><span class="params">(Event value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> value.timestamp;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">super</span>.close();</span><br><span class="line">                    System.out.println(<span class="string">&quot;索引为 &quot;</span> + getRuntimeContext().getIndexOfThisSubtask() + <span class="string">&quot; 的任务结束&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    DataStreamSource&lt;Event&gt; stream = env.fromElements(</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./cart&quot;</span>, <span class="number">2000L</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    stream.flatMap(<span class="keyword">new</span> MyFlatMap()).print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFlatMap</span> <span class="keyword">implements</span> <span class="title">FlatMapFunction</span>&lt;<span class="title">Event</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(Event value, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value.user.equals(<span class="string">&quot;Mary&quot;</span>)) &#123;</span><br><span class="line">            out.collect(value.user);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value.user.equals(<span class="string">&quot;Bob&quot;</span>)) &#123;</span><br><span class="line">            out.collect(value.user);</span><br><span class="line">            out.collect(value.url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    DataStreamSource&lt;Event&gt; stream = env.fromElements(</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./cart&quot;</span>, <span class="number">2000L</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传入匿名类实现FilterFunction</span></span><br><span class="line">    stream.filter(<span class="keyword">new</span> FilterFunction&lt;Event&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(Event e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> e.user.equals(<span class="string">&quot;Mary&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传入FilterFunction实现类</span></span><br><span class="line">    stream.filter(<span class="keyword">new</span> UserFilter()).print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserFilter</span> <span class="keyword">implements</span> <span class="title">FilterFunction</span>&lt;<span class="title">Event</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(Event e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> e.user.equals(<span class="string">&quot;Mary&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><p><strong>说明：1、只能操作两个流    2、两个流可以是不同类型</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.获取执行环境</span></span><br><span class="line">StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.读取端口数据创建流</span></span><br><span class="line">DataStreamSource&lt;String&gt; stringDS = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">1234</span>);</span><br><span class="line">DataStreamSource&lt;String&gt; socketTextStream2 = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">4321</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.将socketTextStream2转换为Int类型</span></span><br><span class="line">SingleOutputStreamOperator&lt;Integer&gt; intDS = socketTextStream2.map(String::length);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.连接两个流</span></span><br><span class="line">ConnectedStreams&lt;String, Integer&gt; connectedStreams = stringDS.connect(intDS);</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.处理连接之后的流</span></span><br><span class="line">SingleOutputStreamOperator&lt;Object&gt; result = connectedStreams.map(<span class="keyword">new</span> CoMapFunction&lt;String, Integer, Object&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">map1</span><span class="params">(String value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">map2</span><span class="params">(Integer value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.打印数据</span></span><br><span class="line">result.print();</span><br><span class="line"></span><br><span class="line"><span class="comment">//7.执行</span></span><br><span class="line">env.execute();</span><br></pre></td></tr></table></figure>

<h3 id="union"><a href="#union" class="headerlink" title="union"></a>union</h3><p><strong>说明：1、可以操作多个流    2、多个流必须是同类型</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.获取执行环境</span></span><br><span class="line">StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.读取端口数据创建流</span></span><br><span class="line">DataStreamSource&lt;String&gt; socketTextStream1 = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">1234</span>);</span><br><span class="line">DataStreamSource&lt;String&gt; socketTextStream2 = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">4321</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.连接两条流</span></span><br><span class="line">DataStream&lt;String&gt; union = socketTextStream1.union(socketTextStream2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.打印</span></span><br><span class="line">union.print();</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.执行任务</span></span><br><span class="line">env.execute();</span><br></pre></td></tr></table></figure>

<h3 id="max-maxBy"><a href="#max-maxBy" class="headerlink" title="max/maxBy"></a>max/maxBy</h3><p>max：取指定字段的当前的最大值，如果有多个字段，其他非比较字段，以第一条为准。</p>
<p>maxBy：取指定字段的当前的最大值，如果有多个字段，其他字段以最大值那条数据为准。另外，maxBy有第二个的参数，用来确定当比较字段出现相同时，返回之前的还是现在的，默认返回之前的，设置为false则返回新的，设置为true返回之前的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.获取执行环境</span></span><br><span class="line">StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.读取端口数据并转换为JavaBean</span></span><br><span class="line">SingleOutputStreamOperator&lt;WaterSensor&gt; waterSensorDS = env.socketTextStream(<span class="string">&quot;linux1&quot;</span>, <span class="number">9999</span>)</span><br><span class="line">        .map(<span class="keyword">new</span> MapFunction&lt;String, WaterSensor&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> WaterSensor <span class="title">map</span><span class="params">(String value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                String[] split = value.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> WaterSensor(split[<span class="number">0</span>],</span><br><span class="line">                        Long.parseLong(split[<span class="number">1</span>]),</span><br><span class="line">                        Integer.parseInt(split[<span class="number">2</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.按照传感器ID分组</span></span><br><span class="line">KeyedStream&lt;WaterSensor, String&gt; keyedStream = waterSensorDS.keyBy(<span class="keyword">new</span> KeySelector&lt;WaterSensor, String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getKey</span><span class="params">(WaterSensor value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value.getId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.计算最高水位线</span></span><br><span class="line"><span class="comment">//SingleOutputStreamOperator&lt;WaterSensor&gt; result = keyedStream.max(&quot;vc&quot;);</span></span><br><span class="line">SingleOutputStreamOperator&lt;WaterSensor&gt; result = keyedStream.maxBy(<span class="string">&quot;vc&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.打印</span></span><br><span class="line">result.print();</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.执行任务</span></span><br><span class="line">env.execute();</span><br></pre></td></tr></table></figure>

<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取PV最大的user数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的使用了之前自定义数据源小节中的ClickSource()</span></span><br><span class="line">    env.addSource(<span class="keyword">new</span> ClickSource())</span><br><span class="line">            <span class="comment">// 将Event数据类型转换成元组类型</span></span><br><span class="line">            .map(<span class="keyword">new</span> MapFunction&lt;Event, Tuple2&lt;String, Long&gt;&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Tuple2&lt;String, Long&gt; <span class="title">map</span><span class="params">(Event e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> Tuple2.of(e.user, <span class="number">1L</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .keyBy(r -&gt; r.f0) <span class="comment">// 使用用户名来进行分流</span></span><br><span class="line">            .reduce(<span class="keyword">new</span> ReduceFunction&lt;Tuple2&lt;String, Long&gt;&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Tuple2&lt;String, Long&gt; <span class="title">reduce</span><span class="params">(Tuple2&lt;String, Long&gt; value1, Tuple2&lt;String, Long&gt; value2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="comment">// 每到一条数据，用户pv的统计值加1</span></span><br><span class="line">                    <span class="keyword">return</span> Tuple2.of(value1.f0, value1.f1 + value2.f1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .keyBy(r -&gt; <span class="keyword">true</span>) <span class="comment">// 为每一条数据分配同一个key，将聚合结果发送到一条流中去</span></span><br><span class="line">            .reduce(<span class="keyword">new</span> ReduceFunction&lt;Tuple2&lt;String, Long&gt;&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Tuple2&lt;String, Long&gt; <span class="title">reduce</span><span class="params">(Tuple2&lt;String, Long&gt; value1, Tuple2&lt;String, Long&gt; value2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="comment">// 将累加器更新为当前最大的pv统计值，然后向下游发送累加器的值</span></span><br><span class="line">                    <span class="keyword">return</span> value1.f1 &gt; value2.f1 ? value1 : value2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="returnType"><a href="#returnType" class="headerlink" title="returnType"></a>returnType</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    DataStreamSource&lt;Event&gt; clicks = env.fromElements(</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./cart&quot;</span>, <span class="number">2000L</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 想要转换成二元组类型，需要进行以下处理</span></span><br><span class="line">    <span class="comment">// 1) 使用显式的 &quot;.returns(...)&quot;</span></span><br><span class="line">    DataStream&lt;Tuple2&lt;String, Long&gt;&gt; stream3 = clicks</span><br><span class="line">            .map( event -&gt; Tuple2.of(event.user, <span class="number">1L</span>) )</span><br><span class="line">            .returns(Types.TUPLE(Types.STRING, Types.LONG));</span><br><span class="line">    stream3.print();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 使用类来替代Lambda表达式</span></span><br><span class="line">    clicks.map(<span class="keyword">new</span> MyTuple2Mapper())</span><br><span class="line">            .print();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3) 使用匿名类来代替Lambda表达式</span></span><br><span class="line">    clicks.map(<span class="keyword">new</span> MapFunction&lt;Event, Tuple2&lt;String, Long&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Tuple2&lt;String, Long&gt; <span class="title">map</span><span class="params">(Event value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Tuple2.of(value.user, <span class="number">1L</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义MapFunction的实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTuple2Mapper</span> <span class="keyword">implements</span> <span class="title">MapFunction</span>&lt;<span class="title">Event</span>, <span class="title">Tuple2</span>&lt;<span class="title">String</span>, <span class="title">Long</span>&gt;&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Tuple2&lt;String, Long&gt; <span class="title">map</span><span class="params">(Event value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Tuple2.of(value.user, <span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="tupleAggreation"><a href="#tupleAggreation" class="headerlink" title="tupleAggreation"></a>tupleAggreation</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">		DataStreamSource&lt;Tuple2&lt;String, Integer&gt;&gt; stream = env.fromElements(</span><br><span class="line">                Tuple2.of(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>),</span><br><span class="line">                Tuple2.of(<span class="string">&quot;a&quot;</span>, <span class="number">3</span>),</span><br><span class="line">                Tuple2.of(<span class="string">&quot;a&quot;</span>, <span class="number">2</span>),</span><br><span class="line">                Tuple2.of(<span class="string">&quot;b&quot;</span>, <span class="number">3</span>),</span><br><span class="line">                Tuple2.of(<span class="string">&quot;b&quot;</span>, <span class="number">4</span>),</span><br><span class="line">                Tuple2.of(<span class="string">&quot;b&quot;</span>, <span class="number">1</span>)</span><br><span class="line">		);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  stream.keyBy(r -&gt; r.f0).sum(1).print();</span></span><br><span class="line">    <span class="comment">//  stream.keyBy(r -&gt; r.f0).sum(&quot;f1&quot;).print();</span></span><br><span class="line">    <span class="comment">//  stream.keyBy(r -&gt; r.f0).max(1).print();</span></span><br><span class="line">    <span class="comment">//  stream.keyBy(r -&gt; r.f0).max(&quot;f1&quot;).print();</span></span><br><span class="line">    <span class="comment">//  stream.keyBy(r -&gt; r.f0).min(1).print();</span></span><br><span class="line">    <span class="comment">//  stream.keyBy(r -&gt; r.f0).min(&quot;f1&quot;).print();</span></span><br><span class="line">    <span class="comment">//  stream.keyBy(r -&gt; r.f0).maxBy(1).print();</span></span><br><span class="line">    <span class="comment">//  stream.keyBy(r -&gt; r.f0).maxBy(&quot;f1&quot;).print();</span></span><br><span class="line">    <span class="comment">//  stream.keyBy(r -&gt; r.f0).minBy(1).print();</span></span><br><span class="line">    stream.keyBy(r -&gt; r.f0).minBy(<span class="string">&quot;f1&quot;</span>).print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="process"><a href="#process" class="headerlink" title="process"></a>process</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.获取执行环境</span></span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.读取端口数据</span></span><br><span class="line">    DataStreamSource&lt;String&gt; socketTextStream = env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">1234</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.使用Process实现压平功能</span></span><br><span class="line">    SingleOutputStreamOperator&lt;String&gt; wordDS = socketTextStream.process(<span class="keyword">new</span> ProcessFlatMapFunc());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.使用Process实现Map功能</span></span><br><span class="line">    SingleOutputStreamOperator&lt;Tuple2&lt;String, Integer&gt;&gt; wordToOneDS = wordDS.process(<span class="keyword">new</span> ProcessMapFunc());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.按照单词分组</span></span><br><span class="line">    KeyedStream&lt;Tuple2&lt;String, Integer&gt;, String&gt; keyedStream = wordToOneDS.keyBy(data -&gt; data.f0);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.计算总和</span></span><br><span class="line">    SingleOutputStreamOperator&lt;Tuple2&lt;String, Integer&gt;&gt; result = keyedStream.sum(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.打印</span></span><br><span class="line">    result.print();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8.执行任务</span></span><br><span class="line">    env.execute();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessFlatMapFunc</span> <span class="keyword">extends</span> <span class="title">ProcessFunction</span>&lt;<span class="title">String</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生命周期方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(String value, Context ctx, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//运行时上下文,状态编程</span></span><br><span class="line">        RuntimeContext runtimeContext = getRuntimeContext();</span><br><span class="line"></span><br><span class="line">        String[] words = value.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            out.collect(word);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定时器</span></span><br><span class="line">        TimerService timerService = ctx.timerService();</span><br><span class="line">        timerService.registerProcessingTimeTimer(<span class="number">1245L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取当前处理数据的时间</span></span><br><span class="line">        timerService.currentProcessingTime();</span><br><span class="line">        timerService.currentWatermark();  <span class="comment">//事件时间</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//侧输出流</span></span><br><span class="line">        <span class="comment">//ctx.output();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessMapFunc</span> <span class="keyword">extends</span> <span class="title">ProcessFunction</span>&lt;<span class="title">String</span>, <span class="title">Tuple2</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(String value, Context ctx, Collector&lt;Tuple2&lt;String, Integer&gt;&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        out.collect(<span class="keyword">new</span> Tuple2&lt;&gt;(value, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="physicalPartitioning"><a href="#physicalPartitioning" class="headerlink" title="physicalPartitioning"></a>physicalPartitioning</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 创建执行环境</span></span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    DataStreamSource&lt;Event&gt; stream = env.fromElements(<span class="keyword">new</span> Event(<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./cart&quot;</span>, <span class="number">2000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod?id=100&quot;</span>, <span class="number">3000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod?id=200&quot;</span>, <span class="number">3500L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./prod?id=2&quot;</span>, <span class="number">2500L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod?id=300&quot;</span>, <span class="number">3600L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">3000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./prod?id=1&quot;</span>, <span class="number">2300L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./prod?id=3&quot;</span>, <span class="number">3300L</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 随机分区</span></span><br><span class="line">    stream.shuffle().print(<span class="string">&quot;shuffle&quot;</span>).setParallelism(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 轮询分区</span></span><br><span class="line">    stream.rebalance().print(<span class="string">&quot;rebalance&quot;</span>).setParallelism(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. rescale重缩放分区</span></span><br><span class="line">    env.addSource(<span class="keyword">new</span> RichParallelSourceFunction&lt;Integer&gt;() &#123;  <span class="comment">// 这里使用了并行数据源的富函数版本</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(SourceContext&lt;Integer&gt; sourceContext)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; i++) &#123;</span><br><span class="line">                        <span class="comment">// 将奇数发送到索引为1的并行子任务</span></span><br><span class="line">                        <span class="comment">// 将偶数发送到索引为0的并行子任务</span></span><br><span class="line">                        <span class="keyword">if</span> ( i % <span class="number">2</span> == getRuntimeContext().getIndexOfThisSubtask()) &#123;</span><br><span class="line">                            sourceContext.collect(i);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .setParallelism(<span class="number">2</span>)</span><br><span class="line">            .rescale()</span><br><span class="line">            .print().setParallelism(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 广播</span></span><br><span class="line">    stream.broadcast().print(<span class="string">&quot;broadcast&quot;</span>).setParallelism(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 全局分区</span></span><br><span class="line">    stream.global().print(<span class="string">&quot;global&quot;</span>).setParallelism(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 自定义重分区</span></span><br><span class="line">    <span class="comment">// 将自然数按照奇偶分区</span></span><br><span class="line">    env.fromElements(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line">            .partitionCustom(<span class="keyword">new</span> Partitioner&lt;Integer&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(Integer key, <span class="keyword">int</span> numPartitions)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> key % <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="keyword">new</span> KeySelector&lt;Integer, Integer&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Integer <span class="title">getKey</span><span class="params">(Integer value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .print().setParallelism(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PojoAggregation"><a href="#PojoAggregation" class="headerlink" title="PojoAggregation"></a>PojoAggregation</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    DataStreamSource&lt;Event&gt; stream = env.fromElements(</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./cart&quot;</span>, <span class="number">2000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;./cart&quot;</span>, <span class="number">3000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;./fav&quot;</span>, <span class="number">4000L</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    stream.keyBy(e -&gt; e.user)</span><br><span class="line">            <span class="comment">//.maxBy(&quot;timestamp&quot;)</span></span><br><span class="line">            .max(<span class="string">&quot;timestamp&quot;</span>)    <span class="comment">// 指定字段名称</span></span><br><span class="line">            .print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="udf"><a href="#udf" class="headerlink" title="udf"></a>udf</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    DataStreamSource&lt;Event&gt; clicks = env.fromElements(</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./cart&quot;</span>, <span class="number">2000L</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 传入实现FilterFunction接口的自定义函数类</span></span><br><span class="line">    DataStream&lt;Event&gt; stream1 = clicks.filter(<span class="keyword">new</span> FlinkFilter());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传入属性字段</span></span><br><span class="line">    DataStream&lt;Event&gt; stream2 = clicks.filter(<span class="keyword">new</span> KeyWordFilter(<span class="string">&quot;home&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 传入匿名类</span></span><br><span class="line">    DataStream&lt;Event&gt; stream3 = clicks.filter(<span class="keyword">new</span> FilterFunction&lt;Event&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(Event value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value.url.contains(<span class="string">&quot;home&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 传入Lambda表达式</span></span><br><span class="line">    SingleOutputStreamOperator&lt;Event&gt; stream4 = clicks.filter(data -&gt; data.url.contains(<span class="string">&quot;home&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//        stream1.print();</span></span><br><span class="line"><span class="comment">//        stream2.print();</span></span><br><span class="line"><span class="comment">//        stream3.print();</span></span><br><span class="line">    stream4.print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FlinkFilter</span> <span class="keyword">implements</span> <span class="title">FilterFunction</span>&lt;<span class="title">Event</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(Event value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value.url.contains(<span class="string">&quot;home&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyWordFilter</span> <span class="keyword">implements</span> <span class="title">FilterFunction</span>&lt;<span class="title">Event</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String keyWord;</span><br><span class="line"></span><br><span class="line">    KeyWordFilter(String keyWord) &#123; <span class="keyword">this</span>.keyWord = keyWord; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(Event value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value.url.contains(<span class="keyword">this</span>.keyWord);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Sink"><a href="#Sink" class="headerlink" title="Sink"></a>Sink</h2><h3 id="kafka-1"><a href="#kafka-1" class="headerlink" title="kafka"></a>kafka</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">    properties.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;hadoop102:9092&quot;</span>);</span><br><span class="line"></span><br><span class="line">    DataStreamSource&lt;String&gt; stream = env.readTextFile(<span class="string">&quot;input/clicks.csv&quot;</span>);</span><br><span class="line"></span><br><span class="line">    stream</span><br><span class="line">            .addSink(<span class="keyword">new</span> FlinkKafkaProducer&lt;String&gt;(</span><br><span class="line">                    <span class="string">&quot;clicks&quot;</span>,</span><br><span class="line">                    <span class="keyword">new</span> SimpleStringSchema(),</span><br><span class="line">                    properties</span><br><span class="line">            ));</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自定义source</span></span><br><span class="line">    DataStreamSource&lt;Event&gt; stream = env.addSource(<span class="keyword">new</span> ClickSource());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个到redis连接的配置</span></span><br><span class="line">    FlinkJedisPoolConfig conf = <span class="keyword">new</span> FlinkJedisPoolConfig.Builder()</span><br><span class="line">            .setHost(<span class="string">&quot;hadoop102&quot;</span>)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    stream.addSink(<span class="keyword">new</span> RedisSink&lt;Event&gt;(conf, <span class="keyword">new</span> MyRedisMapper()));</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRedisMapper</span> <span class="keyword">implements</span> <span class="title">RedisMapper</span>&lt;<span class="title">Event</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisCommandDescription <span class="title">getCommandDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RedisCommandDescription(RedisCommand.HSET, <span class="string">&quot;clicks&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getKeyFromData</span><span class="params">(Event data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValueFromData</span><span class="params">(Event data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.url;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClickSource</span> <span class="keyword">implements</span> <span class="title">SourceFunction</span>&lt;<span class="title">Event</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 声明一个布尔变量，作为控制数据生成的标识位</span></span><br><span class="line">    <span class="keyword">private</span> Boolean running = <span class="keyword">true</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(SourceContext&lt;Event&gt; ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();    <span class="comment">// 在指定的数据集中随机选取数据</span></span><br><span class="line">        String[] users = &#123;<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Cary&quot;</span>&#125;;</span><br><span class="line">        String[] urls = &#123;<span class="string">&quot;./home&quot;</span>, <span class="string">&quot;./cart&quot;</span>, <span class="string">&quot;./fav&quot;</span>, <span class="string">&quot;./prod?id=1&quot;</span>, <span class="string">&quot;./prod?id=2&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            ctx.collect(<span class="keyword">new</span> Event(</span><br><span class="line">                    users[random.nextInt(users.length)],</span><br><span class="line">                    urls[random.nextInt(urls.length)],</span><br><span class="line">                    Calendar.getInstance().getTimeInMillis()</span><br><span class="line">            ));</span><br><span class="line">            <span class="comment">// 隔1秒生成一个点击事件，方便观测</span></span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        running = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="elasticsearch"><a href="#elasticsearch" class="headerlink" title="elasticsearch"></a>elasticsearch</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    DataStreamSource&lt;Event&gt; stream = env.fromElements(</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./cart&quot;</span>, <span class="number">2000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod?id=100&quot;</span>, <span class="number">3000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod?id=200&quot;</span>, <span class="number">3500L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./prod?id=2&quot;</span>, <span class="number">2500L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod?id=300&quot;</span>, <span class="number">3600L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">3000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./prod?id=1&quot;</span>, <span class="number">2300L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./prod?id=3&quot;</span>, <span class="number">3300L</span>));</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;HttpHost&gt; httpHosts = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    httpHosts.add(<span class="keyword">new</span> HttpHost(<span class="string">&quot;hadoop102&quot;</span>, <span class="number">9200</span>, <span class="string">&quot;http&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个ElasticsearchSinkFunction</span></span><br><span class="line">    ElasticsearchSinkFunction&lt;Event&gt; elasticsearchSinkFunction = <span class="keyword">new</span> ElasticsearchSinkFunction&lt;Event&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Event element, RuntimeContext ctx, RequestIndexer indexer)</span> </span>&#123;</span><br><span class="line">            HashMap&lt;String, String&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            data.put(element.user, element.url);</span><br><span class="line"></span><br><span class="line">            IndexRequest request = Requests.indexRequest()</span><br><span class="line">                    .index(<span class="string">&quot;clicks&quot;</span>)</span><br><span class="line">                    .type(<span class="string">&quot;type&quot;</span>)    <span class="comment">// Es 6 必须定义 type</span></span><br><span class="line">                    .source(data);</span><br><span class="line"></span><br><span class="line">            indexer.add(request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    stream.addSink(<span class="keyword">new</span> ElasticsearchSink.Builder&lt;Event&gt;(httpHosts, elasticsearchSinkFunction).build());</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="jdbc"><a href="#jdbc" class="headerlink" title="jdbc"></a>jdbc</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.获取执行环境</span></span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.读取端口数据并转换为JavaBean</span></span><br><span class="line">    SingleOutputStreamOperator&lt;WaterSensor&gt; waterSensorDS = env.socketTextStream(<span class="string">&quot;linux1&quot;</span>, <span class="number">9999</span>)</span><br><span class="line">            .map(<span class="keyword">new</span> MapFunction&lt;String, WaterSensor&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> WaterSensor <span class="title">map</span><span class="params">(String value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    String[] split = value.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> WaterSensor(split[<span class="number">0</span>],</span><br><span class="line">                            Long.parseLong(split[<span class="number">1</span>]),</span><br><span class="line">                            Integer.parseInt(split[<span class="number">2</span>]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.将数据写入MySQL</span></span><br><span class="line">    waterSensorDS.addSink(JdbcSink.sink(</span><br><span class="line">            <span class="string">&quot;INSERT INTO `sensor-0821` VALUES(?,?,?) ON DUPLICATE KEY UPDATE `ts`=?,`vc`=?&quot;</span>,</span><br><span class="line">            <span class="keyword">new</span> JdbcStatementBuilder&lt;WaterSensor&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(PreparedStatement preparedStatement, WaterSensor waterSensor)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">                    <span class="comment">//给占位符赋值</span></span><br><span class="line">                    preparedStatement.setString(<span class="number">1</span>, waterSensor.getId());</span><br><span class="line">                    preparedStatement.setLong(<span class="number">2</span>, waterSensor.getTs());</span><br><span class="line">                    preparedStatement.setInt(<span class="number">3</span>, waterSensor.getVc());</span><br><span class="line">                    preparedStatement.setLong(<span class="number">4</span>, waterSensor.getTs());</span><br><span class="line">                    preparedStatement.setInt(<span class="number">5</span>, waterSensor.getVc());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            JdbcExecutionOptions.builder()</span><br><span class="line">                    .withBatchSize(<span class="number">1</span>)</span><br><span class="line">                    .build(),</span><br><span class="line">            <span class="keyword">new</span> JdbcConnectionOptions.JdbcConnectionOptionsBuilder()</span><br><span class="line">                    .withUrl(<span class="string">&quot;jdbc:mysql://linux1:3306/test?useSSL=false&quot;</span>)</span><br><span class="line">                    .withDriverName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>)</span><br><span class="line">                    .withUsername(<span class="string">&quot;root&quot;</span>)</span><br><span class="line">                    .withPassword(<span class="string">&quot;000000&quot;</span>)</span><br><span class="line">                    .build()</span><br><span class="line">    ));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.执行任务</span></span><br><span class="line">    env.execute();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    DataStreamSource&lt;Event&gt; stream = env.fromElements(</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./cart&quot;</span>, <span class="number">2000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod?id=100&quot;</span>, <span class="number">3000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod?id=200&quot;</span>, <span class="number">3500L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./prod?id=2&quot;</span>, <span class="number">2500L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod?id=300&quot;</span>, <span class="number">3600L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">3000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./prod?id=1&quot;</span>, <span class="number">2300L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./prod?id=3&quot;</span>, <span class="number">3300L</span>));</span><br><span class="line"></span><br><span class="line">    stream.addSink(</span><br><span class="line">            JdbcSink.sink(</span><br><span class="line">                    <span class="string">&quot;INSERT INTO clicks (user, url) VALUES (?, ?)&quot;</span>,</span><br><span class="line">                    (statement, r) -&gt; &#123;</span><br><span class="line">                        statement.setString(<span class="number">1</span>, r.user);</span><br><span class="line">                        statement.setString(<span class="number">2</span>, r.url);</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="keyword">new</span> JdbcConnectionOptions.JdbcConnectionOptionsBuilder()</span><br><span class="line">                            .withUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>)</span><br><span class="line">                            .withDriverName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>)</span><br><span class="line">                            .withUsername(<span class="string">&quot;root&quot;</span>)</span><br><span class="line">                            .withPassword(<span class="string">&quot;root&quot;</span>)</span><br><span class="line">                            .build()</span><br><span class="line">            )</span><br><span class="line">    );</span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="file-1"><a href="#file-1" class="headerlink" title="file"></a>file</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    DataStream&lt;Event&gt; stream = env.fromElements(<span class="keyword">new</span> Event(<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./cart&quot;</span>, <span class="number">2000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod?id=100&quot;</span>, <span class="number">3000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod?id=200&quot;</span>, <span class="number">3500L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./prod?id=2&quot;</span>, <span class="number">2500L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod?id=300&quot;</span>, <span class="number">3600L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">3000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./prod?id=1&quot;</span>, <span class="number">2300L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./prod?id=3&quot;</span>, <span class="number">3300L</span>));</span><br><span class="line"></span><br><span class="line">    StreamingFileSink&lt;String&gt; fileSink = StreamingFileSink</span><br><span class="line">            .&lt;String&gt;forRowFormat(<span class="keyword">new</span> Path(<span class="string">&quot;./output&quot;</span>),</span><br><span class="line">                    <span class="keyword">new</span> SimpleStringEncoder&lt;&gt;(<span class="string">&quot;UTF-8&quot;</span>))</span><br><span class="line">            .withRollingPolicy(</span><br><span class="line">                    DefaultRollingPolicy.builder()</span><br><span class="line">                            .withRolloverInterval(TimeUnit.MINUTES.toMillis(<span class="number">15</span>))</span><br><span class="line">                            .withInactivityInterval(TimeUnit.MINUTES.toMillis(<span class="number">5</span>))</span><br><span class="line">                            .withMaxPartSize(<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">1024</span>)</span><br><span class="line">                            .build())</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将Event转换成String写入文件</span></span><br><span class="line">    stream.map(Event::toString).addSink(fileSink);</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="custome-sink"><a href="#custome-sink" class="headerlink" title="custome_sink"></a>custome_sink</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.获取执行环境</span></span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.读取端口数据并转换为JavaBean</span></span><br><span class="line">    SingleOutputStreamOperator&lt;WaterSensor&gt; waterSensorDS = env.socketTextStream(<span class="string">&quot;linux1&quot;</span>, <span class="number">9999</span>)</span><br><span class="line">            .map(<span class="keyword">new</span> MapFunction&lt;String, WaterSensor&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> WaterSensor <span class="title">map</span><span class="params">(String value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    String[] split = value.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> WaterSensor(split[<span class="number">0</span>],</span><br><span class="line">                            Long.parseLong(split[<span class="number">1</span>]),</span><br><span class="line">                            Integer.parseInt(split[<span class="number">2</span>]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.将数据写入Mysql</span></span><br><span class="line">    waterSensorDS.addSink(<span class="keyword">new</span> MySink());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.执行任务</span></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MySink</span> <span class="keyword">extends</span> <span class="title">RichSinkFunction</span>&lt;<span class="title">WaterSensor</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明连接</span></span><br><span class="line">    <span class="keyword">private</span> Connection connection;</span><br><span class="line">    <span class="keyword">private</span> PreparedStatement preparedStatement;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生命周期方法,用于创建连接</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        connection = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://linux1:3306/test?useSSL=false&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;000000&quot;</span>);</span><br><span class="line">        preparedStatement = connection.prepareStatement(<span class="string">&quot;INSERT INTO `sensor-0821` VALUES(?,?,?) ON DUPLICATE KEY UPDATE `ts`=?,`vc`=?&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(WaterSensor value, Context context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给占位符赋值</span></span><br><span class="line">        preparedStatement.setString(<span class="number">1</span>, value.getId());</span><br><span class="line">        preparedStatement.setLong(<span class="number">2</span>, value.getTs());</span><br><span class="line">        preparedStatement.setInt(<span class="number">3</span>, value.getVc());</span><br><span class="line">        preparedStatement.setLong(<span class="number">4</span>, value.getTs());</span><br><span class="line">        preparedStatement.setInt(<span class="number">5</span>, value.getVc());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行操作</span></span><br><span class="line">        preparedStatement.execute();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生命周期方法,用于关闭连接</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        preparedStatement.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h2><h3 id="时间窗口-Time-Window"><a href="#时间窗口-Time-Window" class="headerlink" title="时间窗口(Time Window)"></a>时间窗口(Time Window)</h3><p>时间窗口以时间点来定义窗口的开始(start)和结束(end)，所以截取出的就是某一时间段的数据。到达结束时间时，窗口不再收集数据，触发计算输出结果，并将窗口关闭销毁。</p>
<p>Flink 中有一个专门的类来表示时间窗口，名称就叫作 TimeWindow。这个类只有两个私有属性：start 和 end，表示窗口的开始和结束的时间戳，单位为<strong>毫秒</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> start;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> end;</span><br></pre></td></tr></table></figure>

<p>我们可以调用公有的 getStart() 和 getEnd() 方法直接获取这两个时间戳。另外，TimeWindow 还提供了一个 maxTimestamp()方法，用来获取窗口中能够包含数据的最大时间戳。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">maxTimestamp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> end - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显，窗口中的数据，最大允许的时间戳就是end - 1，这也就代表了我们定义的窗口时间范围都是左闭右开的区间[start，end)。</p>
<h4 id="TimeTumbling"><a href="#TimeTumbling" class="headerlink" title="TimeTumbling"></a>TimeTumbling</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理时间</span></span><br><span class="line">stream.keyBy(...)</span><br><span class="line">      .window(TumblingProcessingTimeWindows.of(Time.seconds(<span class="number">5</span>)))</span><br><span class="line">      .aggregate(...)</span><br><span class="line"><span class="comment">//北京时间0点</span></span><br><span class="line">.window(TumblingProcessingTimeWindows.of(Time.days(<span class="number">1</span>), Time.hours(-<span class="number">8</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">//事件时间</span></span><br><span class="line">stream.keyBy(...)</span><br><span class="line">      .window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">5</span>)))</span><br><span class="line">      .aggregate(...)</span><br></pre></td></tr></table></figure>

<h4 id="TimeSliding"><a href="#TimeSliding" class="headerlink" title="TimeSliding"></a>TimeSliding</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个长度为 10 秒、滑动步长为 5 秒</span></span><br><span class="line"><span class="comment">//处理时间</span></span><br><span class="line">stream.keyBy(...)</span><br><span class="line">      .window(SlidingProcessingTimeWindows.of(Time.seconds(<span class="number">10</span>), Time.seconds(<span class="number">5</span>)))</span><br><span class="line">      .aggregate(...)</span><br><span class="line"></span><br><span class="line"><span class="comment">//事件时间</span></span><br><span class="line">stream.keyBy(...)</span><br><span class="line">      .window(SlidingEventTimeWindows.of(Time.seconds(<span class="number">10</span>), Time.seconds(<span class="number">5</span>)))</span><br><span class="line">      .aggregate(...)</span><br></pre></td></tr></table></figure>

<h4 id="TimeSession"><a href="#TimeSession" class="headerlink" title="TimeSession"></a>TimeSession</h4><p>窗口分配器由类 ProcessingTimeSessionWindows 提供，需要调用它的静态方法.withGap()或者.withDynamicGap()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态会话超时时间为 10 秒的会话窗口</span></span><br><span class="line"><span class="comment">//处理时间</span></span><br><span class="line">stream.keyBy(...)</span><br><span class="line">      .window(ProcessingTimeSessionWindows.withGap(Time.seconds(<span class="number">10</span>)))</span><br><span class="line">      .aggregate(...)</span><br><span class="line"></span><br><span class="line"><span class="comment">//事件时间</span></span><br><span class="line">stream.keyBy(...)</span><br><span class="line">      .window(EventTimeSessionWindows.withGap(Time.seconds(<span class="number">10</span>)))</span><br><span class="line">      .aggregate(...)</span><br></pre></td></tr></table></figure>

<p>这里.withDynamicGap()方法需要传入一个 SessionWindowTimeGapExtractor 作为参数，用来<strong>定义session gap的动态提取逻辑</strong>。在这里，我们提取了数据元素的第一个字段，用它的长度乘以 1000 作为会话超时的间隔。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">stream.keyBy(...)</span><br><span class="line">      .window(ProcessingTimeSessionWindows.withDynamicGap(</span><br><span class="line">        <span class="keyword">new</span> SessionWindowTimeGapExtractor&lt;Tuple2&lt;String, Long&gt;&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extract</span><span class="params">(Tuple2&lt;String, Long&gt; element)</span> </span>&#123;</span><br><span class="line">                    <span class="comment">// 提取 session gap 值返回, 单位毫秒 </span></span><br><span class="line">                    <span class="keyword">return</span> element.f0.length() * <span class="number">1000</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">      ).aggregate(...)</span><br></pre></td></tr></table></figure>

<h3 id="计数窗口-Count-Window"><a href="#计数窗口-Count-Window" class="headerlink" title="计数窗口(Count Window)"></a>计数窗口(<strong>Count Window</strong>)</h3><p>计数窗口基于元素的个数来截取数据，到达固定的个数时就触发计算并关闭窗口。这相当于座位有限、人满就发车，是否发车与时间无关。每个窗口截取数据的个数，就是窗口的大小。</p>
<h4 id="CountTumbling"><a href="#CountTumbling" class="headerlink" title="CountTumbling"></a>CountTumbling</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当窗口中元素数量达到 10 的时候，就会触发计算执行并关闭窗口</span></span><br><span class="line">stream.keyBy(...)</span><br><span class="line">      .countWindow(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<h4 id="CountSliding"><a href="#CountSliding" class="headerlink" title="CountSliding"></a>CountSliding</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//长度为 10、滑动步长为 3 的滑动计数窗口。每个窗口统计 10 个数据，每隔 3 个数据就统计输出一次结果</span></span><br><span class="line">stream.keyBy(...)</span><br><span class="line">      .countWindow(<span class="number">10</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h3 id="全局窗口-Global-Windows"><a href="#全局窗口-Global-Windows" class="headerlink" title="全局窗口(Global Windows)"></a>全局窗口(<strong>Global Windows</strong>)</h3><p>还有一类比较通用的窗口，就是全局窗口。这种窗口全局有效，会<strong>把相同 key 的所有数据都分配到同一个窗口中</strong>；说直白一点，就跟没分窗口一样。无界流的数据永无止尽，所以这种窗口也没有结束的时候，默认是不会做触发计算的。如果希望它能对数据进行计算处理， 还需要**自定义触发器(Trigger)**。Flink 中的计数窗口(Count Window)，底层就是用全局窗口实现的。</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stream.key<span class="constructor">By(<span class="operator">...</span>)</span></span><br><span class="line">      .window(<span class="module-access"><span class="module"><span class="identifier">GlobalWindows</span>.</span></span>create<span class="literal">()</span>);</span><br></pre></td></tr></table></figure>

<h3 id="窗口函数-Window-Functions"><a href="#窗口函数-Window-Functions" class="headerlink" title="窗口函数(Window Functions)"></a>窗口函数(Window Functions)</h3><p><strong>1、按键分区(Keyed)和非按键分区(Non-Keyed)</strong></p>
<p>按键分区窗口(Keyed Windows)：</p>
<p>经过按键分区 keyBy 操作后，数据流会按照 key 被分为多条逻辑流(logical streams)，这就是 KeyedStream。基于 KeyedStream 进行窗口操作时，窗口计算会在多个并行子任务上同时执行。相同 key 的数据会被发送到同一个并行子任务，而窗口操作会基于每个 key 进行单独的处理。所以可以认为，每个 key 上都定义了一组窗口，各自独立地进行统计计算。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stream.keyBy(...)</span><br><span class="line">      .window(...)</span><br></pre></td></tr></table></figure>

<p>非按键分区(Non-Keyed Windows)：</p>
<p>如果没有进行 keyBy，那么原始的 DataStream 就不会分成多条逻辑流。这时窗口逻辑只能在一个任务(task)上执行，就相当于并行度变成了 1。所以在实际应用中一般不推荐使用这种方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream.windowAll(...)</span><br></pre></td></tr></table></figure>

<p><strong>2、代码中窗口 API 的调用</strong></p>
<p>窗口操作主要有两个部分：窗口分配器(Window Assigners)和窗口函数(Window Functions)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stream.keyBy(&lt;key selector&gt;)</span><br><span class="line">      .window(&lt;window assigner&gt;)      <span class="comment">//窗口分配器</span></span><br><span class="line">      .aggregate(&lt;window function&gt;)   <span class="comment">//窗口函数</span></span><br></pre></td></tr></table></figure>

<p>其中.window() 方法需要传入一个窗口分配器，它指明了窗口的类型；而后面的.aggregate()方法传入一个窗口函数作为参数，它用来定义窗口具体的处理逻辑。窗口分配器有各种形式， 而窗口函数的调用方法也不只.aggregate()一种，我们接下来就详细展开讲解。</p>
<p>另外，在实际应用中，一般都需要并行执行任务，非按键分区很少用到，所以我们之后都以按键分区窗口为例；如果想要实现非按键分区窗口，只要前面不做 keyBy，后面调用.window()时直接换成.windowAll()就可以了。</p>
<p>经<strong>窗口分配器</strong>处理之后，数据可以分配到对应的窗口中，而数据流经过转换得到的数据类型是 WindowedStream。这个类型并不是 DataStream，所以并不能直接进行其他转换，而必须进一步调用<strong>窗口函数</strong>，对收集到的数据进行处理计算之后，才能最终再次得到 DataStream。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-03-23%20%E4%B8%8B%E5%8D%883.31.54.png" alt="截屏2022-03-23 下午3.31.54"></p>
<p>窗口函数定义了要对窗口中收集的数据做的计算操作，根据处理的方式可以分为两类：<strong>增量聚合函数</strong>和<strong>全窗口函数</strong>。</p>
<h4 id="增量聚合函数"><a href="#增量聚合函数" class="headerlink" title="增量聚合函数"></a>增量聚合函数</h4><p>就像 DataStream 的简单聚合一样，每来一条数据就立即进行计算，中间只要保持一个简单的聚合状态就可以了；区别只是在于不立即输出结果，而是要等到窗口结束时间。等到窗口到了结束时间需要输出计算结果的时候，我们只需要拿出之前聚合的状态直接输出，这无疑就大大提高了程序运行的效率和实时性。</p>
<p>典型的增量聚合函数有两个：ReduceFunction 和 AggregateFunction。</p>
<h5 id="ReduceFunction"><a href="#ReduceFunction" class="headerlink" title="ReduceFunction"></a>ReduceFunction</h5><p>将窗口中收集到的数据两两进行归约，当我们进行流处理时，就是要保存一个状态；每来一个新的数据，就和之前的聚合状态做归约，这样就实现了增量式的聚合。</p>
<p>代码中我们对每个用户的行为数据进行了开窗统计。与 word count 逻辑类似，首先将数据转换成(user, count)的二元组形式(类型为 Tuple2&lt;String, Long&gt;)，每条数据对应的初始 count 值都是 1；然后按照用户 id 分组，在处理时间下开滚动窗口，统计每 5 秒内的用户行为数量。 对于窗口的计算，我们用 ReduceFunction 对 count 值做了增量聚合：窗口中会将当前的总 count 值保存成一个归约状态，每来一条数据，就会调用内部的 reduce 方法，将新数据中的 count 值叠加到状态上，并得到新的状态保存起来。等到了 5 秒窗口的结束时间，就把归约好的状态直接输出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从自定义数据源读取数据，并提取时间戳、生成水位线</span></span><br><span class="line">    SingleOutputStreamOperator&lt;Event&gt; stream = env.addSource(<span class="keyword">new</span> ClickSource())</span><br><span class="line">                    .assignTimestampsAndWatermarks(WatermarkStrategy.&lt;Event&gt;forBoundedOutOfOrderness(Duration.ZERO)</span><br><span class="line">                    .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Event&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Event element, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> element.timestamp;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;));          </span><br><span class="line"></span><br><span class="line">    stream.map( <span class="keyword">new</span> MapFunction&lt;Event, Tuple2&lt;String, Long&gt;&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> Tuple2&lt;String, Long&gt; <span class="title">map</span><span class="params">(Event value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="comment">// 将数据转换成二元组，方便计算</span></span><br><span class="line">                            <span class="keyword">return</span> Tuple2.of(value.user, <span class="number">1L</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">          )</span><br><span class="line">          .keyBy(r -&gt; r.f0)</span><br><span class="line">          <span class="comment">// 设置滚动事件时间窗口</span></span><br><span class="line">          .window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">5</span>)))</span><br><span class="line">          .reduce(<span class="keyword">new</span> ReduceFunction&lt;Tuple2&lt;String, Long&gt;&gt;() &#123;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> Tuple2&lt;String, Long&gt; <span class="title">reduce</span><span class="params">(Tuple2&lt;String, Long&gt; value1, Tuple2&lt;String, Long&gt; value2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                  <span class="comment">// 定义累加规则，窗口闭合时，向下游发送累加结果</span></span><br><span class="line">                  <span class="keyword">return</span> Tuple2.of(value1.f0, value1.f1 + value2.f1);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">          .print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="AggregateFunction"><a href="#AggregateFunction" class="headerlink" title="AggregateFunction"></a>AggregateFunction</h5><p><strong>ReduceFunction 可以解决大多数归约聚合的问题，但是这个接口有一个限制，就是聚合状态的类型、输出结果的类型都必须和输入数据类型一样。</strong>这就迫使我们必须在聚合前，先将数据转换(map)成预期结果类型；而在有些情况下，还需要对状态进行进一步处理才能得到输出结果，这时它们的类型可能不同，使用 ReduceFunction 就会非常麻烦。</p>
<p>如果我们希望计算一组数据的平均值，应该怎样做聚合呢？很明显，这时我们需要计算两个状态量：数据的总和(sum)，以及数据的个数(count)，而最终输出结果是两者的商 (sum/count)。如果用 ReduceFunction，那么我们应该先把数据转换成二元组(sum, count)的形式，然后进行归约聚合，最后再将元组的两个元素相除转换得到最后的平均值。本来应该只是一个任务，可我们却需要 map-reduce-map 三步操作，这显然不够高效。应该允许让输入数据、中间状态、输出结果三者类型不同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AggregateFunction</span>&lt;<span class="title">IN</span>, <span class="title">ACC</span>, <span class="title">OUT</span>&gt; <span class="keyword">extends</span> <span class="title">Function</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">   <span class="function">ACC <span class="title">createAccumulator</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function">ACC <span class="title">add</span><span class="params">(IN value, ACC accumulator)</span></span>;</span><br><span class="line">   <span class="function">OUT <span class="title">getResult</span><span class="params">(ACC accumulator)</span></span>;</span><br><span class="line">   <span class="function">ACC <span class="title">merge</span><span class="params">(ACC a, ACC b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AggregateFunction 可以看作是 ReduceFunction 的通用版本，这里有三种类型：输入类型 (IN)、累加器类型(ACC)和输出类型(OUT)。输入类型 IN 就是输入流中元素的数据类型；累加器类型 ACC 则是我们进行聚合的中间状态类型；而输出类型当然就是最终计算结果的类型了。</p>
<p>createAccumulator()：创建一个累加器，这就是为聚合创建了一个<strong>初始状态</strong>，每个聚合任务只会<strong>调用一次</strong>。</p>
<p>add()：将输入的元素添加到累加器中。这就是基于聚合状态，对新来的数据进行进一步聚合的过程。方法传入两个参数：当前新到的数据 value，和当前的累加器 accumulator；返回一个新的累加器值，也就是<strong>对聚合状态进行更新</strong>。每条数据到来之后都会调用这个方法。</p>
<p>getResult()：从累加器中提取聚合的输出结果。也就是说，我们可以定义多个状态，然后再基于这些聚合的状态计算出一个结果进行输出。比如之前我们提到的计算平均值，就可以把 sum 和 count 作为状态放入累加器，而在调用这个方法时相除得到最终结果。这个方法只在窗口要输出结果时调用。</p>
<p>merge()：<strong>合并两个累加器</strong>，并将合并后的状态作为一个累加器返回。这个方法只在需要合并窗口的场景下才会被调用；最常见的合并窗口(Merging Window)的场景就是会话窗口(Session Windows)。</p>
<p>AggregateFunction 的工作原理是：首先调用 createAccumulator()为任务初始化一个状态(累加器)；而后每来一个数据就调用一次 add() 方法，对数据进行聚合，得到的结果保存在状态中；等到了窗口需要输出时，再调用 getResult() 方法得到计算结果。很明显，与 ReduceFunction 相同 AggregateFunction 也是增量式的聚合；而由于<strong>输入、中间状态、输出的类型可以不同</strong>，使得应用更加灵活方便。</p>
<p>在电商网站中，PV(页面浏览量) 和 UV(独立访客数) 是非常重要的两个流量指标。一般来说，PV 统计的是所有的点击量；而对用户 id 进行去重之后，得到的就是 UV。所以有时我们会用 PV/UV 这个比值，来表示人均重复访问量，也就是平均每个用户会访问多少次页面，这在一定程度上代表了用户的粘度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    SingleOutputStreamOperator&lt;Event&gt; stream = env.addSource(<span class="keyword">new</span> ClickSource())</span><br><span class="line">            .assignTimestampsAndWatermarks(WatermarkStrategy.&lt;Event&gt;forMonotonousTimestamps()</span><br><span class="line">                    .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Event&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Event element, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> element.timestamp;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所有数据设置相同的key，发送到同一个分区统计PV和UV，再相除</span></span><br><span class="line">    stream.keyBy(data -&gt; <span class="keyword">true</span>)</span><br><span class="line">            .window(SlidingEventTimeWindows.of(Time.seconds(<span class="number">10</span>), Time.seconds(<span class="number">2</span>)))</span><br><span class="line">            .aggregate(<span class="keyword">new</span> AvgPv())</span><br><span class="line">            .print();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AvgPv</span> <span class="keyword">implements</span> <span class="title">AggregateFunction</span>&lt;<span class="title">Event</span>, <span class="title">Tuple2</span>&lt;<span class="title">HashSet</span>&lt;<span class="title">String</span>&gt;, <span class="title">Long</span>&gt;, <span class="title">Double</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Tuple2&lt;HashSet&lt;String&gt;, Long&gt; createAccumulator() &#123;</span><br><span class="line">        <span class="comment">// 创建累加器</span></span><br><span class="line">        <span class="keyword">return</span> Tuple2.of(<span class="keyword">new</span> HashSet&lt;String&gt;(), <span class="number">0L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Tuple2&lt;HashSet&lt;String&gt;, Long&gt; add(Event value, Tuple2&lt;HashSet&lt;String&gt;, Long&gt; accumulator) &#123;</span><br><span class="line">        <span class="comment">// 属于本窗口的数据来一条累加一次，并返回累加器</span></span><br><span class="line">        accumulator.f0.add(value.user);</span><br><span class="line">        <span class="keyword">return</span> Tuple2.of(accumulator.f0, accumulator.f1 + <span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">getResult</span><span class="params">(Tuple2&lt;HashSet&lt;String&gt;, Long&gt; accumulator)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 窗口闭合时，增量聚合结束，将计算结果发送到下游</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">double</span>) accumulator.f1 / accumulator.f0.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Tuple2&lt;HashSet&lt;String&gt;, Long&gt; merge(Tuple2&lt;HashSet&lt;String&gt;, Long&gt; a, Tuple2&lt;HashSet&lt;String&gt;, Long&gt; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="全窗口函数"><a href="#全窗口函数" class="headerlink" title="全窗口函数"></a>全窗口函数</h4><p>窗口操作中的另一大类就是全窗口函数。与增量聚合函数不同，全窗口函数需要先收集窗口中的数据，并在内部缓存起来，等到窗口要输出结果的时候再取出数据进行计算。</p>
<p>为什么还需要有全窗口函数呢？这是因为有些场景下，我们要做的计算必须基于全部的数据才有效，这时做增量聚合就没什么意义了；另外，输出的结果有可能要包含上下文中的一些信息(比如窗口的起始时间)，这是增量聚合函数做不到的。所以，我们还需要有更丰富的窗口计算方式，这就可以用全窗口函数来实现。在 Flink 中，全窗口函数也有两种：<strong>WindowFunction</strong> 和 <strong>ProcessWindowFunction</strong>。</p>
<h5 id="WindowFunction"><a href="#WindowFunction" class="headerlink" title="WindowFunction"></a>WindowFunction</h5><p>WindowFunction 字面上就是窗口函数，它其实是老版本的通用窗口函数接口。我们可以基于 WindowedStream 调用.apply()方法，传入一个WindowFunction 的实现类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stream</span><br><span class="line">   .keyBy(&lt;key selector&gt;)</span><br><span class="line">   .window(&lt;window assigner&gt;)</span><br><span class="line">   .apply(<span class="keyword">new</span> MyWindowFunction());</span><br></pre></td></tr></table></figure>

<p>这个类中可以获取到包含<strong>窗口所有数据的可迭代集合(Iterable)<strong>，还可以拿到</strong>窗口 (Window)本身的信息</strong>。WindowFunction 接口在源码中实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WindowFunction</span>&lt;<span class="title">IN</span>, <span class="title">OUT</span>, <span class="title">KEY</span>, <span class="title">W</span> <span class="keyword">extends</span> <span class="title">Window</span>&gt; <span class="keyword">extends</span> <span class="title">Function</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">apply</span><span class="params">(KEY key, W window, Iterable&lt;IN&gt; input, Collector&lt;OUT&gt; out)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WindowFunction 能提供的上下文信息较少，也没有更高级的功能。 事实上，它的作用可以被 ProcessWindowFunction 全覆盖，所以之后可能会逐渐弃用。一般在实际应用，直接使用 ProcessWindowFunction 就可以了。</p>
<h5 id="ProcessWindowFunction"><a href="#ProcessWindowFunction" class="headerlink" title="ProcessWindowFunction"></a>ProcessWindowFunction</h5><p>ProcessWindowFunction 是 Window API 中最底层的通用窗口函数接口。之所以说它最底层，是因为除了可以拿到窗口中的所有数据之外ProcessWindowFunction 还可以获取到一个<strong>上下文对象(Context)<strong>。这个上下文对象非常强大，不仅能够获取窗口信息，还可以访问当前的</strong>时间</strong>和<strong>状态</strong>信息。这里的时间就包括了处理时间(processing time)和事件时间水位线(event time watermark)。这就使得 ProcessWindowFunction 更加灵活、功能更加丰富。</p>
<p>作为一个全窗口函数， ProcessWindowFunction 同样需要将所有数据缓存下来、等到窗口触发计算时才使用。它其实就是一个增强版的WindowFunction。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessWindowFunction</span>&lt;<span class="title">IN</span>, <span class="title">OUT</span>, <span class="title">KEY</span>, <span class="title">W</span> <span class="keyword">extends</span> <span class="title">Window</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractRichFunction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Evaluates the window and outputs none or several elements.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key The key for which this window is evaluated.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context The context in which the window is being evaluated.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> elements The elements in the window being evaluated.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> out A collector for emitting elements.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception The function may throw exceptions to fail the program and trigger recovery.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            KEY key, Context context, Iterable&lt;IN&gt; elements, Collector&lt;OUT&gt; out)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Deletes any state in the &#123;<span class="doctag">@code</span> Context&#125; when the Window expires (the watermark passes its</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> maxTimestamp&#125; + &#123;<span class="doctag">@code</span> allowedLateness&#125;).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context The context to which the window is being evaluated</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception The function may throw exceptions to fail the program and trigger recovery.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(Context context)</span> <span class="keyword">throws</span> Exception </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The context holding window metadata. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** Returns the window that is being evaluated. */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> W <span class="title">window</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Returns the current processing time. */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">currentProcessingTime</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Returns the current event-time watermark. */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">currentWatermark</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * State accessor for per-key and per-window state.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;&lt;b&gt;<span class="doctag">NOTE:</span>&lt;/b&gt;If you use per-window state you have to ensure that you clean it up by</span></span><br><span class="line"><span class="comment">         * implementing &#123;<span class="doctag">@link</span> ProcessWindowFunction#clear(Context)&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> KeyedStateStore <span class="title">windowState</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** State accessor for per-key global state. */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> KeyedStateStore <span class="title">globalState</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Emits a record to the side output identified by the &#123;<span class="doctag">@link</span> OutputTag&#125;.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> outputTag the &#123;<span class="doctag">@code</span> OutputTag&#125; that identifies the side output to emit to.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> value The record to emit.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;X&gt; <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(OutputTag&lt;X&gt; outputTag, X value)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    SingleOutputStreamOperator&lt;Event&gt; stream = env.addSource(<span class="keyword">new</span> ClickSource())</span><br><span class="line">            .assignTimestampsAndWatermarks(WatermarkStrategy.&lt;Event&gt;forBoundedOutOfOrderness(Duration.ZERO)</span><br><span class="line">                    .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Event&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Event element, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> element.timestamp;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数据全部发往同一分区，按窗口统计UV</span></span><br><span class="line">    stream.keyBy(data -&gt; <span class="keyword">true</span>)</span><br><span class="line">            .window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">10</span>)))</span><br><span class="line">            .process(<span class="keyword">new</span> UvCountByWindow())</span><br><span class="line">            .print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义窗口处理函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UvCountByWindow</span> <span class="keyword">extends</span> <span class="title">ProcessWindowFunction</span>&lt;<span class="title">Event</span>, <span class="title">String</span>, <span class="title">Boolean</span>, <span class="title">TimeWindow</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Boolean aBoolean, Context context, Iterable&lt;Event&gt; elements, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        HashSet&lt;String&gt; userSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">// 遍历所有数据，放到Set里去重</span></span><br><span class="line">        <span class="keyword">for</span> (Event event: elements)&#123;</span><br><span class="line">            userSet.add(event.user);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结合窗口信息，包装输出内容</span></span><br><span class="line">        Long start = context.window().getStart();</span><br><span class="line">        Long end = context.window().getEnd();</span><br><span class="line">        out.collect(<span class="string">&quot;窗口: &quot;</span> + <span class="keyword">new</span> Timestamp(start) + <span class="string">&quot; ~ &quot;</span> + <span class="keyword">new</span> Timestamp(end)</span><br><span class="line">                + <span class="string">&quot; 的独立访客数量是：&quot;</span> + userSet.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全窗口函数因为运行效率较低，很少直接单独使用，往往会和增量聚合函数结合在一起，共同实现窗口的处理计算。</p>
<h4 id="增量聚合和全窗口函数的结合使用"><a href="#增量聚合和全窗口函数的结合使用" class="headerlink" title="增量聚合和全窗口函数的结合使用"></a>增量聚合和全窗口函数的结合使用</h4><p>我们之前在调用 WindowedStream 的.reduce()和.aggregate()方法时，只是简单地直接传入了一个 ReduceFunction 或 AggregateFunction 进行增量聚合。除此之外，其实还可以传入第二个参数：一个全窗口函数，可以是 WindowFunction 或者 ProcessWindowFunction。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReduceFunction 与 WindowFunction 结合</span></span><br><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">SingleOutputStreamOperator&lt;R&gt; <span class="title">reduce</span><span class="params">(ReduceFunction&lt;T&gt; reduceFunction, WindowFunction&lt;T, R, K, W&gt; function)</span></span></span><br><span class="line"><span class="function"><span class="comment">// ReduceFunction 与 ProcessWindowFunction 结合</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;R&gt; SingleOutputStreamOperator&lt;R&gt; <span class="title">reduce</span><span class="params">(ReduceFunction&lt;T&gt; reduceFunction, ProcessWindowFunction&lt;T, R, K, W&gt; function)</span></span></span><br><span class="line"><span class="function"><span class="comment">// AggregateFunction 与 WindowFunction 结合</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;ACC, V, R&gt; SingleOutputStreamOperator&lt;R&gt; <span class="title">aggregate</span><span class="params">(AggregateFunction&lt;T, ACC, V&gt; aggFunction, WindowFunction&lt;V, R, K, W&gt; windowFunction)</span></span></span><br><span class="line"><span class="function"><span class="comment">// AggregateFunction 与 ProcessWindowFunction 结合</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> &lt;ACC, V, R&gt; SingleOutputStreamOperator&lt;R&gt; <span class="title">aggregate</span><span class="params">(AggregateFunction&lt;T, ACC, V&gt; aggFunction, ProcessWindowFunction&lt;V, R, K, W&gt; windowFunction)</span></span></span><br></pre></td></tr></table></figure>

<p>这样调用的处理机制是：基于第一个参数(增量聚合函数)来处理窗口数据，每来一个数据就做一次聚合；等到窗口需要触发计算时，则调用第二个参数(全窗口函数)的处理逻辑输出结果。需要注意的是，这里的<strong>全窗口函数就不再缓存所有数据</strong>了，而是<strong>直接将增量聚合函数的结果拿来当作了 Iterable 类型的输入</strong>。一般情况下，这时的<strong>可迭代集合中就只有一个元素</strong>了。</p>
<p>下面我们举一个具体的实例来说明。在网站的各种统计指标中，一个很重要的统计指标就是热门的链接；想要得到热门的url，前提是得到每个链接的热门度。一般情况下，可以用 url 的浏览量(点击量)表示热门度。我们这里统计 10 秒钟的 url 浏览量，每 5 秒钟更新一次；另外为了更加清晰地展示，还应该把窗口的起始结束时间一起输出。我们可以定义滑动窗口，并结合增量聚合函数和全窗口函数来得到统计结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//POJO 类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UrlViewCount</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String url;</span><br><span class="line">    <span class="keyword">public</span> Long count;</span><br><span class="line">    <span class="keyword">public</span> Long windowStart;</span><br><span class="line">    <span class="keyword">public</span> Long windowEnd;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UrlViewCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UrlViewCount</span><span class="params">(String url, Long count, Long windowStart, Long windowEnd)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">        <span class="keyword">this</span>.windowStart = windowStart;</span><br><span class="line">        <span class="keyword">this</span>.windowEnd = windowEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;UrlViewCount&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;url=&#x27;&quot;</span> + url + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, count=&quot;</span> + count +</span><br><span class="line">                <span class="string">&quot;, windowStart=&quot;</span> + <span class="keyword">new</span> Timestamp(windowStart) +</span><br><span class="line">                <span class="string">&quot;, windowEnd=&quot;</span> + <span class="keyword">new</span> Timestamp(windowEnd) +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    SingleOutputStreamOperator&lt;Event&gt; stream = env.addSource(<span class="keyword">new</span> ClickSource())</span><br><span class="line">            .assignTimestampsAndWatermarks(WatermarkStrategy.&lt;Event&gt;forMonotonousTimestamps()</span><br><span class="line">                    .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Event&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Event element, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> element.timestamp;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要按照url分组，开滑动窗口统计</span></span><br><span class="line">    stream.keyBy(data -&gt; data.url)</span><br><span class="line">            .window(SlidingEventTimeWindows.of(Time.seconds(<span class="number">10</span>), Time.seconds(<span class="number">5</span>)))</span><br><span class="line">            <span class="comment">// 同时传入增量聚合函数和全窗口函数</span></span><br><span class="line">            .aggregate(<span class="keyword">new</span> UrlViewCountAgg(), <span class="keyword">new</span> UrlViewCountResult())</span><br><span class="line">            .print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义增量聚合函数，来一条数据就加一</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UrlViewCountAgg</span> <span class="keyword">implements</span> <span class="title">AggregateFunction</span>&lt;<span class="title">Event</span>, <span class="title">Long</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">createAccumulator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">add</span><span class="params">(Event value, Long accumulator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accumulator + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getResult</span><span class="params">(Long accumulator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accumulator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">merge</span><span class="params">(Long a, Long b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义窗口处理函数，只需要包装窗口信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UrlViewCountResult</span> <span class="keyword">extends</span> <span class="title">ProcessWindowFunction</span>&lt;<span class="title">Long</span>, <span class="title">UrlViewCount</span>, <span class="title">String</span>, <span class="title">TimeWindow</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String url, Context context, Iterable&lt;Long&gt; elements, Collector&lt;UrlViewCount&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 结合窗口信息，包装输出内容</span></span><br><span class="line">        Long start = context.window().getStart();</span><br><span class="line">        Long end = context.window().getEnd();</span><br><span class="line">        <span class="comment">// 迭代器中只有一个元素，就是增量聚合函数的计算结果</span></span><br><span class="line">        out.collect(<span class="keyword">new</span> UrlViewCount(url, elements.iterator().next(), start, end));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中用一个AggregateFunction来实现增量聚合，每来一个数据就计数加一；得到的结果交给ProcessWindowFunction，结合窗口信息包装成我们想要的 UrlViewCount，最终输出统计结果。</p>
<h3 id="其他API"><a href="#其他API" class="headerlink" title="其他API"></a>其他API</h3><h4 id="触发器-Trigger"><a href="#触发器-Trigger" class="headerlink" title="触发器(Trigger)"></a>触发器(Trigger)</h4><p>触发器主要是用来控制窗口什么时候触发计算。所谓的触发计算，本质上就是执行窗口函数，所以可以认为是计算得到结果并输出的过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stream.keyBy(...)</span><br><span class="line">      .window(...)</span><br><span class="line">      .trigger(<span class="keyword">new</span> MyTrigger())</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A &#123;<span class="doctag">@code</span> Trigger&#125; determines when a pane of a window should be evaluated to emit the results for</span></span><br><span class="line"><span class="comment"> * that part of the window.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;A pane is the bucket of elements that have the same key (assigned by the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * org.apache.flink.api.java.functions.KeySelector&#125;) and same &#123;<span class="doctag">@link</span> Window&#125;. An element can be in</span></span><br><span class="line"><span class="comment"> * multiple panes if it was assigned to multiple windows by the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * org.apache.flink.streaming.api.windowing.assigners.WindowAssigner&#125;. These panes all have their</span></span><br><span class="line"><span class="comment"> * own instance of the &#123;<span class="doctag">@code</span> Trigger&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Triggers must not maintain state internally since they can be re-created or reused for</span></span><br><span class="line"><span class="comment"> * different keys. All necessary state should be persisted using the state abstraction available on</span></span><br><span class="line"><span class="comment"> * the &#123;<span class="doctag">@link</span> TriggerContext&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;When used with a &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * org.apache.flink.streaming.api.windowing.assigners.MergingWindowAssigner&#125; the &#123;<span class="doctag">@code</span> Trigger&#125;</span></span><br><span class="line"><span class="comment"> * must return &#123;<span class="doctag">@code</span> true&#125; from &#123;<span class="doctag">@link</span> #canMerge()&#125; and &#123;<span class="doctag">@link</span> #onMerge(Window, OnMergeContext)&#125;</span></span><br><span class="line"><span class="comment"> * most be properly implemented.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; The type of elements on which this &#123;<span class="doctag">@code</span> Trigger&#125; works.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;W&gt; The type of &#123;<span class="doctag">@link</span> Window Windows&#125; on which this &#123;<span class="doctag">@code</span> Trigger&#125; can operate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PublicEvolving</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Trigger</span>&lt;<span class="title">T</span>, <span class="title">W</span> <span class="keyword">extends</span> <span class="title">Window</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">4104633972991191369L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Called for every element that gets added to a pane. The result of this will determine whether</span></span><br><span class="line"><span class="comment">     * the pane is evaluated to emit results.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element The element that arrived.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timestamp The timestamp of the element that arrived.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> window The window to which the element is being added.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx A context object that can be used to register timer callbacks.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> TriggerResult <span class="title">onElement</span><span class="params">(T element, <span class="keyword">long</span> timestamp, W window, TriggerContext ctx)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Called when a processing-time timer that was set using the trigger context fires.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time The timestamp at which the timer fired.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> window The window for which the timer fired.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx A context object that can be used to register timer callbacks.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> TriggerResult <span class="title">onProcessingTime</span><span class="params">(<span class="keyword">long</span> time, W window, TriggerContext ctx)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Called when an event-time timer that was set using the trigger context fires.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time The timestamp at which the timer fired.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> window The window for which the timer fired.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx A context object that can be used to register timer callbacks.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> TriggerResult <span class="title">onEventTime</span><span class="params">(<span class="keyword">long</span> time, W window, TriggerContext ctx)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns true if this trigger supports merging of trigger state and can therefore be used with</span></span><br><span class="line"><span class="comment">     * a &#123;<span class="doctag">@link</span> org.apache.flink.streaming.api.windowing.assigners.MergingWindowAssigner&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;If this returns &#123;<span class="doctag">@code</span> true&#125; you must properly implement &#123;<span class="doctag">@link</span> #onMerge(Window,</span></span><br><span class="line"><span class="comment">     * OnMergeContext)&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canMerge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Called when several windows have been merged into one window by the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * org.apache.flink.streaming.api.windowing.assigners.WindowAssigner&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> window The new window that results from the merge.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx A context object that can be used to register timer callbacks and access state.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMerge</span><span class="params">(W window, OnMergeContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;This trigger does not support merging.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Clears any state that the trigger might still hold for the given window. This is called when</span></span><br><span class="line"><span class="comment">     * a window is purged. Timers set using &#123;<span class="doctag">@link</span> TriggerContext#registerEventTimeTimer(long)&#125; and</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> TriggerContext#registerProcessingTimeTimer(long)&#125; should be deleted here as well as</span></span><br><span class="line"><span class="comment">     * state acquired using &#123;<span class="doctag">@link</span> TriggerContext#getPartitionedState(StateDescriptor)&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(W window, TriggerContext ctx)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A context object that is given to &#123;<span class="doctag">@link</span> Trigger&#125; methods to allow them to register timer</span></span><br><span class="line"><span class="comment">     * callbacks and deal with state.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TriggerContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Returns the current processing time. */</span></span><br><span class="line">        <span class="function"><span class="keyword">long</span> <span class="title">getCurrentProcessingTime</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns the metric group for this &#123;<span class="doctag">@link</span> Trigger&#125;. This is the same metric group that</span></span><br><span class="line"><span class="comment">         * would be returned from &#123;<span class="doctag">@link</span> RuntimeContext#getMetricGroup()&#125; in a user function.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;You must not call methods that create metric objects (such as &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">         * MetricGroup#counter(int)&#125; multiple times but instead call once and store the metric</span></span><br><span class="line"><span class="comment">         * object in a field.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function">MetricGroup <span class="title">getMetricGroup</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Returns the current watermark time. */</span></span><br><span class="line">        <span class="function"><span class="keyword">long</span> <span class="title">getCurrentWatermark</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Register a system time callback. When the current system time passes the specified time</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@link</span> Trigger#onProcessingTime(long, Window, TriggerContext)&#125; is called with the time</span></span><br><span class="line"><span class="comment">         * specified here.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> time The time at which to invoke &#123;<span class="doctag">@link</span> Trigger#onProcessingTime(long, Window,</span></span><br><span class="line"><span class="comment">         *     TriggerContext)&#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">registerProcessingTimeTimer</span><span class="params">(<span class="keyword">long</span> time)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Register an event-time callback. When the current watermark passes the specified time</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@link</span> Trigger#onEventTime(long, Window, TriggerContext)&#125; is called with the time</span></span><br><span class="line"><span class="comment">         * specified here.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> time The watermark at which to invoke &#123;<span class="doctag">@link</span> Trigger#onEventTime(long, Window,</span></span><br><span class="line"><span class="comment">         *     TriggerContext)&#125;</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@see</span> org.apache.flink.streaming.api.watermark.Watermark</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">registerEventTimeTimer</span><span class="params">(<span class="keyword">long</span> time)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Delete the processing time trigger for the given time. */</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">deleteProcessingTimeTimer</span><span class="params">(<span class="keyword">long</span> time)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Delete the event-time trigger for the given time. */</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">deleteEventTimeTimer</span><span class="params">(<span class="keyword">long</span> time)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Retrieves a &#123;<span class="doctag">@link</span> State&#125; object that can be used to interact with fault-tolerant state</span></span><br><span class="line"><span class="comment">         * that is scoped to the window and key of the current trigger invocation.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> stateDescriptor The StateDescriptor that contains the name and type of the state</span></span><br><span class="line"><span class="comment">         *     that is being accessed.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> &lt;S&gt; The type of the state.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> The partitioned state object.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> UnsupportedOperationException Thrown, if no partitioned state is available for</span></span><br><span class="line"><span class="comment">         *     the function (function is not part os a KeyedStream).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        &lt;S extends State&gt; <span class="function">S <span class="title">getPartitionedState</span><span class="params">(StateDescriptor&lt;S, ?&gt; stateDescriptor)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Retrieves a &#123;<span class="doctag">@link</span> ValueState&#125; object that can be used to interact with fault-tolerant</span></span><br><span class="line"><span class="comment">         * state that is scoped to the window and key of the current trigger invocation.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> name The name of the key/value state.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> stateType The class of the type that is stored in the state. Used to generate</span></span><br><span class="line"><span class="comment">         *     serializers for managed memory and checkpointing.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> defaultState The default state value, returned when the state is accessed and no</span></span><br><span class="line"><span class="comment">         *     value has yet been set for the key. May be null.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> &lt;S&gt; The type of the state.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> The partitioned state object.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> UnsupportedOperationException Thrown, if no partitioned state is available for</span></span><br><span class="line"><span class="comment">         *     the function (function is not part os a KeyedStream).</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@deprecated</span> Use &#123;<span class="doctag">@link</span> #getPartitionedState(StateDescriptor)&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Deprecated</span></span><br><span class="line">        &lt;S extends Serializable&gt; <span class="function">ValueState&lt;S&gt; <span class="title">getKeyValueState</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                String name, Class&lt;S&gt; stateType, S defaultState)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Retrieves a &#123;<span class="doctag">@link</span> ValueState&#125; object that can be used to interact with fault-tolerant</span></span><br><span class="line"><span class="comment">         * state that is scoped to the window and key of the current trigger invocation.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> name The name of the key/value state.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> stateType The type information for the type that is stored in the state. Used to</span></span><br><span class="line"><span class="comment">         *     create serializers for managed memory and checkpoints.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> defaultState The default state value, returned when the state is accessed and no</span></span><br><span class="line"><span class="comment">         *     value has yet been set for the key. May be null.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> &lt;S&gt; The type of the state.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> The partitioned state object.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> UnsupportedOperationException Thrown, if no partitioned state is available for</span></span><br><span class="line"><span class="comment">         *     the function (function is not part os a KeyedStream).</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@deprecated</span> Use &#123;<span class="doctag">@link</span> #getPartitionedState(StateDescriptor)&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Deprecated</span></span><br><span class="line">        &lt;S extends Serializable&gt; <span class="function">ValueState&lt;S&gt; <span class="title">getKeyValueState</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                String name, TypeInformation&lt;S&gt; stateType, S defaultState)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Extension of &#123;<span class="doctag">@link</span> TriggerContext&#125; that is given to &#123;<span class="doctag">@link</span> Trigger#onMerge(Window,</span></span><br><span class="line"><span class="comment">     * OnMergeContext)&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnMergeContext</span> <span class="keyword">extends</span> <span class="title">TriggerContext</span> </span>&#123;</span><br><span class="line">        &lt;S extends MergingState&lt;?, ?&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">mergePartitionedState</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">                StateDescriptor&lt;S, ?&gt; stateDescriptor)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Trigger 是窗口算子的内部属性，每个窗口分配器(WindowAssigner)都会对应一个默认的触发器；对于 Flink 内置的窗口类型，它们的触发器都已经做了实现。例如，所有事件时间窗口，默认的触发器都是 EventTimeTrigger；类似还有 ProcessingTimeTrigger 和 CountTrigger。 所以一般情况下是不需要自定义触发器的，不过我们依然有必要了解它的原理。</p>
<p>Trigger 是一个抽象类，自定义时必须实现下面四个抽象方法：</p>
<p>onElement()：窗口中每到来一个元素，都会调用这个方法。</p>
<p>onEventTime()：当注册的事件时间定时器触发时，将调用这个方法。</p>
<p>onProcessingTime ()：当注册的处理时间定时器触发时，将调用这个方法。</p>
<p>clear()：当窗口关闭销毁时，调用这个方法。一般用来清除自定义的状态。</p>
<p>除了 clear() 比较像生命周期方法，其他三个方法其实都是对某种事件的响应。 onElement() 是对流中数据元素到来的响应；而另两个则是对时间的响应。这几个方法的参数中都有一个触发器上下文(TriggerContext)对象，可以用来注册定时器回调(callback)。这里提到的定时器(Timer)，其实就是我们设定的一个闹钟，代表未来某个时间点会执行的事件；当时间进展到设定的值时，就会执行定义好的操作。</p>
<p>上面的前三个方法可以响应事件，那它们又是怎样跟窗口操作联系起来的呢？这就需要了解一下它们的返回值。这<strong>三个方法返回类型都是 TriggerResult</strong>，这是一个枚举类型(enum)， 其中定义了对窗口进行操作的四种类型。</p>
<p>CONTINUE(继续)：什么都不做</p>
<p>FIRE(触发)：触发计算，输出结果</p>
<p>PURGE(清除)：清空窗口中的所有数据，销毁窗口</p>
<p>FIRE_AND_PURGE(触发并清除)：触发计算输出结果，并清除窗口</p>
<p>在日常业务场景中，我们经常会开比较大的窗口来计算每个窗口的 pv 或者 uv 等数据。但窗口开的太大，会使我们看到计算结果的时间间隔变长。所以我们可以使用触发器，来隔一段时间触发一次窗口计算。我们在代码中计算了每个 url 在 10 秒滚动窗口的 pv 指标，然后设置了触发器，每隔 1 秒钟触发一次窗口的计算。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    env</span><br><span class="line">            .addSource(<span class="keyword">new</span> ClickSource())</span><br><span class="line">            .assignTimestampsAndWatermarks(</span><br><span class="line">                    WatermarkStrategy.&lt;Event&gt;forMonotonousTimestamps()</span><br><span class="line">                            .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Event&gt;() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Event event, <span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">                                    <span class="keyword">return</span> event.timestamp;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;)</span><br><span class="line">            )</span><br><span class="line">            .keyBy(r -&gt; r.url)</span><br><span class="line">            .window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">10</span>)))</span><br><span class="line">            .trigger(<span class="keyword">new</span> MyTrigger())</span><br><span class="line">            .process(<span class="keyword">new</span> WindowResult())</span><br><span class="line">            .print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowResult</span> <span class="keyword">extends</span> <span class="title">ProcessWindowFunction</span>&lt;<span class="title">Event</span>, <span class="title">UrlViewCount</span>, <span class="title">String</span>, <span class="title">TimeWindow</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String s, Context context, Iterable&lt;Event&gt; iterable, Collector&lt;UrlViewCount&gt; collector)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        collector.collect(</span><br><span class="line">                <span class="keyword">new</span> UrlViewCount(</span><br><span class="line">                        s,</span><br><span class="line">                        <span class="comment">// 获取迭代器中的元素个数</span></span><br><span class="line">                        iterable.spliterator().getExactSizeIfKnown(),</span><br><span class="line">                        context.window().getStart(),</span><br><span class="line">                        context.window().getEnd()</span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTrigger</span> <span class="keyword">extends</span> <span class="title">Trigger</span>&lt;<span class="title">Event</span>, <span class="title">TimeWindow</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TriggerResult <span class="title">onElement</span><span class="params">(Event event, <span class="keyword">long</span> l, TimeWindow timeWindow, TriggerContext triggerContext)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ValueState&lt;Boolean&gt; isFirstEvent = triggerContext.getPartitionedState(</span><br><span class="line">                <span class="keyword">new</span> ValueStateDescriptor&lt;Boolean&gt;(<span class="string">&quot;first-event&quot;</span>, Types.BOOLEAN)</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (isFirstEvent.value() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> i = timeWindow.getStart(); i &lt; timeWindow.getEnd(); i = i + <span class="number">1000L</span>) &#123;</span><br><span class="line">                triggerContext.registerEventTimeTimer(i);</span><br><span class="line">            &#125;</span><br><span class="line">            isFirstEvent.update(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> TriggerResult.CONTINUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TriggerResult <span class="title">onEventTime</span><span class="params">(<span class="keyword">long</span> l, TimeWindow timeWindow, TriggerContext triggerContext)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> TriggerResult.FIRE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TriggerResult <span class="title">onProcessingTime</span><span class="params">(<span class="keyword">long</span> l, TimeWindow timeWindow, TriggerContext triggerContext)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> TriggerResult.CONTINUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(TimeWindow timeWindow, TriggerContext triggerContext)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ValueState&lt;Boolean&gt; isFirstEvent = triggerContext.getPartitionedState(</span><br><span class="line">                <span class="keyword">new</span> ValueStateDescriptor&lt;Boolean&gt;(<span class="string">&quot;first-event&quot;</span>, Types.BOOLEAN)</span><br><span class="line">        );</span><br><span class="line">        isFirstEvent.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="移除器-Evictor"><a href="#移除器-Evictor" class="headerlink" title="移除器(Evictor)"></a>移除器(Evictor)</h4><p>移除器主要用来定义移除某些数据的逻辑。基于 WindowedStream 调用.evictor()方法，就可以传入一个自定义的移除器(Evictor)。Evictor 是一个接口，不同的窗口类型都有各自预实现的移除器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stream.keyBy(...)</span><br><span class="line">      .window(...)</span><br><span class="line">      .evictor(<span class="keyword">new</span> MyEvictor())</span><br></pre></td></tr></table></figure>

<p>Evictor 接口定义了两个方法:</p>
<p>evictBefore()：定义执行窗口函数之前的移除数据操作。</p>
<p>evictAfter()：定义执行窗口函数之后的移除数据操作默认情况下，预实现的移除器都是在执行窗口函数(window fucntions)之前移除数据的。</p>
<h4 id="允许延迟-Allowed-Lateness"><a href="#允许延迟-Allowed-Lateness" class="headerlink" title="允许延迟(Allowed Lateness)"></a>允许延迟(Allowed Lateness)</h4><p>在事件时间语义下，窗口中可能会出现数据迟到的情况。这是因为在乱序流中，水位线 (watermark)并不一定能保证时间戳更早的所有数据不会再来。当水位线已经到达窗口结束时间时，窗口会触发计算并输出结果，这时一般也就要销毁窗口了；如果窗口关闭之后，又有本属于窗口内的数据姗姗来迟，默认情况下就会被丢弃。这也很好理解：窗口触发计算就像发车，如果要赶的车已经开走了，又不能坐其他的车(保证分配窗口的正确性)，那就只好放弃坐班了。</p>
<p>不过在多数情况下，直接丢弃数据也会导致统计结果不准确，我们还是希望该上车的人都能上来。为了解决迟到数据的问题，Flink 提供了一个特殊的接口，可以为窗口算子设置一个允许的最大延迟(Allowed Lateness)。也就是说，我们可以设定允许延迟一段时间，在这段时间内，窗口不会销毁，<strong>继续到来的数据依然可以进入窗口中并触发计算</strong>。直到水位线推进到了窗口结束时间 + 延迟时间，才真正将窗口的内容清空，正式关闭窗口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stream.keyBy(...)</span><br><span class="line">      .window(TumblingEventTimeWindows.of(Time.hours(<span class="number">1</span>)))</span><br><span class="line">      .allowedLateness(Time.minutes(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<h4 id="侧输出流"><a href="#侧输出流" class="headerlink" title="侧输出流"></a>侧输出流</h4><p>Flink 还提供了另外一种方式处理迟到数据。我们可以将未收入窗口的迟到数据，放入侧输出流(side output)进行另外的处理。所谓的侧输出流，相当于是数据流的一个分支，这个流中单独放置那些错过了该上的车、本该被丢弃的数据。</p>
<p>基于 WindowedStream 调用.sideOutputLateData() 方法，就可以实现这个功能。方法需要传入一个输出标签(OutputTag)，用来标记分支的迟到数据流。因为保存的就是流中的原始数据，所以 OutputTag 的类型与流中数据<strong>类型相同</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取socket文本流</span></span><br><span class="line">    SingleOutputStreamOperator&lt;Event&gt; stream =</span><br><span class="line">            env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">7777</span>)</span><br><span class="line">                    .map(<span class="keyword">new</span> MapFunction&lt;String, Event&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> Event <span class="title">map</span><span class="params">(String value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            String[] fields = value.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">new</span> Event(fields[<span class="number">0</span>].trim(), fields[<span class="number">1</span>].trim(), Long.valueOf(fields[<span class="number">2</span>].trim()));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    <span class="comment">// 方式一：设置watermark延迟时间，2秒钟</span></span><br><span class="line">                    .assignTimestampsAndWatermarks(WatermarkStrategy.&lt;Event&gt;forBoundedOutOfOrderness(Duration.ofSeconds(<span class="number">2</span>))</span><br><span class="line">                            .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Event&gt;() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Event element, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                                    <span class="keyword">return</span> element.timestamp;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义侧输出流标签</span></span><br><span class="line">    OutputTag&lt;Event&gt; outputTag = <span class="keyword">new</span> OutputTag&lt;Event&gt;(<span class="string">&quot;late&quot;</span>)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    SingleOutputStreamOperator&lt;UrlViewCount&gt; result = stream.keyBy(data -&gt; data.url)</span><br><span class="line">            .window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">10</span>)))</span><br><span class="line">            <span class="comment">// 方式二：允许窗口处理迟到数据，设置1分钟的等待时间</span></span><br><span class="line">            .allowedLateness(Time.minutes(<span class="number">1</span>))</span><br><span class="line">            <span class="comment">// 方式三：将最后的迟到数据输出到侧输出流</span></span><br><span class="line">            .sideOutputLateData(outputTag)</span><br><span class="line">            .aggregate(<span class="keyword">new</span> UrlViewCountAgg(), <span class="keyword">new</span> UrlViewCountResult());</span><br><span class="line"></span><br><span class="line">    result.print(<span class="string">&quot;result&quot;</span>);</span><br><span class="line">    result.getSideOutput(outputTag).print(<span class="string">&quot;late&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为方便观察，可以将原始数据也输出</span></span><br><span class="line">    stream.print(<span class="string">&quot;input&quot;</span>);</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UrlViewCountAgg</span> <span class="keyword">implements</span> <span class="title">AggregateFunction</span>&lt;<span class="title">Event</span>, <span class="title">Long</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">createAccumulator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">add</span><span class="params">(Event value, Long accumulator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accumulator + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getResult</span><span class="params">(Long accumulator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accumulator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">merge</span><span class="params">(Long a, Long b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UrlViewCountResult</span> <span class="keyword">extends</span> <span class="title">ProcessWindowFunction</span>&lt;<span class="title">Long</span>, <span class="title">UrlViewCount</span>, <span class="title">String</span>, <span class="title">TimeWindow</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String url, Context context, Iterable&lt;Long&gt; elements, Collector&lt;UrlViewCount&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 结合窗口信息，包装输出内容</span></span><br><span class="line">        Long start = context.window().getStart();</span><br><span class="line">        Long end = context.window().getEnd();</span><br><span class="line">        out.collect(<span class="keyword">new</span> UrlViewCount(url, elements.iterator().next(), start, end));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里注意，getSideOutput() 是 SingleOutputStreamOperator 的方法，获取到的侧输出流数据类型应该和 OutputTag 指定的类型一致，与窗口聚合之后流中的数据类型<strong>可以不同</strong>。</p>
<h3 id="窗口的生命周期"><a href="#窗口的生命周期" class="headerlink" title="窗口的生命周期"></a>窗口的生命周期</h3><p><strong>1、窗口的创建</strong></p>
<p>窗口的类型和基本信息由窗口分配器(window assigners)指定，但窗口不会预先创建好，而是由数据驱动创建。当第一个应该属于这个窗口的数据元素到达时，就会创建对应的窗口。</p>
<p><strong>2、窗口计算的触发</strong></p>
<p>除了窗口分配器，每个窗口还会有自己的<strong>窗口函数(window functions)<strong>和</strong>触发器(trigger)<strong>。 窗口函数可以分为</strong>增量聚合函数</strong>和<strong>全窗口函数</strong>，主要定义了窗口中计算的逻辑；而触发器则是指定调用窗口函数的条件。</p>
<p>对于不同的窗口类型，触发计算的条件也会不同。例如，一个滚动事件时间窗口，应该在水位线到达窗口结束时间的时候触发计算，属于定点发车；而一个计数窗口，会在窗口中元素数量达到定义大小时触发计算，属于人满就发车。所以 Flink 预定义的窗口类型都有对应内置的触发器。</p>
<p>对于事件时间窗口而言，除去到达结束时间的定点发车，还有另一种情形。当我们设置了允许延迟，那么如果水位线超过了窗口结束时间、但还没有到达设定的最大延迟时间，这期间内到达的迟到数据也会触发窗口计算。这类似于没有准时赶上班车的人又追上了车，这时车要再次停靠、开门，将新的数据整合统计进来。</p>
<p><strong>3、窗口的销毁</strong></p>
<p>一般情况下，当时间达到了结束点，就会直接触发计算输出结果、进而清除状态销毁窗口。 这时窗口的销毁可以认为和触发计算是同一时刻。这里需要注意，Flink 中只对时间窗口(TimeWindow)有销毁机制；由于计数窗口(CountWindow)是基于全局窗口(GlobalWindw) 实现的，而全局窗口不会清除状态，所以就不会被销毁。</p>
<p>在特殊的场景下，窗口的销毁和触发计算会有所不同。事件时间语义下，如果设置了允许延迟，那么在水位线到达窗口结束时间时，仍然不会销毁窗口；窗口真正被完全删除的时间点， 是窗口的结束时间加上用户指定的允许延迟时间。</p>
<p><strong>4、窗口 API 调用总结</strong></p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-03-23%20%E4%B8%8B%E5%8D%888.50.24.png" alt="截屏2022-03-23 下午8.50.24"></p>
<h2 id="WaterMark"><a href="#WaterMark" class="headerlink" title="WaterMark"></a>WaterMark</h2><p>水位线 = 观察到的最大事件时间 – 最大延迟时间 – 1 毫秒</p>
<p>Flink<strong>内置</strong>了两个WaterMark生成器：</p>
<p>1、Monotonously Increasing Timestamps(时间戳单调增长：其实就是允许的延迟为0)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有序流</span></span><br><span class="line">WatermarkStrategy.forMonotonousTimestamps();</span><br></pre></td></tr></table></figure>

<p>2、Fixed Amount of Lateness(允许固定时间的延迟)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//乱序流</span></span><br><span class="line">WatermarkStrategy.forBoundedOutOfOrderness(Duration.ofSeconds(<span class="number">10</span>));</span><br></pre></td></tr></table></figure>

<h3 id="内置水位线生成器"><a href="#内置水位线生成器" class="headerlink" title="内置水位线生成器"></a>内置水位线生成器</h3><p><strong>WatermarkTest</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数据源改为socket文本流，并转换成Event类型</span></span><br><span class="line">    env.socketTextStream(<span class="string">&quot;localhost&quot;</span>, <span class="number">7777</span>)</span><br><span class="line">            .map(<span class="keyword">new</span> MapFunction&lt;String, Event&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Event <span class="title">map</span><span class="params">(String value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    String[] fields = value.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> Event(fields[<span class="number">0</span>].trim(), fields[<span class="number">1</span>].trim(), Long.valueOf(fields[<span class="number">2</span>].trim()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment">// 插入水位线的逻辑</span></span><br><span class="line">            .assignTimestampsAndWatermarks(</span><br><span class="line">                    <span class="comment">// 针对乱序流插入水位线，延迟时间设置为5s</span></span><br><span class="line">                    WatermarkStrategy.&lt;Event&gt;forBoundedOutOfOrderness(Duration.ofSeconds(<span class="number">5</span>))</span><br><span class="line">                            .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Event&gt;() &#123;</span><br><span class="line">                                <span class="comment">// 抽取时间戳的逻辑</span></span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Event element, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                                    <span class="keyword">return</span> element.timestamp;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;)</span><br><span class="line">            )</span><br><span class="line">            <span class="comment">// 根据user分组，开窗统计</span></span><br><span class="line">            .keyBy(data -&gt; data.user)</span><br><span class="line">            .window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">10</span>)))</span><br><span class="line">            .process(<span class="keyword">new</span> WatermarkTestResult())</span><br><span class="line">            .print();</span><br><span class="line"></span><br><span class="line">    env.execute(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义处理窗口函数，输出当前的水位线和窗口信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WatermarkTestResult</span> <span class="keyword">extends</span> <span class="title">ProcessWindowFunction</span>&lt;<span class="title">Event</span>, <span class="title">String</span>, <span class="title">String</span>, <span class="title">TimeWindow</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String s, Context context, Iterable&lt;Event&gt; elements, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Long start = context.window().getStart();</span><br><span class="line">        Long end = context.window().getEnd();</span><br><span class="line">        Long currentWatermark = context.currentWatermark();</span><br><span class="line">        Long count = elements.spliterator().getExactSizeIfKnown();</span><br><span class="line">        out.collect(<span class="string">&quot;窗口&quot;</span> + start + <span class="string">&quot; ~ &quot;</span> + end + <span class="string">&quot;中共有&quot;</span> + count + <span class="string">&quot;个元素，窗口闭合计算时，水位线处于：&quot;</span> + currentWatermark);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义水位线"><a href="#自定义水位线" class="headerlink" title="自定义水位线"></a>自定义水位线</h3><p>有2种风格的WaterMark生产方式：periodic(周期性)和punctuated(间歇性)，都需要继承接口<strong>WatermarkGenerator</strong>。</p>
<p>onEvent()：<strong>每个事件到来时调用</strong>。在事件触发的方法中发出水位线，自然就是断点式(间歇性)生成。</p>
<p>onPeriodicEmit()：<strong>由框架周期性调用</strong>。周期性调用的方法中发出水位线，自然就是周期性生成水位线。</p>
<p>两种方式的不同就集中体现在这两个方法的实现上。</p>
<p><strong>CustomWatermarkTest</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    env</span><br><span class="line">            .addSource(<span class="keyword">new</span> ClickSource())</span><br><span class="line">            .assignTimestampsAndWatermarks(<span class="keyword">new</span> CustomWatermarkStrategy())</span><br><span class="line">            .print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomWatermarkStrategy</span> <span class="keyword">implements</span> <span class="title">WatermarkStrategy</span>&lt;<span class="title">Event</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TimestampAssigner&lt;Event&gt; <span class="title">createTimestampAssigner</span><span class="params">(TimestampAssignerSupplier.Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SerializableTimestampAssigner&lt;Event&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Event element, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> element.timestamp; <span class="comment">// 告诉程序数据源里的时间戳是哪一个字段</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WatermarkGenerator&lt;Event&gt; <span class="title">createWatermarkGenerator</span><span class="params">(WatermarkGeneratorSupplier.Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomPeriodicGenerator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//periodic</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomPeriodicGenerator</span> <span class="keyword">implements</span> <span class="title">WatermarkGenerator</span>&lt;<span class="title">Event</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long delayTime = <span class="number">5000L</span>; <span class="comment">// 延迟时间</span></span><br><span class="line">    <span class="keyword">private</span> Long maxTs = Long.MIN_VALUE + delayTime + <span class="number">1L</span>; <span class="comment">// 观察到的最大时间戳</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event event, <span class="keyword">long</span> eventTimestamp, WatermarkOutput output)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 每来一条数据就调用一次</span></span><br><span class="line">        maxTs = Math.max(event.timestamp, maxTs); <span class="comment">// 更新最大时间戳</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPeriodicEmit</span><span class="params">(WatermarkOutput output)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 发射水位线，默认200ms调用一次</span></span><br><span class="line">        output.emitWatermark(<span class="keyword">new</span> Watermark(maxTs - delayTime - <span class="number">1L</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//punctuated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomPunctuatedGenerator</span> <span class="keyword">implements</span> <span class="title">WatermarkGenerator</span>&lt;<span class="title">Event</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event r, <span class="keyword">long</span> eventTimestamp, WatermarkOutput output)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只有在遇到特定的 itemId 时，才发出水位线 </span></span><br><span class="line">        <span class="keyword">if</span> (r.user.equals(<span class="string">&quot;Mary&quot;</span>)) &#123;</span><br><span class="line">            output.emitWatermark(<span class="keyword">new</span> Watermark(r.timestamp - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPeriodicEmit</span><span class="params">(WatermarkOutput output)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不需要做任何事情，因为我们在 onEvent 方法中发射了水位线</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="EmitWatermarkInSourceFunction"><a href="#EmitWatermarkInSourceFunction" class="headerlink" title="EmitWatermarkInSourceFunction"></a>EmitWatermarkInSourceFunction</h3><p>我们也可以在自定义的数据源中抽取事件时间，然后发送水位线。这里要注意的是，在自定义数据源中发送了水位线以后，就不能再在程序中使用 assignTimestampsAndWatermarks 方法来生成水位线了。在自定义数据源中生成水位线和在程序中使用 assignTimestampsAndWatermarks 方法生成水位线<strong>二者只能取其一</strong>。</p>
<p>在自定义水位线中生成水位线相比 assignTimestampsAndWatermarks 方法更加灵活，可以任意的产生周期性的、非周期性的水位线，以及水位线的大小也完全由我们自定义。所以非常适合用来编写 Flink 的测试程序，测试 Flink 的各种各样的特性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    env.addSource(<span class="keyword">new</span> ClickSourceWithWatermark()).print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClickSourceWithWatermark</span> <span class="keyword">implements</span> <span class="title">SourceFunction</span>&lt;<span class="title">Event</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> running = <span class="keyword">true</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(SourceContext&lt;Event&gt; sourceContext)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        String[] userArr = &#123;<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Alice&quot;</span>&#125;;</span><br><span class="line">        String[] urlArr  = &#123;<span class="string">&quot;./home&quot;</span>, <span class="string">&quot;./cart&quot;</span>, <span class="string">&quot;./prod?id=1&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            <span class="keyword">long</span> currTs = Calendar.getInstance().getTimeInMillis(); <span class="comment">// 毫秒时间戳</span></span><br><span class="line">            String username = userArr[random.nextInt(userArr.length)];</span><br><span class="line">            String url      = urlArr[random.nextInt(urlArr.length)];</span><br><span class="line">            Event event = <span class="keyword">new</span> Event(username, url, currTs);</span><br><span class="line">            <span class="comment">// 使用collectWithTimestamp方法将数据发送出去，并指明数据中的时间戳的字段</span></span><br><span class="line">            sourceContext.collectWithTimestamp(event, event.timestamp);</span><br><span class="line">            <span class="comment">// 发送水位线</span></span><br><span class="line">            sourceContext.emitWatermark(<span class="keyword">new</span> Watermark(event.timestamp - <span class="number">1L</span>));</span><br><span class="line">            Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        running = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ProcessFunction-API"><a href="#ProcessFunction-API" class="headerlink" title="ProcessFunction API"></a>ProcessFunction API</h2><p>处理函数提供了一个定时服务 (TimerService)，我们可以通过它访问流中的事件(event)、时间戳(timestamp)、水位线 (watermark)，甚至可以注册定时事件。而且处理函数继承了 AbstractRichFunction 抽象类，所以拥有富函数类的所有特性，同样可以访问状态(state)和其他运行时信息。此外，处理函数还可以直接将数据输出到侧输出流(side output)中。所以，处理函数是最为灵活的处理方法，可以实现各种自定义的业务逻辑；同时也是整个 DataStream API 的底层基础。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A function that processes elements of a stream.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;For every element in the input stream &#123;<span class="doctag">@link</span> #processElement(Object, Context, Collector)&#125; is</span></span><br><span class="line"><span class="comment"> * invoked. This can produce zero or more elements as output. Implementations can also query the</span></span><br><span class="line"><span class="comment"> * time and set timers through the provided &#123;<span class="doctag">@link</span> Context&#125;. For firing timers &#123;<span class="doctag">@link</span> #onTimer(long,</span></span><br><span class="line"><span class="comment"> * OnTimerContext, Collector)&#125; will be invoked. This can again produce zero or more elements as</span></span><br><span class="line"><span class="comment"> * output and register further timers.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;<span class="doctag">NOTE:</span>&lt;/b&gt; Access to keyed state and timers (which are also scoped to a key) is only</span></span><br><span class="line"><span class="comment"> * available if the &#123;<span class="doctag">@code</span> ProcessFunction&#125; is applied on a &#123;<span class="doctag">@code</span> KeyedStream&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;<span class="doctag">NOTE:</span>&lt;/b&gt; A &#123;<span class="doctag">@code</span> ProcessFunction&#125; is always a &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * org.apache.flink.api.common.functions.RichFunction&#125;. Therefore, access to the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * org.apache.flink.api.common.functions.RuntimeContext&#125; is always available and setup and teardown</span></span><br><span class="line"><span class="comment"> * methods can be implemented. See &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * org.apache.flink.api.common.functions.RichFunction#open(org.apache.flink.configuration.Configuration)&#125;</span></span><br><span class="line"><span class="comment"> * and &#123;<span class="doctag">@link</span> org.apache.flink.api.common.functions.RichFunction#close()&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;I&gt; Type of the input elements.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;O&gt; Type of the output elements.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PublicEvolving</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessFunction</span>&lt;<span class="title">I</span>, <span class="title">O</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractRichFunction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Process one element from the input stream.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This function can output zero or more elements using the &#123;<span class="doctag">@link</span> Collector&#125; parameter and</span></span><br><span class="line"><span class="comment">     * also update internal state or set timers using the &#123;<span class="doctag">@link</span> Context&#125; parameter.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value The input value.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx A &#123;<span class="doctag">@link</span> Context&#125; that allows querying the timestamp of the element and getting a</span></span><br><span class="line"><span class="comment">     *     &#123;<span class="doctag">@link</span> TimerService&#125; for registering timers and querying the time. The context is only</span></span><br><span class="line"><span class="comment">     *     valid during the invocation of this method, do not store it.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> out The collector for returning result values.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception This method may throw exceptions. Throwing an exception will cause the</span></span><br><span class="line"><span class="comment">     *     operation to fail and may trigger recovery.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(I value, Context ctx, Collector&lt;O&gt; out)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Called when a timer set using &#123;<span class="doctag">@link</span> TimerService&#125; fires.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timestamp The timestamp of the firing timer.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx An &#123;<span class="doctag">@link</span> OnTimerContext&#125; that allows querying the timestamp of the firing timer,</span></span><br><span class="line"><span class="comment">     *     querying the &#123;<span class="doctag">@link</span> TimeDomain&#125; of the firing timer and getting a &#123;<span class="doctag">@link</span> TimerService&#125;</span></span><br><span class="line"><span class="comment">     *     for registering timers and querying the time. The context is only valid during the</span></span><br><span class="line"><span class="comment">     *     invocation of this method, do not store it.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> out The collector for returning result values.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception This method may throw exceptions. Throwing an exception will cause the</span></span><br><span class="line"><span class="comment">     *     operation to fail and may trigger recovery.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTimer</span><span class="params">(<span class="keyword">long</span> timestamp, OnTimerContext ctx, Collector&lt;O&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Information available in an invocation of &#123;<span class="doctag">@link</span> #processElement(Object, Context, Collector)&#125;</span></span><br><span class="line"><span class="comment">     * or &#123;<span class="doctag">@link</span> #onTimer(long, OnTimerContext, Collector)&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Timestamp of the element currently being processed or timestamp of a firing timer.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;This might be &#123;<span class="doctag">@code</span> null&#125;, for example if the time characteristic of your program is</span></span><br><span class="line"><span class="comment">         * set to &#123;<span class="doctag">@link</span> org.apache.flink.streaming.api.TimeCharacteristic#ProcessingTime&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Long <span class="title">timestamp</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** A &#123;<span class="doctag">@link</span> TimerService&#125; for querying time and registering timers. */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> TimerService <span class="title">timerService</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Emits a record to the side output identified by the &#123;<span class="doctag">@link</span> OutputTag&#125;.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> outputTag the &#123;<span class="doctag">@code</span> OutputTag&#125; that identifies the side output to emit to.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> value The record to emit.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;X&gt; <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(OutputTag&lt;X&gt; outputTag, X value)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Information available in an invocation of &#123;<span class="doctag">@link</span> #onTimer(long, OnTimerContext, Collector)&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">OnTimerContext</span> <span class="keyword">extends</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** The &#123;<span class="doctag">@link</span> TimeDomain&#125; of the firing timer. */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> TimeDomain <span class="title">timeDomain</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    env</span><br><span class="line">            .addSource(<span class="keyword">new</span> ClickSource())</span><br><span class="line">            .assignTimestampsAndWatermarks(</span><br><span class="line">                    WatermarkStrategy.&lt;Event&gt;forMonotonousTimestamps()</span><br><span class="line">                            .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Event&gt;() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Event event, <span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">                                    <span class="keyword">return</span> event.timestamp;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;)</span><br><span class="line">            )</span><br><span class="line">            .process(<span class="keyword">new</span> ProcessFunction&lt;Event, String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(Event value, Context ctx, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (value.user.equals(<span class="string">&quot;Mary&quot;</span>)) &#123;</span><br><span class="line">                        out.collect(value.user);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value.user.equals(<span class="string">&quot;Bob&quot;</span>)) &#123;</span><br><span class="line">                        out.collect(value.user);</span><br><span class="line">                        out.collect(value.user);</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(ctx.timerService().currentWatermark());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象类 ProcessFunction 继承了 AbstractRichFunction，有两个泛型类型参数：I 表示 Input，也就是输入的数据类型；O 表示 Output，也就是处理完成之后输出的数据类型。</p>
<p>内部单独定义了两个方法：一个是必须要实现的抽象方法.processElement()；另一个是非抽象方法.onTimer()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessFunction</span>&lt;<span class="title">I</span>, <span class="title">O</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractRichFunction</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(I value, Context ctx, Collector&lt;O&gt; out)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTimer</span><span class="params">(<span class="keyword">long</span> timestamp, OnTimerContext ctx, Collector&lt;O&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>processElement()：</strong></p>
<p>value：当前流中的输入元素，也就是正在处理的数据，类型与流中数据类型一致。</p>
<p>ctx：类型是ProcessFunction中定义的内部抽象类Context，表示当前运行的上下文，可以获取到当前的时间戳，并提供了用于查询时间和注册定时器的定时服务(TimerService)，以及可以将数据发送到侧输出流(side output)的方法.output()。 Context 抽象类定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Long <span class="title">timestamp</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> TimerService <span class="title">timerService</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;X&gt; <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(OutputTag&lt;X&gt; outputTag, X value)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>out：收集器(类型为Collector)，用于返回输出数据。使用方式与 flatMap 算子中的收集器完全一样，直接调用 out.collect()方法就可以向下游发出一个数据。 这个方法可以多次调用，也可以不调用。</p>
<p><strong>onTimer()：</strong></p>
<p>用于定义定时触发的操作，这是一个非常强大、也非常有趣的功能。<strong>这个方法只有在注册好的定时器触发的时候才会调用，而定时器是通过定时服务TimerService来注册的</strong>。打个比方，注册定时器(timer)就是设了一个闹钟，到了设定时间就会响；而.onTimer()中定义的， 就是闹钟响的时候要做的事。所以它本质上是一个基于时间的回调(callback)方法，通过时间的进展来触发；在事件时间语义下就是由水位线(watermark)来触发了。</p>
<p>与.processElement()类似，定时方法.onTimer()也有三个参数：时间戳(timestamp)，上下文(ctx)，以及收集器(out)。这里的 timestamp 是指设定好的触发时间，事件时间语义下当然就是水位线了。另外这里同样有上下文和收集器，所以也可以调用定时服务(TimerService)， 以及任意输出处理之后的数据。</p>
<p>既然有.onTimer()方法做定时触发，我们用 ProcessFunction 也可以自定义数据按照时间分组、定时触发计算输出结果；这其实就实现了窗口(window)的功能。所以说 ProcessFunction 是真正意义上的终极奥义，用它可以实现一切功能。</p>
<p>我们也可以看到，处理函数都是基于事件触发的。水位线就如同插入流中的一条数据一样；只不过处理真正的数据事件调用的是.processElement()方法，而处理水位线事件调用的是.onTimer()。</p>
<p>这里需要注意的是，上面的.onTimer()方法只是定时器触发时的操作，而定时器(timer) 真正的设置需要用到上下文 ctx 中的定时服务。在 Flink 中，只有按键分区流 KeyedStream 才支持设置定时器的操作。</p>
<p><strong>Flink 提供了 8 个不同的处理函数：</strong></p>
<h3 id="ProcessFunction"><a href="#ProcessFunction" class="headerlink" title="ProcessFunction"></a>ProcessFunction</h3><p>最基本的处理函数，基于 DataStream 直接调用.process()时作为参数传入。</p>
<h3 id="KeyedProcessFunction"><a href="#KeyedProcessFunction" class="headerlink" title="KeyedProcessFunction"></a>KeyedProcessFunction</h3><p>对流按键分区后的处理函数，基于 KeyedStream 调用.process()时作为参数传入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A keyed function that processes elements of a stream.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;For every element in the input stream &#123;<span class="doctag">@link</span> #processElement(Object, Context, Collector)&#125; is</span></span><br><span class="line"><span class="comment"> * invoked. This can produce zero or more elements as output. Implementations can also query the</span></span><br><span class="line"><span class="comment"> * time and set timers through the provided &#123;<span class="doctag">@link</span> Context&#125;. For firing timers &#123;<span class="doctag">@link</span> #onTimer(long,</span></span><br><span class="line"><span class="comment"> * OnTimerContext, Collector)&#125; will be invoked. This can again produce zero or more elements as</span></span><br><span class="line"><span class="comment"> * output and register further timers.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;<span class="doctag">NOTE:</span>&lt;/b&gt; Access to keyed state and timers (which are also scoped to a key) is only</span></span><br><span class="line"><span class="comment"> * available if the &#123;<span class="doctag">@code</span> KeyedProcessFunction&#125; is applied on a &#123;<span class="doctag">@code</span> KeyedStream&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;b&gt;<span class="doctag">NOTE:</span>&lt;/b&gt; A &#123;<span class="doctag">@code</span> KeyedProcessFunction&#125; is always a &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * org.apache.flink.api.common.functions.RichFunction&#125;. Therefore, access to the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * org.apache.flink.api.common.functions.RuntimeContext&#125; is always available and setup and teardown</span></span><br><span class="line"><span class="comment"> * methods can be implemented. See &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment"> * org.apache.flink.api.common.functions.RichFunction#open(org.apache.flink.configuration.Configuration)&#125;</span></span><br><span class="line"><span class="comment"> * and &#123;<span class="doctag">@link</span> org.apache.flink.api.common.functions.RichFunction#close()&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;K&gt; Type of the key.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;I&gt; Type of the input elements.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;O&gt; Type of the output elements.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PublicEvolving</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyedProcessFunction</span>&lt;<span class="title">K</span>, <span class="title">I</span>, <span class="title">O</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractRichFunction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Process one element from the input stream.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This function can output zero or more elements using the &#123;<span class="doctag">@link</span> Collector&#125; parameter and</span></span><br><span class="line"><span class="comment">     * also update internal state or set timers using the &#123;<span class="doctag">@link</span> Context&#125; parameter.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value The input value.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx A &#123;<span class="doctag">@link</span> Context&#125; that allows querying the timestamp of the element and getting a</span></span><br><span class="line"><span class="comment">     *     &#123;<span class="doctag">@link</span> TimerService&#125; for registering timers and querying the time. The context is only</span></span><br><span class="line"><span class="comment">     *     valid during the invocation of this method, do not store it.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> out The collector for returning result values.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception This method may throw exceptions. Throwing an exception will cause the</span></span><br><span class="line"><span class="comment">     *     operation to fail and may trigger recovery.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(I value, Context ctx, Collector&lt;O&gt; out)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Called when a timer set using &#123;<span class="doctag">@link</span> TimerService&#125; fires.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timestamp The timestamp of the firing timer.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx An &#123;<span class="doctag">@link</span> OnTimerContext&#125; that allows querying the timestamp, the &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     *     TimeDomain&#125;, and the key of the firing timer and getting a &#123;<span class="doctag">@link</span> TimerService&#125; for</span></span><br><span class="line"><span class="comment">     *     registering timers and querying the time. The context is only valid during the invocation</span></span><br><span class="line"><span class="comment">     *     of this method, do not store it.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> out The collector for returning result values.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception This method may throw exceptions. Throwing an exception will cause the</span></span><br><span class="line"><span class="comment">     *     operation to fail and may trigger recovery.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTimer</span><span class="params">(<span class="keyword">long</span> timestamp, OnTimerContext ctx, Collector&lt;O&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Information available in an invocation of &#123;<span class="doctag">@link</span> #processElement(Object, Context, Collector)&#125;</span></span><br><span class="line"><span class="comment">     * or &#123;<span class="doctag">@link</span> #onTimer(long, OnTimerContext, Collector)&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Timestamp of the element currently being processed or timestamp of a firing timer.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;This might be &#123;<span class="doctag">@code</span> null&#125;, for example if the time characteristic of your program is</span></span><br><span class="line"><span class="comment">         * set to &#123;<span class="doctag">@link</span> org.apache.flink.streaming.api.TimeCharacteristic#ProcessingTime&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Long <span class="title">timestamp</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** A &#123;<span class="doctag">@link</span> TimerService&#125; for querying time and registering timers. */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> TimerService <span class="title">timerService</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Emits a record to the side output identified by the &#123;<span class="doctag">@link</span> OutputTag&#125;.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> outputTag the &#123;<span class="doctag">@code</span> OutputTag&#125; that identifies the side output to emit to.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> value The record to emit.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;X&gt; <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(OutputTag&lt;X&gt; outputTag, X value)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Get key of the element being processed. */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> K <span class="title">getCurrentKey</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Information available in an invocation of &#123;<span class="doctag">@link</span> #onTimer(long, OnTimerContext, Collector)&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">OnTimerContext</span> <span class="keyword">extends</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** The &#123;<span class="doctag">@link</span> TimeDomain&#125; of the firing timer. */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> TimeDomain <span class="title">timeDomain</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Get key of the firing timer. */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> K <span class="title">getCurrentKey</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="定时器-Timer-和定时服务-TimerService"><a href="#定时器-Timer-和定时服务-TimerService" class="headerlink" title="定时器(Timer)和定时服务(TimerService)"></a>定时器(Timer)和定时服务(TimerService)</h4><p>定时器(timers)是处理函数中进行时间相关操作的主要机制。在.onTimer()方法中可以实现定时处理的逻辑，而它能触发的前提，就是之前曾经注册过定时器、并且现在已经到了触发时间。注册定时器的功能，是通过上下文中提供的定时服务(TimerService)来实现的。</p>
<p>TimerService 是 Flink 关于时间和定时器的基础服务接口，包含以下六个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前的处理时间</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">currentProcessingTime</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前的水位线(事件时间) </span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">currentWatermark</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册处理时间定时器，当处理时间超过 time 时触发 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerProcessingTimeTimer</span><span class="params">(<span class="keyword">long</span> time)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册事件时间定时器，当水位线超过 time 时触发 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerEventTimeTimer</span><span class="params">(<span class="keyword">long</span> time)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除触发时间为 time 的处理时间定时器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteProcessingTimeTimer</span><span class="params">(<span class="keyword">long</span> time)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除触发时间为 time 的处理时间定时器 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteEventTimeTimer</span><span class="params">(<span class="keyword">long</span> time)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>需要注意，尽管处理函数中都可以直接访问 TimerService，不过只有基于 KeyedStream 的处理函数，才能去调用注册和删除定时器的方法；未作按键分区的 DataStream 不支持定时器操作，只能获取当前时间。</strong></p>
<p>基于 KeyedStream 注册定时器时，会传入一个定时器触发的时间戳，这个时间戳的定时器对于每个 key 都是有效的。这样，我们的代码并不需要做额外的处理，底层就可以直接对不同 key 进行独立的处理操作了。</p>
<p>利用这个特性，有时我们可以故意降低时间戳的精度，来减少定时器的数量，从而提高处理性能。比如我们可以在设置定时器时只保留整秒数，那么定时器的触发频率就是最多 1 秒一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> coalescedTime = time / <span class="number">1000</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">ctx.timerService().registerProcessingTimeTimer(coalescedTime);</span><br></pre></td></tr></table></figure>

<p>这里注意<strong>定时器的时间戳必须是毫秒数</strong>，所以我们得到整秒之后还要乘以1000。定时器默认的区分精度是毫秒。</p>
<p><strong>EventTimeTimerTest：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    SingleOutputStreamOperator&lt;Event&gt; stream = env.addSource(<span class="keyword">new</span> CustomSource())</span><br><span class="line">            .assignTimestampsAndWatermarks(WatermarkStrategy.&lt;Event&gt;forMonotonousTimestamps()</span><br><span class="line">                    .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Event&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Event element, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> element.timestamp;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于KeyedStream定义事件时间定时器</span></span><br><span class="line">    stream.keyBy(data -&gt; <span class="keyword">true</span>)</span><br><span class="line">            .process(<span class="keyword">new</span> KeyedProcessFunction&lt;Boolean, Event, String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(Event value, Context ctx, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    out.collect(<span class="string">&quot;数据到达，时间戳为：&quot;</span> + ctx.timestamp());</span><br><span class="line">                    out.collect(<span class="string">&quot;数据到达，水位线为：&quot;</span> + ctx.timerService().currentWatermark() + <span class="string">&quot;\n -------分割线-------&quot;</span>);</span><br><span class="line">                    <span class="comment">// 注册一个10秒后的定时器</span></span><br><span class="line">                    ctx.timerService().registerEventTimeTimer(ctx.timestamp() + <span class="number">10</span> * <span class="number">1000L</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTimer</span><span class="params">(<span class="keyword">long</span> timestamp, OnTimerContext ctx, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    out.collect(<span class="string">&quot;定时器触发，触发时间：&quot;</span> + timestamp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义测试数据源</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomSource</span> <span class="keyword">implements</span> <span class="title">SourceFunction</span>&lt;<span class="title">Event</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(SourceContext&lt;Event&gt; ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 直接发出测试数据</span></span><br><span class="line">        ctx.collect(<span class="keyword">new</span> Event(<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">1000L</span>));</span><br><span class="line">        <span class="comment">// 为了更加明显，中间停顿5秒钟</span></span><br><span class="line">        Thread.sleep(<span class="number">5000L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发出10秒后的数据</span></span><br><span class="line">        ctx.collect(<span class="keyword">new</span> Event(<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">11000L</span>));</span><br><span class="line">        Thread.sleep(<span class="number">5000L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发出10秒+1ms后的数据</span></span><br><span class="line">        ctx.collect(<span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./cart&quot;</span>, <span class="number">11001L</span>));</span><br><span class="line">        Thread.sleep(<span class="number">5000L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="KeyedProcessTopN"><a href="#KeyedProcessTopN" class="headerlink" title="KeyedProcessTopN"></a>KeyedProcessTopN</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//KeyedProcessTopN</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从自定义数据源读取数据</span></span><br><span class="line">    SingleOutputStreamOperator&lt;Event&gt; eventStream = env.addSource(<span class="keyword">new</span> ClickSource())</span><br><span class="line">            .assignTimestampsAndWatermarks(WatermarkStrategy.&lt;Event&gt;forMonotonousTimestamps()</span><br><span class="line">                    .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Event&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Event element, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> element.timestamp;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要按照url分组，求出每个url的访问量</span></span><br><span class="line">    SingleOutputStreamOperator&lt;UrlViewCount&gt; urlCountStream =</span><br><span class="line">            eventStream.keyBy(data -&gt; data.url)</span><br><span class="line">                    .window(SlidingEventTimeWindows.of(Time.seconds(<span class="number">10</span>), Time.seconds(<span class="number">5</span>)))</span><br><span class="line">                    .aggregate(<span class="keyword">new</span> UrlViewCountAgg(),</span><br><span class="line">                            <span class="keyword">new</span> UrlViewCountResult());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对结果中同一个窗口的统计数据，进行排序处理</span></span><br><span class="line">    SingleOutputStreamOperator&lt;String&gt; result = urlCountStream.keyBy(data -&gt; data.windowEnd)</span><br><span class="line">            .process(<span class="keyword">new</span> TopN(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    result.print(<span class="string">&quot;result&quot;</span>);</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义增量聚合</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UrlViewCountAgg</span> <span class="keyword">implements</span> <span class="title">AggregateFunction</span>&lt;<span class="title">Event</span>, <span class="title">Long</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">createAccumulator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">add</span><span class="params">(Event value, Long accumulator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accumulator + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getResult</span><span class="params">(Long accumulator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accumulator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">merge</span><span class="params">(Long a, Long b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义全窗口函数，只需要包装窗口信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UrlViewCountResult</span> <span class="keyword">extends</span> <span class="title">ProcessWindowFunction</span>&lt;<span class="title">Long</span>, <span class="title">UrlViewCount</span>, <span class="title">String</span>, <span class="title">TimeWindow</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String url, Context context, Iterable&lt;Long&gt; elements, Collector&lt;UrlViewCount&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 结合窗口信息，包装输出内容</span></span><br><span class="line">        Long start = context.window().getStart();</span><br><span class="line">        Long end = context.window().getEnd();</span><br><span class="line">        out.collect(<span class="keyword">new</span> UrlViewCount(url, elements.iterator().next(), start, end));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义处理函数，排序取top n</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TopN</span> <span class="keyword">extends</span> <span class="title">KeyedProcessFunction</span>&lt;<span class="title">Long</span>, <span class="title">UrlViewCount</span>, <span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 将n作为属性</span></span><br><span class="line">    <span class="keyword">private</span> Integer n;</span><br><span class="line">    <span class="comment">// 定义一个列表状态</span></span><br><span class="line">    <span class="keyword">private</span> ListState&lt;UrlViewCount&gt; urlViewCountListState;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TopN</span><span class="params">(Integer n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 从环境中获取列表状态</span></span><br><span class="line">        urlViewCountListState = getRuntimeContext().getListState(</span><br><span class="line">                <span class="keyword">new</span> ListStateDescriptor&lt;UrlViewCount&gt;(<span class="string">&quot;url-view-count-list&quot;</span>,</span><br><span class="line">                        Types.POJO(UrlViewCount.class)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(UrlViewCount value, Context ctx, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 将count数据添加到列表状态中，保存起来</span></span><br><span class="line">        urlViewCountListState.add(value);</span><br><span class="line">        <span class="comment">// 注册 window end + 1ms后的定时器，等待所有数据到齐开始排序</span></span><br><span class="line">        ctx.timerService().registerEventTimeTimer(ctx.getCurrentKey() + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTimer</span><span class="params">(<span class="keyword">long</span> timestamp, OnTimerContext ctx, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 将数据从列表状态变量中取出，放入ArrayList，方便排序</span></span><br><span class="line">        ArrayList&lt;UrlViewCount&gt; urlViewCountArrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (UrlViewCount urlViewCount : urlViewCountListState.get()) &#123;</span><br><span class="line">            urlViewCountArrayList.add(urlViewCount);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 清空状态，释放资源</span></span><br><span class="line">        urlViewCountListState.clear();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 排序</span></span><br><span class="line">        urlViewCountArrayList.sort(<span class="keyword">new</span> Comparator&lt;UrlViewCount&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(UrlViewCount o1, UrlViewCount o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2.count.intValue() - o1.count.intValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取前两名，构建输出结果</span></span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        result.append(<span class="string">&quot;========================================\n&quot;</span>);</span><br><span class="line">        result.append(<span class="string">&quot;窗口结束时间：&quot;</span> + <span class="keyword">new</span> Timestamp(timestamp - <span class="number">1</span>) + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.n; i++) &#123;</span><br><span class="line">            UrlViewCount UrlViewCount = urlViewCountArrayList.get(i);</span><br><span class="line">            String info = <span class="string">&quot;No.&quot;</span> + (i + <span class="number">1</span>) + <span class="string">&quot; &quot;</span></span><br><span class="line">                    + <span class="string">&quot;url：&quot;</span> + UrlViewCount.url + <span class="string">&quot; &quot;</span></span><br><span class="line">                    + <span class="string">&quot;浏览量：&quot;</span> + UrlViewCount.count + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">            result.append(info);</span><br><span class="line">        &#125;</span><br><span class="line">        result.append(<span class="string">&quot;========================================\n&quot;</span>);</span><br><span class="line">        out.collect(result.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ProcessWindowFunction-1"><a href="#ProcessWindowFunction-1" class="headerlink" title="ProcessWindowFunction"></a>ProcessWindowFunction</h3><p>开窗之后的处理函数，也是全窗口函数的代表。基于 WindowedStream 调用.process()时作为参数传入。</p>
<p>ProcessWindowFunction 既是处理函数又是全窗口函数。从名字上也可以推测出，它的本质似乎更倾向于窗口函数一些。事实上它的用法也确实跟其他处理函数有很大不同。我们可以从源码中的定义看到这一点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessWindowFunction</span>&lt;<span class="title">IN</span>, <span class="title">OUT</span>, <span class="title">KEY</span>, <span class="title">W</span> <span class="keyword">extends</span> <span class="title">Window</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractRichFunction</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(KEY key, Context context, Iterable&lt;IN&gt; elements, Collector&lt;OUT&gt; out)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="comment">//key:窗口做统计计算基于的键，也就是之前keyBy用来分区的字段</span></span><br><span class="line">    <span class="comment">//context:当前窗口进行计算的上下文，它的类型就是ProcessWindowFunction内部定义的抽象类Context</span></span><br><span class="line">    <span class="comment">//elements:窗口收集到用来计算的所有数据，这是一个可迭代的集合类型</span></span><br><span class="line">    <span class="comment">//out:用来发送数据输出计算结果的收集器，类型为Collector</span></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(Context context)</span> <span class="keyword">throws</span> Exception </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上下文context所包含的内容也跟其他处理函数有所差别</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** Returns the window that is being evaluated. */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> W <span class="title">window</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/** Returns the current processing time. */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">currentProcessingTime</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/** Returns the current event-time watermark. */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">currentWatermark</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * State accessor for per-key and per-window state.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;&lt;b&gt;<span class="doctag">NOTE:</span>&lt;/b&gt;If you use per-window state you have to ensure that you clean it up by</span></span><br><span class="line"><span class="comment">         * implementing &#123;<span class="doctag">@link</span> ProcessWindowFunction#clear(Context)&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> KeyedStateStore <span class="title">windowState</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/** State accessor for per-key global state. */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> KeyedStateStore <span class="title">globalState</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Emits a record to the side output identified by the &#123;<span class="doctag">@link</span> OutputTag&#125;.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> outputTag the &#123;<span class="doctag">@code</span> OutputTag&#125; that identifies the side output to emit to.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> value The record to emit.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;X&gt; <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(OutputTag&lt;X&gt; outputTag, X value)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ProcessAllWindowFunction"><a href="#ProcessAllWindowFunction" class="headerlink" title="ProcessAllWindowFunction"></a>ProcessAllWindowFunction</h3><p>同样是开窗之后的处理函数，基于 AllWindowedStream 调用.process()时作为参数传入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Base abstract class for functions that are evaluated over non-keyed windows using a context for</span></span><br><span class="line"><span class="comment"> * retrieving extra information.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;IN&gt; The type of the input value.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;OUT&gt; The type of the output value.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;W&gt; The type of &#123;<span class="doctag">@code</span> Window&#125; that this window function can be applied on.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PublicEvolving</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessAllWindowFunction</span>&lt;<span class="title">IN</span>, <span class="title">OUT</span>, <span class="title">W</span> <span class="keyword">extends</span> <span class="title">Window</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractRichFunction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Evaluates the window and outputs none or several elements.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context The context in which the window is being evaluated.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> elements The elements in the window being evaluated.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> out A collector for emitting elements.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception The function may throw exceptions to fail the program and trigger recovery.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Context context, Iterable&lt;IN&gt; elements, Collector&lt;OUT&gt; out)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Deletes any state in the &#123;<span class="doctag">@code</span> Context&#125; when the Window expires (the watermark passes its</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> maxTimestamp&#125; + &#123;<span class="doctag">@code</span> allowedLateness&#125;).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context The context to which the window is being evaluated</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception The function may throw exceptions to fail the program and trigger recovery.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(Context context)</span> <span class="keyword">throws</span> Exception </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The context holding window metadata. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** <span class="doctag">@return</span> The window that is being evaluated. */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> W <span class="title">window</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * State accessor for per-key and per-window state.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;&lt;b&gt;<span class="doctag">NOTE:</span>&lt;/b&gt;If you use per-window state you have to ensure that you clean it up by</span></span><br><span class="line"><span class="comment">         * implementing &#123;<span class="doctag">@link</span> ProcessWindowFunction#clear(ProcessWindowFunction.Context)&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> KeyedStateStore <span class="title">windowState</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** State accessor for per-key global state. */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> KeyedStateStore <span class="title">globalState</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Emits a record to the side output identified by the &#123;<span class="doctag">@link</span> OutputTag&#125;.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> outputTag the &#123;<span class="doctag">@code</span> OutputTag&#125; that identifies the side output to emit to.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> value The record to emit.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;X&gt; <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(OutputTag&lt;X&gt; outputTag, X value)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ProcessAllWindowTopN"><a href="#ProcessAllWindowTopN" class="headerlink" title="ProcessAllWindowTopN"></a>ProcessAllWindowTopN</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ProcessAllWindowTopN</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    SingleOutputStreamOperator&lt;Event&gt; eventStream = env.addSource(<span class="keyword">new</span> ClickSource())</span><br><span class="line">            .assignTimestampsAndWatermarks(</span><br><span class="line">                    WatermarkStrategy.&lt;Event&gt;forMonotonousTimestamps()</span><br><span class="line">                            .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Event&gt;() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Event element, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                                    <span class="keyword">return</span> element.timestamp;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;)</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只需要url就可以统计数量，所以转换成String直接开窗统计</span></span><br><span class="line">    SingleOutputStreamOperator&lt;String&gt; result = eventStream</span><br><span class="line">            .map(<span class="keyword">new</span> MapFunction&lt;Event, String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">map</span><span class="params">(Event value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> value.url;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .windowAll(SlidingEventTimeWindows.of(Time.seconds(<span class="number">10</span>), Time.seconds(<span class="number">5</span>)))    <span class="comment">// 开滑动窗口</span></span><br><span class="line">            .process(<span class="keyword">new</span> ProcessAllWindowFunction&lt;String, String, TimeWindow&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(Context context, Iterable&lt;String&gt; elements, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    HashMap&lt;String, Long&gt; urlCountMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                    <span class="comment">// 遍历窗口中数据，将浏览量保存到一个 HashMap 中</span></span><br><span class="line">                    <span class="keyword">for</span> (String url : elements) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (urlCountMap.containsKey(url)) &#123;</span><br><span class="line">                            <span class="keyword">long</span> count = urlCountMap.get(url);</span><br><span class="line">                            urlCountMap.put(url, count + <span class="number">1L</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            urlCountMap.put(url, <span class="number">1L</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ArrayList&lt;Tuple2&lt;String, Long&gt;&gt; mapList = <span class="keyword">new</span> ArrayList&lt;Tuple2&lt;String, Long&gt;&gt;();</span><br><span class="line">                    <span class="comment">// 将浏览量数据放入ArrayList，进行排序</span></span><br><span class="line">                    <span class="keyword">for</span> (String key : urlCountMap.keySet()) &#123;</span><br><span class="line">                        mapList.add(Tuple2.of(key, urlCountMap.get(key)));</span><br><span class="line">                    &#125;</span><br><span class="line">                    mapList.sort(<span class="keyword">new</span> Comparator&lt;Tuple2&lt;String, Long&gt;&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Tuple2&lt;String, Long&gt; o1, Tuple2&lt;String, Long&gt; o2)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> o2.f1.intValue() - o1.f1.intValue();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="comment">// 取排序后的前两名，构建输出结果</span></span><br><span class="line">                    StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                    result.append(<span class="string">&quot;========================================\n&quot;</span>);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                        Tuple2&lt;String, Long&gt; temp = mapList.get(i);</span><br><span class="line">                        String info = <span class="string">&quot;浏览量No.&quot;</span> + (i + <span class="number">1</span>) +</span><br><span class="line">                                <span class="string">&quot; url：&quot;</span> + temp.f0 +</span><br><span class="line">                                <span class="string">&quot; 浏览量：&quot;</span> + temp.f1 +</span><br><span class="line">                                <span class="string">&quot; 窗口结束时间：&quot;</span> + <span class="keyword">new</span> Timestamp(context.window().getEnd()) + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">                        result.append(info);</span><br><span class="line">                    &#125;</span><br><span class="line">                    result.append(<span class="string">&quot;========================================\n&quot;</span>);</span><br><span class="line">                    out.collect(result.toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">    result.print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CoProcessFunction"><a href="#CoProcessFunction" class="headerlink" title="CoProcessFunction"></a>CoProcessFunction</h3><p>合并(connect)两条流之后的处理函数，基于 ConnectedStreams 调用.process()时作为参数传入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CoProcessFunction</span>&lt;<span class="title">IN1</span>, <span class="title">IN2</span>, <span class="title">OUT</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractRichFunction</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">processElement1</span><span class="params">(IN1 value, Context ctx, Collector&lt;OUT&gt; out)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">processElement2</span><span class="params">(IN2 value, Context ctx, Collector&lt;OUT&gt; out)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTimer</span><span class="params">(<span class="keyword">long</span> timestamp, OnTimerContext ctx, Collector&lt;OUT&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;...&#125;</span><br><span class="line">    </span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它需要实现的就是 processElement1()、processElement2()两个方法，在每个数据到来时，会根据来源的流调用其中的一个方法进行处理。CoProcessFunction同样可以通过上下文ctx来访问 timestamp、水位线，并通过 TimerService 注册定时器；另外也提供了.onTimer()方法，用于定义定时触发的处理操作。</p>
<h4 id="实时对账"><a href="#实时对账" class="headerlink" title="实时对账"></a>实时对账</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BillCheckExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 来自app的支付日志</span></span><br><span class="line">        SingleOutputStreamOperator&lt;Tuple3&lt;String, String, Long&gt;&gt; appStream = env.fromElements(</span><br><span class="line">                Tuple3.of(<span class="string">&quot;order-1&quot;</span>, <span class="string">&quot;app&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">                Tuple3.of(<span class="string">&quot;order-2&quot;</span>, <span class="string">&quot;app&quot;</span>, <span class="number">2000L</span>)</span><br><span class="line">        ).assignTimestampsAndWatermarks(WatermarkStrategy.&lt;Tuple3&lt;String, String, Long&gt;&gt;forMonotonousTimestamps()</span><br><span class="line">                .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Tuple3&lt;String, String, Long&gt;&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Tuple3&lt;String, String, Long&gt; element, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> element.f2;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 来自第三方支付平台的支付日志</span></span><br><span class="line">        SingleOutputStreamOperator&lt;Tuple4&lt;String, String, String, Long&gt;&gt; thirdpartStream = env.fromElements(</span><br><span class="line">                Tuple4.of(<span class="string">&quot;order-1&quot;</span>, <span class="string">&quot;third-party&quot;</span>, <span class="string">&quot;success&quot;</span>, <span class="number">3000L</span>),</span><br><span class="line">                Tuple4.of(<span class="string">&quot;order-3&quot;</span>, <span class="string">&quot;third-party&quot;</span>, <span class="string">&quot;success&quot;</span>, <span class="number">4000L</span>)</span><br><span class="line">        ).assignTimestampsAndWatermarks(WatermarkStrategy.&lt;Tuple4&lt;String, String, String, Long&gt;&gt;forMonotonousTimestamps()</span><br><span class="line">                .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Tuple4&lt;String, String, String, Long&gt;&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Tuple4&lt;String, String, String, Long&gt; element, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> element.f3;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检测同一支付单在两条流中是否匹配，不匹配就报警</span></span><br><span class="line">        appStream.connect(thirdpartStream)</span><br><span class="line">                .keyBy(data -&gt; data.f0, data -&gt; data.f0)</span><br><span class="line">                .process(<span class="keyword">new</span> OrderMatchResult())</span><br><span class="line">                .print();</span><br><span class="line"></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义实现CoProcessFunction</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderMatchResult</span> <span class="keyword">extends</span> <span class="title">CoProcessFunction</span>&lt;<span class="title">Tuple3</span>&lt;<span class="title">String</span>, <span class="title">String</span>, <span class="title">Long</span>&gt;, <span class="title">Tuple4</span>&lt;<span class="title">String</span>, <span class="title">String</span>, <span class="title">String</span>, <span class="title">Long</span>&gt;, <span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 定义状态变量，用来保存已经到达的事件</span></span><br><span class="line">        <span class="keyword">private</span> ValueState&lt;Tuple3&lt;String, String, Long&gt;&gt; appEventState;</span><br><span class="line">        <span class="keyword">private</span> ValueState&lt;Tuple4&lt;String, String, String, Long&gt;&gt; thirdPartyEventState;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            appEventState = getRuntimeContext().getState(</span><br><span class="line">                    <span class="keyword">new</span> ValueStateDescriptor&lt;Tuple3&lt;String, String, Long&gt;&gt;(<span class="string">&quot;app-event&quot;</span>, Types.TUPLE(Types.STRING, Types.STRING, Types.LONG))</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            thirdPartyEventState = getRuntimeContext().getState(</span><br><span class="line">                    <span class="keyword">new</span> ValueStateDescriptor&lt;Tuple4&lt;String, String, String, Long&gt;&gt;(<span class="string">&quot;thirdparty-event&quot;</span>, Types.TUPLE(Types.STRING, Types.STRING, Types.STRING,Types.LONG))</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement1</span><span class="params">(Tuple3&lt;String, String, Long&gt; value, Context ctx, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// 看另一条流中事件是否来过</span></span><br><span class="line">            <span class="keyword">if</span> (thirdPartyEventState.value() != <span class="keyword">null</span>)&#123;</span><br><span class="line">                out.collect(<span class="string">&quot;对账成功：&quot;</span> + value + <span class="string">&quot;  &quot;</span> + thirdPartyEventState.value());</span><br><span class="line">                <span class="comment">// 清空状态</span></span><br><span class="line">                thirdPartyEventState.clear();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 更新状态</span></span><br><span class="line">                appEventState.update(value);</span><br><span class="line">                <span class="comment">// 注册一个5秒后的定时器，开始等待另一条流的事件</span></span><br><span class="line">                ctx.timerService().registerEventTimeTimer(value.f2 + <span class="number">5000L</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement2</span><span class="params">(Tuple4&lt;String, String, String, Long&gt; value, Context ctx, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (appEventState.value() != <span class="keyword">null</span>)&#123;</span><br><span class="line">                out.collect(<span class="string">&quot;对账成功：&quot;</span> + appEventState.value() + <span class="string">&quot;  &quot;</span> + value);</span><br><span class="line">                <span class="comment">// 清空状态</span></span><br><span class="line">                appEventState.clear();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 更新状态</span></span><br><span class="line">                thirdPartyEventState.update(value);</span><br><span class="line">                <span class="comment">// 注册一个5秒后的定时器，开始等待另一条流的事件</span></span><br><span class="line">                ctx.timerService().registerEventTimeTimer(value.f3 + <span class="number">5000L</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTimer</span><span class="params">(<span class="keyword">long</span> timestamp, OnTimerContext ctx, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// 定时器触发，判断状态，如果某个状态不为空，说明另一条流中事件没来</span></span><br><span class="line">            <span class="keyword">if</span> (appEventState.value() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                out.collect(<span class="string">&quot;对账失败：&quot;</span> + appEventState.value() + <span class="string">&quot;  &quot;</span> + <span class="string">&quot;第三方支付平台信息未到&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (thirdPartyEventState.value() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                out.collect(<span class="string">&quot;对账失败：&quot;</span> + thirdPartyEventState.value() + <span class="string">&quot;  &quot;</span> + <span class="string">&quot;app信息未到&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            appEventState.clear();</span><br><span class="line">            thirdPartyEventState.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ProcessJoinFunction"><a href="#ProcessJoinFunction" class="headerlink" title="ProcessJoinFunction"></a>ProcessJoinFunction</h3><p>间隔连接(interval join)两条流之后的处理函数，基于 IntervalJoinedStream 调用.process()时作为参数传入。</p>
<h3 id="BroadcastProcessFunction"><a href="#BroadcastProcessFunction" class="headerlink" title="BroadcastProcessFunction"></a>BroadcastProcessFunction</h3><p>广播连接流处理函数，基于 BroadcastConnectedStream 调用.process()时作为参数传入。这里的广播连接流BroadcastConnectedStream，是一个未 keyBy 的普通 DataStream 与一个广播流(BroadcastStream)做连接(conncet)之后的产物。</p>
<p>这种连接方式往往用在需要动态定义某些规则或配置的场景。因为规则是实时变动的，所以我们可以用一个单独的流来获取规则数据；而这些规则或配置是对整个应用全局有效的，所以不能只把这数据传递给一个下游并行子任务处理，而是要广播(broadcast)给所有的并行子任务。而下游子任务收到广播出来的规则，会把它保存成一个状态，这就是所谓的广播状态(broadcast state)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BroadcastProcessFunction</span>&lt;<span class="title">IN1</span>, <span class="title">IN2</span>, <span class="title">OUT</span>&gt; <span class="keyword">extends</span> <span class="title">BaseBroadcastProcessFunction</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(IN1 value, ReadOnlyContext ctx, Collector&lt;OUT&gt; out)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">processBroadcastElement</span><span class="params">(IN2 value, Context ctx, Collector&lt;OUT&gt; out)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="KeyedBroadcastProcessFunction"><a href="#KeyedBroadcastProcessFunction" class="headerlink" title="KeyedBroadcastProcessFunction"></a>KeyedBroadcastProcessFunction</h3><p>按键分区的广播连接流处理函数，同样是基于 BroadcastConnectedStream 调用.process()时作为参数传入。与 BroadcastProcessFunction 不同的是，这时的广播连接流，是一个 KeyedStream 与广播流(BroadcastStream)做连接之后的产物。</p>
<h3 id="侧输出流-Side-Output"><a href="#侧输出流-Side-Output" class="headerlink" title="侧输出流(Side Output)"></a>侧输出流(Side Output)</h3><p>处理函数还有另外一个特有功能，就是将自定义的数据放入侧输出流(side output)输出。具体应用时，只要在处理函数的.processElement()或者.onTimer()方法中，调用上下文的.output()方法就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;Integer&gt; stream = env.addSource(...);</span><br><span class="line"></span><br><span class="line">SingleOutputStreamOperator&lt;Long&gt; longStream = stream.process(<span class="keyword">new</span> ProcessFunction&lt;Integer, Long&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">( Integer value, Context ctx, Collector&lt;Integer&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 转换成 Long，输出到主流中</span></span><br><span class="line">        out.collect(Long.valueOf(value));</span><br><span class="line">        <span class="comment">// 转换成 String，输出到侧输出流中</span></span><br><span class="line">        ctx.output(outputTag, <span class="string">&quot;side-output: &quot;</span> + String.valueOf(value));</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这里 output()方法需要传入两个参数，第一个是一个输出标签OutputTag，用来标识侧输出流，一般会在外部统一声明；第二个就是要输出的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先将 OutputTag 声明出来</span></span><br><span class="line">OutputTag&lt;String&gt; outputTag = <span class="keyword">new</span> OutputTag&lt;String&gt;(<span class="string">&quot;side-output&quot;</span>) &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>如果想要获取这个侧输出流，可以基于处理之后的 DataStream 直接调用.getSideOutput() 方法，传入对应的 OutputTag。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;String&gt; stringStream = longStream.getSideOutput(outputTag);</span><br></pre></td></tr></table></figure>

<h2 id="多流转换"><a href="#多流转换" class="headerlink" title="多流转换"></a>多流转换</h2><p>多流转换可以分为<strong>分流</strong>和<strong>合流</strong>两大类。目前分流的操作一般是通过侧输出流(side output)来实现，而合流的算子比较丰富，根据不同的需求可以调用 union、 connect、join 以及 coGroup 等接口进行连接合并操作。</p>
<h3 id="分流"><a href="#分流" class="headerlink" title="分流"></a>分流</h3><p>分流就是将一条数据流拆分成完全独立的两条、甚至多条流。也就是基于一个 DataStream，得到完全平等的多个子 DataStream。</p>
<h4 id="filter实现"><a href="#filter实现" class="headerlink" title="filter实现"></a>filter实现</h4><p>只要针对同一条流多次独立调用.filter()方法进行筛选，就可以得到拆分之后的流了。</p>
<p>例如，我们可以将电商网站收集到的用户行为数据进行一个拆分，根据类型(type)的不同，分为Mary的浏览数据、Bob的浏览数据等等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    SingleOutputStreamOperator&lt;Event&gt; stream = env</span><br><span class="line">            .addSource(<span class="keyword">new</span> ClickSource());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 筛选Mary的浏览行为放入MaryStream流中</span></span><br><span class="line">    DataStream&lt;Event&gt; MaryStream = stream.filter(<span class="keyword">new</span> FilterFunction&lt;Event&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(Event value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value.user.equals(<span class="string">&quot;Mary&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 筛选Bob的购买行为放入BobStream流中</span></span><br><span class="line">    DataStream&lt;Event&gt; BobStream = stream.filter(<span class="keyword">new</span> FilterFunction&lt;Event&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(Event value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value.user.equals(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 筛选其他人的浏览行为放入elseStream流中</span></span><br><span class="line">    DataStream&lt;Event&gt; elseStream = stream.filter(<span class="keyword">new</span> FilterFunction&lt;Event&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(Event value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> !value.user.equals(<span class="string">&quot;Mary&quot;</span>) &amp;&amp; !value.user.equals(<span class="string">&quot;Bob&quot;</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    MaryStream.print(<span class="string">&quot;Mary pv&quot;</span>);</span><br><span class="line">    BobStream.print(<span class="string">&quot;Bob pv&quot;</span>);</span><br><span class="line">    elseStream.print(<span class="string">&quot;else pv&quot;</span>);</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码背后的含义，是将原始数据流 stream 复制三份，然后对每一份分别做筛选；这明显是不够高效的。我们自然想到，能不能不用复制流，直接用一个算子就把它们都拆分开呢?</p>
<h4 id="侧输出流-1"><a href="#侧输出流-1" class="headerlink" title="侧输出流"></a>侧输出流</h4><p>处理函数本身可以认为是一个转换算子，它的输出类型是单一的，处理之后得到的仍然是一个 DataStream；而侧输出流则不受限制，可以任意自定义输出数据，它们就像从主流上分叉出的支流。尽管看起来主流和支流有所区别，不过实际上它们都是某种类型的 DataStream，所以本质上还是平等的。利用侧输出流就可以很方便地实现分流操作，而且得到的多条 DataStream <strong>类型可以不同</strong>，这就给我们的应用带来了极大的便利。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SplitStreamByOutputTag</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义输出标签，侧输出流的数据类型为三元组(user, url, timestamp)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> OutputTag&lt;Tuple3&lt;String, String, Long&gt;&gt; MaryTag = <span class="keyword">new</span> OutputTag&lt;Tuple3&lt;String, String, Long&gt;&gt;(<span class="string">&quot;Mary-pv&quot;</span>)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> OutputTag&lt;Tuple3&lt;String, String, Long&gt;&gt; BobTag = <span class="keyword">new</span> OutputTag&lt;Tuple3&lt;String, String, Long&gt;&gt;(<span class="string">&quot;Bob-pv&quot;</span>)&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        SingleOutputStreamOperator&lt;Event&gt; stream = env</span><br><span class="line">                .addSource(<span class="keyword">new</span> ClickSource());</span><br><span class="line"></span><br><span class="line">        SingleOutputStreamOperator&lt;Event&gt; processedStream = stream.process(<span class="keyword">new</span> ProcessFunction&lt;Event, Event&gt;() &#123;</span><br><span class="line">          </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(Event value, Context ctx, Collector&lt;Event&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (value.user.equals(<span class="string">&quot;Mary&quot;</span>))&#123;</span><br><span class="line">                    ctx.output(MaryTag, <span class="keyword">new</span> Tuple3&lt;&gt;(value.user, value.url, value.timestamp));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value.user.equals(<span class="string">&quot;Bob&quot;</span>))&#123;</span><br><span class="line">                    ctx.output(BobTag, <span class="keyword">new</span> Tuple3&lt;&gt;(value.user, value.url, value.timestamp));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    out.collect(value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        processedStream.getSideOutput(MaryTag).print(<span class="string">&quot;Mary pv&quot;</span>);</span><br><span class="line">        processedStream.getSideOutput(BobTag).print(<span class="string">&quot;Bob pv&quot;</span>);</span><br><span class="line">        processedStream.print(<span class="string">&quot;else&quot;</span>);</span><br><span class="line"></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="合流"><a href="#合流" class="headerlink" title="合流"></a>合流</h3><h4 id="联合-Union"><a href="#联合-Union" class="headerlink" title="联合(Union)"></a>联合(Union)</h4><p>联合操作要求必须流中的数据类型必须相同，合并之后的新流会包括所有流中的元素，数据类型不变。这种合流方式非常简单粗暴，就像公路上多个车道汇在一起一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//union()的参数可以是多个 DataStream，所以联合操作可以实现多条流的合并</span></span><br><span class="line">stream1.union(stream2, stream3, ...)</span><br></pre></td></tr></table></figure>

<p>注意，对于合流之后的水位线，也是要以最小的那个为准，这样才可以保证所有流都不会再传来之前的数据。换句话说，多流合并时处理的时效性是以最慢的那个流为准的。我们自然可以想到，这与之前介绍的并行任务水位线传递的规则是完全一致的；多条流的合并，某种意义上也可以看作是多个并行任务向同一个下游任务汇合的过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    SingleOutputStreamOperator&lt;Event&gt; stream1 = env.socketTextStream(<span class="string">&quot;linux1&quot;</span>, <span class="number">7777</span>)</span><br><span class="line">            .map(data -&gt; &#123;</span><br><span class="line">                String[] field = data.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Event(field[<span class="number">0</span>].trim(), field[<span class="number">1</span>].trim(), Long.valueOf(field[<span class="number">2</span>].trim()));</span><br><span class="line">            &#125;)</span><br><span class="line">            .assignTimestampsAndWatermarks(WatermarkStrategy.&lt;Event&gt;forBoundedOutOfOrderness(Duration.ofSeconds(<span class="number">2</span>))</span><br><span class="line">                    .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Event&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Event element, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> element.timestamp;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    stream1.print(<span class="string">&quot;stream1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    SingleOutputStreamOperator&lt;Event&gt; stream2 = env.socketTextStream(<span class="string">&quot;linux2&quot;</span>, <span class="number">7777</span>)</span><br><span class="line">            .map(data -&gt; &#123;</span><br><span class="line">                String[] field = data.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Event(field[<span class="number">0</span>].trim(), field[<span class="number">1</span>].trim(), Long.valueOf(field[<span class="number">2</span>].trim()));</span><br><span class="line">            &#125;)</span><br><span class="line">            .assignTimestampsAndWatermarks(WatermarkStrategy.&lt;Event&gt;forBoundedOutOfOrderness(Duration.ofSeconds(<span class="number">5</span>))</span><br><span class="line">                    .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Event&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Event element, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> element.timestamp;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    stream2.print(<span class="string">&quot;stream2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并两条流</span></span><br><span class="line">    stream1.union(stream2)</span><br><span class="line">            .process(<span class="keyword">new</span> ProcessFunction&lt;Event, String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(Event value, Context ctx, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    out.collect(<span class="string">&quot;水位线：&quot;</span> + ctx.timerService().currentWatermark());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .print();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="连接-Connect"><a href="#连接-Connect" class="headerlink" title="连接(Connect)"></a>连接(Connect)</h4><p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-03-25%20%E4%B8%8A%E5%8D%8812.08.27.png" alt="截屏2022-03-25 上午12.08.27"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    </span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    DataStream&lt;Integer&gt; stream1 = env.fromElements(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    DataStream&lt;Long&gt; stream2 = env.fromElements(<span class="number">1L</span>,<span class="number">2L</span>,<span class="number">3L</span>);</span><br><span class="line"></span><br><span class="line">    ConnectedStreams&lt;Integer, Long&gt; connectedStreams = stream1.connect(stream2);</span><br><span class="line">    </span><br><span class="line">    SingleOutputStreamOperator&lt;String&gt; result = connectedStreams.map(<span class="keyword">new</span> CoMapFunction&lt;Integer, Long, String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">map1</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Integer: &quot;</span> + value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">map2</span><span class="params">(Long value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Long: &quot;</span> + value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    result.print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们将一条 Integer 流和一条 Long 流合并，转换成 String 输出。所以当遇到第一条流输入的整型值时，调用.map1()；而遇到第二条流输入的长整型数据时，调用.map2()：最终都转换为字符串输出，合并成了一条字符串流。</p>
<p>值得一提的是，ConnectedStreams 也可以直接调用.keyBy()进行按键分区的操作，得到的还是一个 ConnectedStreams：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connectedStreams.keyBy(keySelector1, keySelector2);</span><br></pre></td></tr></table></figure>

<p>这里传入两个参数 keySelector1 和 keySelector2，是两条流中各自的键选择器；当然也可以直接传入键的位置值(keyPosition)，或者键的字段名(field)，这与普通的 keyBy 用法完全 一致。ConnectedStreams 进行 keyBy 操作，其实就是把两条流中 key 相同的数据放到了一起，然后针对来源的流再做各自处理，这在一些场景下非常有用。另外，我们也可以在合并之前就将两条流分别进行 keyBy，得到的 KeyedStream 再进行连接(connect)操作，效果是一样的。 要注意两条流定义的<strong>键的类型必须相同</strong>，否则会抛出异常。</p>
<h4 id="双流联结-Join"><a href="#双流联结-Join" class="headerlink" title="双流联结(Join)"></a>双流联结(Join)</h4><h5 id="窗口联结-Window-Join"><a href="#窗口联结-Window-Join" class="headerlink" title="窗口联结(Window Join)"></a>窗口联结(Window Join)</h5><p>可以定义时间窗口，并将两条流中共享一个公共键(key)的数据放在窗口中进行配对处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stream1.join(stream2)</span><br><span class="line">       .where(&lt;KeySelector&gt;)</span><br><span class="line">       .equalTo(&lt;KeySelector&gt;)</span><br><span class="line">       .window(&lt;WindowAssigner&gt;)</span><br><span class="line">       .apply(&lt;JoinFunction&gt;)</span><br></pre></td></tr></table></figure>

<p>上面代码中.where()的参数是键选择器(KeySelector)，用来指定第一条流中的 key；而.equalTo()传入的 KeySelector 则指定了第二条流中的 key。两者相同的元素，如果在同一窗口中，就可以匹配起来，并通过一个联结函数(JoinFunction)进行处理了。</p>
<p>传入的 JoinFunction 也是一个函数类接口，使用时需要实现内部的.join()方法。这个方法有两个参数，分别表示两条流中成对匹配的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JoinFunction</span>&lt;<span class="title">IN1</span>, <span class="title">IN2</span>, <span class="title">OUT</span>&gt; <span class="keyword">extends</span> <span class="title">Function</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">   <span class="function">OUT <span class="title">join</span><span class="params">(IN1 first, IN2 second)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-03-25%20%E4%B8%8A%E5%8D%889.56.19.png" alt="截屏2022-03-25 上午9.56.19"></p>
<p>除了 JoinFunction，在.apply()方法中还可以传入 FlatJoinFunction，用法非常类似，只是内部需要实现的.join()方法没有返回值。结果的输出是通过收集器(Collector)来实现的，所以对于一对匹配数据可以输出任意条结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    DataStream&lt;Tuple2&lt;String, Long&gt;&gt; stream1 = env</span><br><span class="line">            .fromElements(</span><br><span class="line">                    Tuple2.of(<span class="string">&quot;a&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">                    Tuple2.of(<span class="string">&quot;b&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">                    Tuple2.of(<span class="string">&quot;a&quot;</span>, <span class="number">2000L</span>),</span><br><span class="line">                    Tuple2.of(<span class="string">&quot;b&quot;</span>, <span class="number">2000L</span>)</span><br><span class="line">            )</span><br><span class="line">            .assignTimestampsAndWatermarks(</span><br><span class="line">                    WatermarkStrategy</span><br><span class="line">                            .&lt;Tuple2&lt;String, Long&gt;&gt;forMonotonousTimestamps()</span><br><span class="line">                            .withTimestampAssigner(</span><br><span class="line">                                    <span class="keyword">new</span> SerializableTimestampAssigner&lt;Tuple2&lt;String, Long&gt;&gt;() &#123;</span><br><span class="line">                                        <span class="meta">@Override</span></span><br><span class="line">                                        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Tuple2&lt;String, Long&gt; stringLongTuple2, <span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">                                            <span class="keyword">return</span> stringLongTuple2.f1;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                            )</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    DataStream&lt;Tuple2&lt;String, Long&gt;&gt; stream2 = env</span><br><span class="line">            .fromElements(</span><br><span class="line">                    Tuple2.of(<span class="string">&quot;a&quot;</span>, <span class="number">3000L</span>),</span><br><span class="line">                    Tuple2.of(<span class="string">&quot;b&quot;</span>, <span class="number">3000L</span>),</span><br><span class="line">                    Tuple2.of(<span class="string">&quot;a&quot;</span>, <span class="number">4000L</span>),</span><br><span class="line">                    Tuple2.of(<span class="string">&quot;b&quot;</span>, <span class="number">4000L</span>)</span><br><span class="line">            )</span><br><span class="line">            .assignTimestampsAndWatermarks(</span><br><span class="line">                    WatermarkStrategy</span><br><span class="line">                            .&lt;Tuple2&lt;String, Long&gt;&gt;forMonotonousTimestamps()</span><br><span class="line">                            .withTimestampAssigner(</span><br><span class="line">                                    <span class="keyword">new</span> SerializableTimestampAssigner&lt;Tuple2&lt;String, Long&gt;&gt;() &#123;</span><br><span class="line">                                        <span class="meta">@Override</span></span><br><span class="line">                                        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Tuple2&lt;String, Long&gt; stringLongTuple2, <span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">                                            <span class="keyword">return</span> stringLongTuple2.f1;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                            )</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    stream1</span><br><span class="line">            .join(stream2)</span><br><span class="line">            .where(r -&gt; r.f0)</span><br><span class="line">            .equalTo(r -&gt; r.f0)</span><br><span class="line">            .window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">5</span>)))</span><br><span class="line">            .apply(<span class="keyword">new</span> JoinFunction&lt;Tuple2&lt;String, Long&gt;, Tuple2&lt;String, Long&gt;, String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">join</span><span class="params">(Tuple2&lt;String, Long&gt; left, Tuple2&lt;String, Long&gt; right)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> left + <span class="string">&quot;=&gt;&quot;</span> + right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">(a,1000)</span>=&gt;<span class="comment">(a,3000)</span></span><br><span class="line"><span class="comment">(a,1000)</span>=&gt;<span class="comment">(a,4000)</span></span><br><span class="line"><span class="comment">(a,2000)</span>=&gt;<span class="comment">(a,3000)</span></span><br><span class="line"><span class="comment">(a,2000)</span>=&gt;<span class="comment">(a,4000)</span></span><br><span class="line"><span class="comment">(b,1000)</span>=&gt;<span class="comment">(b,3000)</span></span><br><span class="line"><span class="comment">(b,1000)</span>=&gt;<span class="comment">(b,4000)</span></span><br><span class="line"><span class="comment">(b,2000)</span>=&gt;<span class="comment">(b,3000)</span></span><br><span class="line"><span class="comment">(b,2000)</span>=&gt;<span class="comment">(b,4000)</span></span><br></pre></td></tr></table></figure>

<h5 id="间隔联结-Interval-Join"><a href="#间隔联结-Interval-Join" class="headerlink" title="间隔联结(Interval Join)"></a>间隔联结(Interval Join)</h5><p>在有些场景下，我们要处理的时间间隔可能并不是固定的。比如，在交易系统中，需要实时地对每一笔交易进行核验，保证两个账户转入转出数额相等，也就是所谓的实时对账。 两次转账的数据可能写入了不同的日志流，它们的时间戳应该相差不大，所以我们可以考虑只统计一段时间内是否有出账入账的数据匹配。这时显然不应该用滚动窗口或滑动窗口来处理——因为匹配的两个数据有可能刚好卡在窗口边缘两侧，于是窗口内就都没有匹配了；会话窗口虽然时间不固定，但也明显不适合这个场景。 基于时间的窗口联结已经无能为力了。</p>
<p>为了应对这样的需求，Flink 提供了一种叫作间隔联结(interval join)的合流操作。顾名思义，间隔联结的思路就是针对一条流的每个数据，<strong>开辟出其时间戳前后的一段时间间隔</strong>，看这期间是否有来自另一条流的数据匹配。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">stream1</span><br><span class="line">   .keyBy(&lt;KeySelector&gt;)</span><br><span class="line">   .intervalJoin(stream2.keyBy(&lt;KeySelector&gt;))</span><br><span class="line">   .between(Time.milliseconds(-<span class="number">2</span>), Time.milliseconds(<span class="number">1</span>))</span><br><span class="line">   .process (<span class="keyword">new</span> ProcessJoinFunction&lt;Integer, Integer, String()&#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(Integer left, Integer right, Context ctx, Collector&lt;String&gt; out)</span> </span>&#123;</span><br><span class="line">                              out.collect(left + <span class="string">&quot;,&quot;</span> + right);</span><br><span class="line">                           </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<p>抽象类 ProcessJoinFunction 就像是 ProcessFunction 和 JoinFunction 的结合，内部同样有一个抽象方法.processElement()。与其他处理函数不同的是，它多了一个参数，这自然是因为有来自两条流的数据。参数中 left 指的就是第一条流中的数据，right 则是第二条流中与它匹配的数据。每当检测到一组匹配，就会调用这里的.processElement()方法，经处理转换之后输出结果。</p>
<p>举一个例子，我们有两条流，一条是下订单的流，一条是浏览数据的流。我们可以针对同一个用户，来做这样一个联结。也就是使用一个用户的下订单的事件和这个用户的最近十分钟的浏览数据进行一个联结查询：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    SingleOutputStreamOperator&lt;Tuple3&lt;String, String, Long&gt;&gt; orderStream = env.fromElements(</span><br><span class="line">            Tuple3.of(<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;order-1&quot;</span>, <span class="number">5000L</span>),</span><br><span class="line">            Tuple3.of(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;order-2&quot;</span>, <span class="number">5000L</span>),</span><br><span class="line">            Tuple3.of(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;order-3&quot;</span>, <span class="number">20000L</span>),</span><br><span class="line">            Tuple3.of(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;order-4&quot;</span>, <span class="number">20000L</span>),</span><br><span class="line">            Tuple3.of(<span class="string">&quot;Cary&quot;</span>, <span class="string">&quot;order-5&quot;</span>, <span class="number">51000L</span>)</span><br><span class="line">    ).assignTimestampsAndWatermarks(WatermarkStrategy.&lt;Tuple3&lt;String, String, Long&gt;&gt;forMonotonousTimestamps()</span><br><span class="line">            .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Tuple3&lt;String, String, Long&gt;&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Tuple3&lt;String, String, Long&gt; element, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> element.f2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    SingleOutputStreamOperator&lt;Event&gt; clickStream = env.fromElements(</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./cart&quot;</span>, <span class="number">2000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod?id=100&quot;</span>, <span class="number">3000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod?id=200&quot;</span>, <span class="number">3500L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./prod?id=2&quot;</span>, <span class="number">2500L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod?id=300&quot;</span>, <span class="number">36000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">30000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./prod?id=1&quot;</span>, <span class="number">23000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./prod?id=3&quot;</span>, <span class="number">33000L</span>)</span><br><span class="line">    ).assignTimestampsAndWatermarks(WatermarkStrategy.&lt;Event&gt;forMonotonousTimestamps()</span><br><span class="line">            .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Event&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Event element, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> element.timestamp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    orderStream.keyBy(data -&gt; data.f0)</span><br><span class="line">            .intervalJoin(clickStream.keyBy(data -&gt; data.user))</span><br><span class="line">            .between(Time.seconds(-<span class="number">5</span>), Time.seconds(<span class="number">10</span>))</span><br><span class="line">            .process(<span class="keyword">new</span> ProcessJoinFunction&lt;Tuple3&lt;String, String, Long&gt;, Event, String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(Tuple3&lt;String, String, Long&gt; left, Event right, Context ctx, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    out.collect(right + <span class="string">&quot; =&gt; &quot;</span> + left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="窗口同组联结-Window-CoGroup"><a href="#窗口同组联结-Window-CoGroup" class="headerlink" title="窗口同组联结(Window CoGroup)"></a>窗口同组联结(Window CoGroup)</h5><p>除窗口联结和间隔联结之外，Flink 还提供了一个窗口同组联结(window coGroup)操作。它的用法跟 window join 非常类似，也是将两条流合并之后开窗处理匹配的元素，调用时只需要将.join()换为.coGroup()就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stream1.coGroup(stream2)</span><br><span class="line">   .where(&lt;KeySelector&gt;)</span><br><span class="line">   .equalTo(&lt;KeySelector&gt;)</span><br><span class="line">   .window(TumblingEventTimeWindows.of(Time.hours(<span class="number">1</span>)))</span><br><span class="line">   .apply(&lt;CoGroupFunction&gt;)</span><br></pre></td></tr></table></figure>

<p>与 window join 的区别在于，调用.apply()方法定义具体操作时，传入的是一个 CoGroupFunction。这也是一个函数类接口，源码中定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CoGroupFunction</span>&lt;<span class="title">IN1</span>, <span class="title">IN2</span>, <span class="title">O</span>&gt; <span class="keyword">extends</span> <span class="title">Function</span>, <span class="title">Serializable</span> </span>&#123; </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">coGroup</span><span class="params">(Iterable&lt;IN1&gt; first, Iterable&lt;IN2&gt; second, Collector&lt;O&gt; out)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>.coGroup()方法，有些类似于 FlatJoinFunction 中.join()的形式，同样有三个参数，分别代表两条流中的数据以及用于输出的收集器(Collector)。<strong>不同的是，这里的前两个参数不再是单独的每一组配对数据了，而是传入了可遍历的数据集合。也就是说，现在不会再去计算窗口中两条流数据集的笛卡尔积，而是直接把收集到的所有数据一次性传入，至于要怎样配对完全是自定义的。</strong>这样.coGroup()方法只会被调用一次，而且即使一条流的数据没有任何另一条流的数据匹配，也可以出现在集合中、当然也可以定义输出结果了。</p>
<p><strong>coGroup 操作比窗口的 join 更加通用，不仅可以实现类似 SQL 中的内连接(inner join)，也可以实现左外连接(left outer join)、右外连接(right outer join)和全外连接(full outer join)。事实上，窗口 join 的底层，也是通过 coGroup 来实现的。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    DataStream&lt;Tuple2&lt;String, Long&gt;&gt; stream1 = env</span><br><span class="line">            .fromElements(</span><br><span class="line">                    Tuple2.of(<span class="string">&quot;a&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">                    Tuple2.of(<span class="string">&quot;b&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">                    Tuple2.of(<span class="string">&quot;a&quot;</span>, <span class="number">2000L</span>),</span><br><span class="line">                    Tuple2.of(<span class="string">&quot;b&quot;</span>, <span class="number">2000L</span>)</span><br><span class="line">            )</span><br><span class="line">            .assignTimestampsAndWatermarks(</span><br><span class="line">                    WatermarkStrategy</span><br><span class="line">                            .&lt;Tuple2&lt;String, Long&gt;&gt;forMonotonousTimestamps()</span><br><span class="line">                            .withTimestampAssigner(</span><br><span class="line">                                    <span class="keyword">new</span> SerializableTimestampAssigner&lt;Tuple2&lt;String, Long&gt;&gt;() &#123;</span><br><span class="line">                                        <span class="meta">@Override</span></span><br><span class="line">                                        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Tuple2&lt;String, Long&gt; stringLongTuple2, <span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">                                            <span class="keyword">return</span> stringLongTuple2.f1;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                            )</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    DataStream&lt;Tuple2&lt;String, Long&gt;&gt; stream2 = env</span><br><span class="line">            .fromElements(</span><br><span class="line">                    Tuple2.of(<span class="string">&quot;a&quot;</span>, <span class="number">3000L</span>),</span><br><span class="line">                    Tuple2.of(<span class="string">&quot;b&quot;</span>, <span class="number">3000L</span>),</span><br><span class="line">                    Tuple2.of(<span class="string">&quot;a&quot;</span>, <span class="number">4000L</span>),</span><br><span class="line">                    Tuple2.of(<span class="string">&quot;b&quot;</span>, <span class="number">4000L</span>)</span><br><span class="line">            )</span><br><span class="line">            .assignTimestampsAndWatermarks(</span><br><span class="line">                    WatermarkStrategy</span><br><span class="line">                            .&lt;Tuple2&lt;String, Long&gt;&gt;forMonotonousTimestamps()</span><br><span class="line">                            .withTimestampAssigner(</span><br><span class="line">                                    <span class="keyword">new</span> SerializableTimestampAssigner&lt;Tuple2&lt;String, Long&gt;&gt;() &#123;</span><br><span class="line">                                        <span class="meta">@Override</span></span><br><span class="line">                                        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Tuple2&lt;String, Long&gt; stringLongTuple2, <span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">                                            <span class="keyword">return</span> stringLongTuple2.f1;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                            )</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    stream1</span><br><span class="line">            .coGroup(stream2)</span><br><span class="line">            .where(r -&gt; r.f0)</span><br><span class="line">            .equalTo(r -&gt; r.f0)</span><br><span class="line">            .window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">5</span>)))</span><br><span class="line">            .apply(<span class="keyword">new</span> CoGroupFunction&lt;Tuple2&lt;String, Long&gt;, Tuple2&lt;String, Long&gt;, String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">coGroup</span><span class="params">(Iterable&lt;Tuple2&lt;String, Long&gt;&gt; iter1, Iterable&lt;Tuple2&lt;String, Long&gt;&gt; iter2, Collector&lt;String&gt; collector)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    collector.collect(iter1 + <span class="string">&quot;=&gt;&quot;</span> + iter2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="comment">(a,1000)</span>, <span class="comment">(a,2000)</span>]=&gt;[<span class="comment">(a,3000)</span>, <span class="comment">(a,4000)</span>]</span><br><span class="line">[<span class="comment">(b,1000)</span>, <span class="comment">(b,2000)</span>]=&gt;[<span class="comment">(b,3000)</span>, <span class="comment">(b,4000)</span>]</span><br></pre></td></tr></table></figure>

<h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><p>有状态的算子任务，则除当前数据之外，还需要一些其他数据来得到计算结果。这里的其他数据，就是所谓的状态(state)，最常见的就是之前到达的数据，或者由之前数据计算出的某个结果。比如，做求和(sum)计算时，需要保存之前所有数据的和，这就是状态；窗口算子中会保存已经到达的所有数据，这些也都是它的状态。另外，如果我们希望检索到某种事件模式(event pattern)，比如先有下单行为，后有支付行为，那么也应该把之前的行为保存下来，这同样属于状态。容易发现，之前讲过的聚合算子、窗口算子都属于有状态的算子。</p>
<p>有状态算子的一般处理流程：(1)算子任务接收到上游发来的数据；(2)获取当前状态；(3)根据业务逻辑进行计算，更新状态；(4)得到计算结果，输出发送到下游任务。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-03-25%20%E4%B8%8A%E5%8D%8811.24.56.png" alt="截屏2022-03-25 上午11.24.56"></p>
<table>
<thead>
<tr>
<th></th>
<th>ManagedState</th>
<th>RawState</th>
</tr>
</thead>
<tbody><tr>
<td>状态管理方式</td>
<td>Flink Runtime托管, 自动存储, 自动恢复, 自动伸缩</td>
<td>用户自己管理</td>
</tr>
<tr>
<td>状态数据结构</td>
<td>Flink提供多种常用数据结构, 例如:ListState, MapState等</td>
<td>字节数组: byte[]</td>
</tr>
<tr>
<td>使用场景</td>
<td>绝大数Flink算子</td>
<td>所有算子</td>
</tr>
</tbody></table>
<p>对Managed State继续细分，它又有两种类型：</p>
<p>a) Operator State(算子状态)</p>
<p>状态作用范围限定为当前的算子任务实例，也就是只对当前并行子任务实例有效。这就意味着对于一个并行子任务，占据了一个分区，它所处理的所有数据都会访问到相同的状态，状态对于同一任务而言是共享的。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-03-25%20%E4%B8%8B%E5%8D%883.47.50.png" alt="截屏2022-03-25 下午3.47.50"></p>
<p>算子状态可以用在所有算子上，使用的时候其实就跟一个本地变量没什么区别——因为本地变量的作用域也是当前任务实例。在使用时，我们还需进一步实现 CheckpointedFunction 接口。</p>
<p>b) Keyed State(键控状态)</p>
<p>状态是根据输入流中定义的键(key)来维护和访问的，所以只能定义在按键分区流(KeyedStream)中，也就 keyBy 之后才可以使用。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-03-25%20%E4%B8%8B%E5%8D%883.48.55.png" alt="截屏2022-03-25 下午3.48.55"></p>
<p>按键分区状态应用非常广泛。之前讲到的聚合算子必须在 keyBy 之后才能使用，就是因为聚合的结果是以Keyed State的形式保存的。另外，也可以通过富函数类(Rich Function) 来自定义 Keyed State，所以只要提供了富函数类接口的算子，也都可以使用 Keyed State。</p>
<p>所以即使是 map、filter 这样无状态的基本转换算子，我们也可以通过富函数类给它们追加 Keyed State，或者实现 CheckpointedFunction 接口来定义 Operator State；从这个角度讲， Flink 中所有的算子都可以是有状态的，不愧是有状态的流处理。</p>
<p>无论是 Keyed State 还是 Operator State，它们都是在本地实例上维护的，也就是说<strong>每个并行子任务维护着对应的状态</strong>，算子的<strong>子任务之间状态不共享</strong>。关于状态的具体使用。</p>
<table>
<thead>
<tr>
<th></th>
<th>OperatorState</th>
<th>KeyedState</th>
</tr>
</thead>
<tbody><tr>
<td>适用用算子类型</td>
<td>可用于所有算子: 常用于source, 例如 FlinkKafkaConsumer</td>
<td>只适用于KeyedStream上的算子</td>
</tr>
<tr>
<td>状态分配</td>
<td>一个算子的子任务对应一个状态</td>
<td>一个Key对应一个State: 一个算子会处理多个Key, 则访问相应的多个State</td>
</tr>
<tr>
<td>创建和访问方式</td>
<td>实现CheckpointedFunction或ListCheckpointed(已经过时)接口</td>
<td>重写RichFunction, 通过里面的RuntimeContext访问</td>
</tr>
<tr>
<td>横向扩展</td>
<td>并发改变时有多重重写分配方式可选: 均匀分配和合并后每个得到全量</td>
<td>并发改变, State随着Key在实例间迁移</td>
</tr>
<tr>
<td>支持的数据结构</td>
<td>ListState、UnionListState和BroadCastState</td>
<td>ValueState, ListState,MapState ReduceState, AggregatingState</td>
</tr>
</tbody></table>
<h3 id="按键分区状态-Keyed-State"><a href="#按键分区状态-Keyed-State" class="headerlink" title="按键分区状态(Keyed State)"></a>按键分区状态(Keyed State)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//stateTest</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    SingleOutputStreamOperator&lt;Event&gt; stream = env.addSource(<span class="keyword">new</span> ClickSource())</span><br><span class="line">            .assignTimestampsAndWatermarks(WatermarkStrategy.&lt;Event&gt;forMonotonousTimestamps()</span><br><span class="line">                    .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Event&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Event element, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> element.timestamp;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    stream.keyBy(data -&gt; data.user)</span><br><span class="line">          .flatMap(<span class="keyword">new</span> MyFlatMap())</span><br><span class="line">          .print();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现自定义的FlatMapFunction，用于Keyed State测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFlatMap</span> <span class="keyword">extends</span> <span class="title">RichFlatMapFunction</span>&lt;<span class="title">Event</span>, <span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 定义状态</span></span><br><span class="line">    ValueState&lt;Event&gt; myValueState;</span><br><span class="line">    ListState&lt;Event&gt; myListState;</span><br><span class="line">    MapState&lt;String, Long&gt; myMapState;</span><br><span class="line">    ReducingState&lt;Event&gt; myReducingState;</span><br><span class="line">    AggregatingState&lt;Event, String&gt; myAggregatingState;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加一个本地变量进行对比</span></span><br><span class="line">    Long count = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ValueStateDescriptor&lt;Event&gt; valueStateDescriptor = <span class="keyword">new</span> ValueStateDescriptor&lt;&gt;(<span class="string">&quot;my-state&quot;</span>, Event.class);</span><br><span class="line">        myValueState = getRuntimeContext().getState(valueStateDescriptor);</span><br><span class="line"></span><br><span class="line">        myListState = getRuntimeContext().getListState(<span class="keyword">new</span> ListStateDescriptor&lt;Event&gt;(<span class="string">&quot;my-list&quot;</span>, Event.class));</span><br><span class="line">        myMapState = getRuntimeContext().getMapState(<span class="keyword">new</span> MapStateDescriptor&lt;String, Long&gt;(<span class="string">&quot;my-map&quot;</span>, String.class, Long.class));</span><br><span class="line"></span><br><span class="line">        myReducingState = getRuntimeContext().getReducingState(<span class="keyword">new</span> ReducingStateDescriptor&lt;Event&gt;(<span class="string">&quot;my-reduce&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> ReduceFunction&lt;Event&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Event <span class="title">reduce</span><span class="params">(Event value1, Event value2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> Event(value1.user, value1.url, value2.timestamp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                , Event.class));</span><br><span class="line"></span><br><span class="line">        myAggregatingState = getRuntimeContext().getAggregatingState(<span class="keyword">new</span> AggregatingStateDescriptor&lt;Event, Long, String&gt;(<span class="string">&quot;my-agg&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> AggregateFunction&lt;Event, Long, String&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Long <span class="title">createAccumulator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Long <span class="title">add</span><span class="params">(Event value, Long accmulator)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> accmulator + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> String <span class="title">getResult</span><span class="params">(Long accumulator)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">&quot;count: &quot;</span> + accumulator;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Long <span class="title">merge</span><span class="params">(Long a, Long b)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> a + b;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                , Long.class));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置状态的TTL</span></span><br><span class="line">        StateTtlConfig ttlConfig = StateTtlConfig.newBuilder(Time.hours(<span class="number">1</span>))</span><br><span class="line">                .setUpdateType(StateTtlConfig.UpdateType.OnReadAndWrite)</span><br><span class="line">                .setStateVisibility(StateTtlConfig.StateVisibility.ReturnExpiredIfNotCleanedUp)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        valueStateDescriptor.enableTimeToLive(ttlConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(Event value, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 访问和更新状态</span></span><br><span class="line">        System.out.println(myValueState.value());</span><br><span class="line">        myValueState.update(value);</span><br><span class="line">        System.out.println( <span class="string">&quot;my value: &quot;</span> + myValueState.value() );</span><br><span class="line"></span><br><span class="line">        myListState.add(value);</span><br><span class="line"></span><br><span class="line">        myMapState.put(value.user, myMapState.get(value.user) == <span class="keyword">null</span>? <span class="number">1</span>: myMapState.get(value.user) + <span class="number">1</span>);</span><br><span class="line">        System.out.println( <span class="string">&quot;my map value: &quot;</span> + myMapState.get(value.user) );</span><br><span class="line"></span><br><span class="line">        myReducingState.add(value);</span><br><span class="line">        System.out.println( <span class="string">&quot;my reducing value: &quot;</span> + myReducingState.get() );</span><br><span class="line"></span><br><span class="line">        myAggregatingState.add(value);</span><br><span class="line">        System.out.println( <span class="string">&quot;my agg value: &quot;</span> + myAggregatingState.get() );</span><br><span class="line"></span><br><span class="line">        count ++;</span><br><span class="line">        System.out.println(<span class="string">&quot;count: &quot;</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="值状态-ValueState"><a href="#值状态-ValueState" class="headerlink" title="值状态(ValueState)"></a>值状态(ValueState)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ValueState</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">   <span class="function">T <span class="title">value</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(T value)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>T value()：获取当前状态的值。<br>update(Tvalue)：对状态进行更新，传入的参数value就是要覆写的状态值。</p>
<p>在具体使用时，为了让运行时上下文清楚到底是哪个状态，我们还需要创建一个状态描述器(StateDescriptor)来提供状态的基本信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ValueStateDescriptor</span><span class="params">(String name, Class&lt;T&gt; typeClass)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">super</span>(name, typeClass, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要传入状态的名称和类型。</p>
<p>例子：我们这里会使用用户 id 来进行分流，然后分别统计每个用户的 pv 数据，由于我们并不想每次 pv 加一，就将统计结果发送到下游去，所以这里我们注册了一个定时器，用来隔一段时间发送 pv 的统计结果，这样对下游算子的压力不至于太大。具体实现方式是定义一个用来保存定时器时间戳的值状态变量。当定时器触发并向下游发送数据以后，便清空储存定时器时间戳的状态变量，这样当新的数据到来时，发现并没有定时器存在，就可以注册新的定时器了， 注册完定时器之后将定时器的时间戳继续保存在状态变量中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PeriodicPvExample</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    SingleOutputStreamOperator&lt;Event&gt; stream = env.addSource(<span class="keyword">new</span> ClickSource())</span><br><span class="line">            .assignTimestampsAndWatermarks(WatermarkStrategy.&lt;Event&gt;forMonotonousTimestamps()</span><br><span class="line">                    .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Event&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Event element, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> element.timestamp;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    stream.print(<span class="string">&quot;input&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计每个用户的pv，隔一段时间（10s）输出一次结果</span></span><br><span class="line">    stream.keyBy(data -&gt; data.user)</span><br><span class="line">            .process(<span class="keyword">new</span> PeriodicPvResult())</span><br><span class="line">            .print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册定时器，周期性输出pv</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PeriodicPvResult</span> <span class="keyword">extends</span> <span class="title">KeyedProcessFunction</span>&lt;<span class="title">String</span> ,<span class="title">Event</span>, <span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 定义两个状态，保存当前pv值，以及定时器时间戳</span></span><br><span class="line">    ValueState&lt;Long&gt; countState;</span><br><span class="line">    ValueState&lt;Long&gt; timerTsState;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        countState = getRuntimeContext().getState(<span class="keyword">new</span> ValueStateDescriptor&lt;Long&gt;(<span class="string">&quot;count&quot;</span>, Long.class));</span><br><span class="line">        timerTsState = getRuntimeContext().getState(<span class="keyword">new</span> ValueStateDescriptor&lt;Long&gt;(<span class="string">&quot;timerTs&quot;</span>, Long.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(Event value, Context ctx, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 更新count值</span></span><br><span class="line">        Long count = countState.value();</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="keyword">null</span>)&#123;</span><br><span class="line">            countState.update(<span class="number">1L</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            countState.update(count + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注册定时器</span></span><br><span class="line">        <span class="keyword">if</span> (timerTsState.value() == <span class="keyword">null</span>)&#123;</span><br><span class="line">            ctx.timerService().registerEventTimeTimer(value.timestamp + <span class="number">10</span> * <span class="number">1000L</span>);</span><br><span class="line">            timerTsState.update(value.timestamp + <span class="number">10</span> * <span class="number">1000L</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTimer</span><span class="params">(<span class="keyword">long</span> timestamp, OnTimerContext ctx, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        out.collect(ctx.getCurrentKey() + <span class="string">&quot; pv: &quot;</span> + countState.value());</span><br><span class="line">        <span class="comment">// 清空状态</span></span><br><span class="line">        timerTsState.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="列表状态-ListState"><a href="#列表状态-ListState" class="headerlink" title="列表状态(ListState)"></a>列表状态(ListState)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ListState</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">MergingState</span>&lt;<span class="title">T</span>, <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(List&lt;T&gt; values)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(List&lt;T&gt; values)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Iterable<T>get()：获取当前的列表状态，返回的是一个可迭代类型Iterable<T>。</T></T></p>
<p>update(List<T>values)：传入一个列表values，直接对状态进行覆盖。</T></p>
<p>add(Tvalue)：在状态列表中添加一个元素value。</p>
<p>addAll(List<T>values)：向列表中添加多个元素，以列表values形式传入。</T></p>
<p>在 Flink SQL 中，支持两条流的全量 Join，语法如下：SELECT * FROM A INNER JOIN B WHERE A.id = B.id；这样一条 SQL 语句要慎用，因为 Flink 会将 A 流和 B 流的所有数据都保存下来，然后进行 Join。不过在这里我们可以用列表状态变量来实现一下这个 SQL 语句的功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TwoStreamFullJoinExample</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    SingleOutputStreamOperator&lt;Tuple3&lt;String, String, Long&gt;&gt; stream1 = env</span><br><span class="line">            .fromElements(</span><br><span class="line">                    Tuple3.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;stream-1&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">                    Tuple3.of(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;stream-1&quot;</span>, <span class="number">2000L</span>)</span><br><span class="line">            )</span><br><span class="line">            .assignTimestampsAndWatermarks(</span><br><span class="line">                    WatermarkStrategy.&lt;Tuple3&lt;String, String, Long&gt;&gt;forMonotonousTimestamps()</span><br><span class="line">                            .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Tuple3&lt;String, String, Long&gt;&gt;() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Tuple3&lt;String, String, Long&gt; t, <span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">                                    <span class="keyword">return</span> t.f2;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;)</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    SingleOutputStreamOperator&lt;Tuple3&lt;String, String, Long&gt;&gt; stream2 = env</span><br><span class="line">            .fromElements(</span><br><span class="line">                    Tuple3.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;stream-2&quot;</span>, <span class="number">3000L</span>),</span><br><span class="line">                    Tuple3.of(<span class="string">&quot;b&quot;</span>, <span class="string">&quot;stream-2&quot;</span>, <span class="number">4000L</span>)</span><br><span class="line">            )</span><br><span class="line">            .assignTimestampsAndWatermarks(</span><br><span class="line">                    WatermarkStrategy.&lt;Tuple3&lt;String, String, Long&gt;&gt;forMonotonousTimestamps()</span><br><span class="line">                            .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Tuple3&lt;String, String, Long&gt;&gt;() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Tuple3&lt;String, String, Long&gt; t, <span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">                                    <span class="keyword">return</span> t.f2;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;)</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    stream1.keyBy(r -&gt; r.f0)</span><br><span class="line">            .connect(stream2.keyBy(r -&gt; r.f0))</span><br><span class="line">            .process(<span class="keyword">new</span> CoProcessFunction&lt;Tuple3&lt;String, String, Long&gt;, Tuple3&lt;String, String, Long&gt;, String&gt;() &#123;</span><br><span class="line">                <span class="keyword">private</span> ListState&lt;Tuple3&lt;String, String, Long&gt;&gt; stream1ListState;</span><br><span class="line">                <span class="keyword">private</span> ListState&lt;Tuple3&lt;String, String, Long&gt;&gt; stream2ListState;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">super</span>.open(parameters);</span><br><span class="line">                    stream1ListState = getRuntimeContext().getListState(</span><br><span class="line">                            <span class="keyword">new</span> ListStateDescriptor&lt;Tuple3&lt;String, String, Long&gt;&gt;(<span class="string">&quot;stream1-list&quot;</span>, Types.TUPLE(Types.STRING, Types.STRING))</span><br><span class="line">                    );</span><br><span class="line">                    stream2ListState = getRuntimeContext().getListState(</span><br><span class="line">                            <span class="keyword">new</span> ListStateDescriptor&lt;Tuple3&lt;String, String, Long&gt;&gt;(<span class="string">&quot;stream2-list&quot;</span>, Types.TUPLE(Types.STRING, Types.STRING))</span><br><span class="line">                    );</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement1</span><span class="params">(Tuple3&lt;String, String, Long&gt; left, Context context, Collector&lt;String&gt; collector)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    stream1ListState.add(left);</span><br><span class="line">                    <span class="keyword">for</span> (Tuple3&lt;String, String, Long&gt; right : stream2ListState.get()) &#123;</span><br><span class="line">                        collector.collect(left + <span class="string">&quot; =&gt; &quot;</span> + right);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement2</span><span class="params">(Tuple3&lt;String, String, Long&gt; right, Context context, Collector&lt;String&gt; collector)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    stream2ListState.add(right);</span><br><span class="line">                    <span class="keyword">for</span> (Tuple3&lt;String, String, Long&gt; left : stream1ListState.get()) &#123;</span><br><span class="line">                        collector.collect(left + <span class="string">&quot; =&gt; &quot;</span> + right);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="映射状态-MapState"><a href="#映射状态-MapState" class="headerlink" title="映射状态(MapState)"></a>映射状态(MapState)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MapState</span>&lt;<span class="title">UK</span>, <span class="title">UV</span>&gt; <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="function">UV <span class="title">get</span><span class="params">(UK key)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(UK key, UV value)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;UK, UV&gt; map)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(UK key)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(UK key)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    Iterable&lt;Map.Entry&lt;UK, UV&gt;&gt; entries() <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="function">Iterable&lt;UK&gt; <span class="title">keys</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function">Iterable&lt;UV&gt; <span class="title">values</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    Iterator&lt;Map.Entry&lt;UK, UV&gt;&gt; iterator() <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>get(UKkey)：传入一个key作为参数，查询对应的value值。</p>
<p>put(UKkey,UVvalue)：传入一个键值对，更新key对应的value值。</p>
<p>putAll(Map&lt;UK,UV&gt;map)：将传入的映射map中所有的键值对，全部添加到映射状态中。</p>
<p>remove(UKkey)：将指定key对应的键值对删除。</p>
<p>contains(UK key)：判断是否存在指定的 key，返回一个 boolean 值。 另外，MapState 也提供了获取整个映射相关信息的方法。</p>
<p>entries()：获取映射状态中所有的键值对。</p>
<p>keys()：获取映射状态中所有的键(key)，返回一个可迭代 Iterable 类型。</p>
<p>values()：获取映射状态中所有的值(value)，返回一个可迭代 Iterable 类型。</p>
<p>booleanisEmpty()：判断映射是否为空，返回一个boolean值。</p>
<p>映射状态的用法和 Java 中的 HashMap 很相似。在这里我们可以通过 MapState 的使用来探索一下窗口的底层实现，也就是我们要用映射状态来完整模拟窗口的功能。这里我们模拟一个滚动窗口。我们要计算的是每一个 url 在每一个窗口中的 pv 数据。我们之前使用增量聚合和全窗口聚合结合的方式实现过这个需求。这里我们用 MapState 再来实现一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用KeyedProcessFunction模拟滚动窗口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    SingleOutputStreamOperator&lt;Event&gt; stream = env.addSource(<span class="keyword">new</span> ClickSource())</span><br><span class="line">            .assignTimestampsAndWatermarks(WatermarkStrategy.&lt;Event&gt;forMonotonousTimestamps()</span><br><span class="line">                    .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Event&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Event element, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> element.timestamp;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计每10s窗口内，每个url的pv</span></span><br><span class="line">    stream.keyBy(data -&gt; data.url)</span><br><span class="line">            .process(<span class="keyword">new</span> FakeWindowResult(<span class="number">10000L</span>))</span><br><span class="line">            .print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FakeWindowResult</span> <span class="keyword">extends</span> <span class="title">KeyedProcessFunction</span>&lt;<span class="title">String</span>, <span class="title">Event</span>, <span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 定义属性，窗口长度</span></span><br><span class="line">    <span class="keyword">private</span> Long windowSize;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FakeWindowResult</span><span class="params">(Long windowSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.windowSize = windowSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明状态，用map保存pv值（窗口start，count）</span></span><br><span class="line">    MapState&lt;Long, Long&gt; windowPvMapState;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        windowPvMapState = getRuntimeContext().getMapState(<span class="keyword">new</span> MapStateDescriptor&lt;Long, Long&gt;(<span class="string">&quot;window-pv&quot;</span>, Long.class, Long.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(Event value, Context ctx, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 每来一条数据，就根据时间戳判断属于哪个窗口</span></span><br><span class="line">        Long windowStart = value.timestamp / windowSize * windowSize;</span><br><span class="line">        Long windowEnd = windowStart + windowSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册 end -1 的定时器，窗口触发计算</span></span><br><span class="line">        ctx.timerService().registerEventTimeTimer(windowEnd - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新状态中的pv值</span></span><br><span class="line">        <span class="keyword">if</span> (windowPvMapState.contains(windowStart))&#123;</span><br><span class="line">            Long pv = windowPvMapState.get(windowStart);</span><br><span class="line">            windowPvMapState.put(windowStart, pv + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            windowPvMapState.put(windowStart, <span class="number">1L</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定时器触发，直接输出统计的pv结果</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTimer</span><span class="params">(<span class="keyword">long</span> timestamp, OnTimerContext ctx, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Long windowEnd = timestamp + <span class="number">1</span>;</span><br><span class="line">        Long windowStart = windowEnd - windowSize;</span><br><span class="line">        Long pv = windowPvMapState.get(windowStart);</span><br><span class="line">        out.collect( <span class="string">&quot;url: &quot;</span> + ctx.getCurrentKey()</span><br><span class="line">                + <span class="string">&quot; 访问量: &quot;</span> + pv</span><br><span class="line">                + <span class="string">&quot; 窗口：&quot;</span> + <span class="keyword">new</span> Timestamp(windowStart) + <span class="string">&quot; ~ &quot;</span> + <span class="keyword">new</span> Timestamp(windowEnd));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟窗口的销毁，清除map中的key</span></span><br><span class="line">        windowPvMapState.remove(windowStart);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="归约状态-ReducingState"><a href="#归约状态-ReducingState" class="headerlink" title="归约状态(ReducingState)"></a>归约状态(ReducingState)</h4><p>似于值状态(Value)，不过需要对添加进来的所有数据进行归约，将归约聚合之后的值作为状态保存下来。ReducintState<T>这个接口调用的方法类似于 ListState，只不过它保存的只是一个聚合值，所以调用.add()方法时，不是在状态列表里添加元素，而是直接把新数据和之前的状态进行归约，并用得到的结果更新状态。</T></p>
<p>归约逻辑的定义，是在归约状态描述器(ReducingStateDescriptor)中，通过传入一个归 约函数(ReduceFunction)来实现的。这里的归约函数，就是我们之前介绍 reduce 聚合算子时讲到的 ReduceFunction，所以状态类型跟输入的数据类型是一样的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReducingStateDescriptor</span><span class="params">( String name, ReduceFunction&lt;T&gt; reduceFunction, Class&lt;T&gt; typeClass)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>这里的描述器有三个参数，其中第二个参数就是定义了归约聚合逻辑的 ReduceFunction， 另外两个参数则是状态的名称和类型。</p>
<h4 id="聚合状态-AggregatingState"><a href="#聚合状态-AggregatingState" class="headerlink" title="聚合状态(AggregatingState)"></a>聚合状态(AggregatingState)</h4><p>与归约状态非常类似，聚合状态也是一个值，用来保存添加进来的所有数据的聚合结果。与 ReducingState 不同的是，它的聚合逻辑是由在描述器中传入一个更加一般化的聚合函数(AggregateFunction)来定义的；这也就是之前我们讲过的 AggregateFunction，里面通过一个累加器(Accumulator)来表示状态，所以聚合的状态类型可以跟添加进来的数据类型完全不同，使用更加灵活。</p>
<p>同样地，AggregatingState 接口调用方法也与 ReducingState 相同，调用.add()方法添加元素时，会直接使用指定的 AggregateFunction 进行聚合并更新状态。</p>
<p>们举一个简单的例子，对用户点击事件流每 5 个数据统计一次平均时间戳。这是一个类似计数窗口(CountWindow)求平均值的计算，这里我们可以使用一个有聚合状态的 RichFlatMapFunction 来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AverageTimestampExample</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    SingleOutputStreamOperator&lt;Event&gt; stream = env.addSource(<span class="keyword">new</span> ClickSource())</span><br><span class="line">            .assignTimestampsAndWatermarks(WatermarkStrategy.&lt;Event&gt;forMonotonousTimestamps()</span><br><span class="line">                    .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Event&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Event element, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> element.timestamp;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计每个用户的点击频次，到达5次就输出统计结果</span></span><br><span class="line">    stream.keyBy(data -&gt; data.user)</span><br><span class="line">            .flatMap(<span class="keyword">new</span> AvgTsResult())</span><br><span class="line">            .print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AvgTsResult</span> <span class="keyword">extends</span> <span class="title">RichFlatMapFunction</span>&lt;<span class="title">Event</span>, <span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 定义聚合状态，用来计算平均时间戳</span></span><br><span class="line">    AggregatingState&lt;Event, Long&gt; avgTsAggState;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个值状态，用来保存当前用户访问频次</span></span><br><span class="line">    ValueState&lt;Long&gt; countState;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        avgTsAggState = getRuntimeContext().getAggregatingState(<span class="keyword">new</span> AggregatingStateDescriptor&lt;Event, Tuple2&lt;Long, Long&gt;, Long&gt;(</span><br><span class="line">                <span class="string">&quot;avg-ts&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> AggregateFunction&lt;Event, Tuple2&lt;Long, Long&gt;, Long&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Tuple2&lt;Long, Long&gt; <span class="title">createAccumulator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> Tuple2.of(<span class="number">0L</span>, <span class="number">0L</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Tuple2&lt;Long, Long&gt; <span class="title">add</span><span class="params">(Event value, Tuple2&lt;Long, Long&gt; accumulator)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> Tuple2.of(accumulator.f0 + value.timestamp, accumulator.f1 + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Long <span class="title">getResult</span><span class="params">(Tuple2&lt;Long, Long&gt; accumulator)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> accumulator.f0 / accumulator.f1;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Tuple2&lt;Long, Long&gt; <span class="title">merge</span><span class="params">(Tuple2&lt;Long, Long&gt; a, Tuple2&lt;Long, Long&gt; b)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                Types.TUPLE(Types.LONG, Types.LONG)</span><br><span class="line">        ));</span><br><span class="line"></span><br><span class="line">        countState = getRuntimeContext().getState(<span class="keyword">new</span> ValueStateDescriptor&lt;Long&gt;(<span class="string">&quot;count&quot;</span>, Long.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(Event value, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Long count = countState.value();</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="keyword">null</span>)&#123;</span><br><span class="line">            count = <span class="number">1L</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        countState.update(count);</span><br><span class="line">        avgTsAggState.add(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 达到5次就输出结果，并清空状态</span></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">5</span>)&#123;</span><br><span class="line">            out.collect(value.user + <span class="string">&quot; 平均时间戳：&quot;</span> + <span class="keyword">new</span> Timestamp(avgTsAggState.get()));</span><br><span class="line">            countState.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="状态生存时间-TTL"><a href="#状态生存时间-TTL" class="headerlink" title="状态生存时间(TTL)"></a>状态生存时间(TTL)</h4><p>在实际应用中，很多状态会随着时间的推移逐渐增长，如果不加以限制，最终就会导致存储空间的耗尽。一个优化的思路是直接在代码中调用.clear()方法去清除状态，但是有时候我们的逻辑要求不能直接清除。这时就需要配置一个状态的生存时间(time-to-live，TTL)，当状态在内存中存在的时间超出这个值时，就将它清除。</p>
<p>具体实现上，如果用一个进程不停地扫描所有状态看是否过期，显然会占用大量资源做无用功。状态的失效其实不需要立即删除，所以我们可以给状态附加一个属性，也就是状态的失效时间。状态创建的时候，设置 失效时间 = 当前时间 + TTL；之后如果有对状态的访问和修改，我们可以再对失效时间进行更新；当设置的清除条件被触发时(比如，状态被访问的时候、或者每隔一段时间扫描一次失效状态)，就可以判断状态是否失效、从而进行清除了。</p>
<p>配置状态的 TTL 时，需要创建一个 StateTtlConfig 配置对象，然后调用状态描述器的.enableTimeToLive()方法启动 TTL 功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">StateTtlConfig ttlConfig = StateTtlConfig</span><br><span class="line">   .newBuilder(Time.seconds(<span class="number">10</span>))</span><br><span class="line">   .setUpdateType(StateTtlConfig.UpdateType.OnCreateAndWrite)</span><br><span class="line">   .setStateVisibility(StateTtlConfig.StateVisibility.NeverReturnExpired)</span><br><span class="line">   .build();</span><br><span class="line">   </span><br><span class="line">ValueStateDescriptor&lt;String&gt; stateDescriptor = <span class="keyword">new</span> ValueStateDescriptor&lt;&gt;(<span class="string">&quot;my state&quot;</span>, String.class);</span><br><span class="line">stateDescriptor.enableTimeToLive(ttlConfig);</span><br></pre></td></tr></table></figure>

<p><strong>.newBuilder()</strong></p>
<p>状态 TTL 配置的构造器方法，必须调用，返回一个 Builder 之后再调用.build()方法就可以得到 StateTtlConfig 了。方法需要传入一个 Time 作为参数，这就是设定的状态生存时间。</p>
<p><strong>.setUpdateType()</strong></p>
<p>设置更新类型。更新类型指定了什么时候更新状态失效时间，这里的 OnCreateAndWrite 表示只有创建状态和更改状态(写操作)时更新失效时间。另一种类型 OnReadAndWrite 则表示无论读写操作都会更新失效时间，也就是只要对状态进行了访问，就表明它是活跃的，从而延长生存时间。这个配置默认为 OnCreateAndWrite。</p>
<p><strong>.setStateVisibility()</strong></p>
<p>设置状态的可见性。所谓的状态可见性，是指因为清除操作并不是实时的，所以当状态过期之后还有可能继续存在，这时如果对它进行访问，能否正常读取到就是一个问题了。这里设置的 NeverReturnExpired 是默认行为，表示从不返回过期值，也就是只要过期就认为它已经被清除了，应用不能继续读取；这在处理会话或者隐私数据时比较重要。对应的另一种配置是 ReturnExpireDefNotCleanedUp，就是如果过期状态还存在，就返回它的值。</p>
<p>除此之外，TTL 配置还可以设置在保存检查点(checkpoint)时触发清除操作，或者配置增量的清理(incremental cleanup)，还可以针对 RocksDB 状态后端使用压缩过滤器(compaction filter)进行后台清理。</p>
<p>这里需要注意，目前的 TTL 设置只支持处理时间。另外，所有集合类型的状态(例如 ListState、MapState)在设置 TTL 时，都是针对每一项(per-entry)元素的。也就是说，一个列表状态中的每一个元素，都会以自己的失效时间来进行清理，而不是整个列表一起清理。</p>
<h3 id="算子状态-Operator-State"><a href="#算子状态-Operator-State" class="headerlink" title="算子状态(Operator State)"></a>算子状态(Operator State)</h3><p>算子状态(Operator State)就是一个算子并行实例上定义的状态，作用范围被限定为当前算子任务。<strong>算子状态跟数据的 key 无关</strong>，所以不同 key 的数据只要被分发到同一个并行子任务， 就会访问到同一个 Operator State。</p>
<p>算子状态的实际应用场景不如 Keyed State 多，一般用在 Source 或 Sink 等与外部系统连接的算子上，或者完全没有 key 定义的场景。比如 Flink 的 Kafka 连接器中，就用到了算子状态。 在我们给 Source 算子设置并行度后，Kafka 消费者的每一个并行实例，都会为对应的主题topic分区维护一个偏移量， 作为算子状态保存起来。这在保证 Flink 应用精确一次(exactly-once)状态一致性时非常有用。 当算子的并行度发生变化时，算子状态也支持在并行的算子任务实例之间做重组分配。根据状态的类型不同，重组分配的方案也会不同。</p>
<p>算子状态也支持不同的结构类型，主要有三种：ListState、UnionListState 和 BroadcastState。</p>
<h4 id="列表状态-ListState-1"><a href="#列表状态-ListState-1" class="headerlink" title="列表状态(ListState)"></a>列表状态(ListState)</h4><p>与 Keyed State 中的列表状态的区别是：在算子状态的上下文中，不会按键(key)分别处理状态，所以每一个并行子任务上只会保留一个列表(list)，也就是当前并行子任务上所有状态项的集合。列表中的状态项就是可以重新分配的最细粒度，彼此之间完全独立。</p>
<p>当算子并行度进行缩放调整时，算子的列表状态中的所有元素项会被统一收集起来，相当于把多个分区的列表合并成了一个大列表，然后再均匀地分配给所有并行任务。这种均匀分配的具体方法就是轮询(round-robin)，与之前介绍的 rebanlance 数据传输方式类似， 是通过逐一发牌的方式将状态项平均分配的。这种方式也叫作平均分割重组(even-split redistribution)。</p>
<p>算子状态中不会存在键组(key group)这样的结构，所以为了方便重组分配，就把它直接定义成了列表(list)。这也就解释了，为什么算子状态中没有最简单的值状态(ValueState)。</p>
<h4 id="联合列表状态-UnionListState"><a href="#联合列表状态-UnionListState" class="headerlink" title="联合列表状态(UnionListState)"></a>联合列表状态(UnionListState)</h4><p>与 ListState 类似，联合列表状态也会将状态表示为一个列表。它与常规列表状态的区别在于，算子并行度进行缩放调整时对于状态的分配方式不同。</p>
<p>UnionListState 的重点就在于联合(union)。在并行度调整时，<strong>常规列表状态是轮询分配状态项</strong>，而<strong>联合列表状态的算子则会直接广播状态的完整列表</strong>。这样，并行度缩放之后的并行子任务就获取到了联合后完整的大列表，可以自行选择要使用的状态项和要丢弃的状态项。这种分配也叫作联合重组(union redistribution)。如果列表中状态项数量太多，为资源和效率考虑一般不建议使用联合重组的方式。</p>
<h4 id="广播状态-BroadcastState"><a href="#广播状态-BroadcastState" class="headerlink" title="广播状态(BroadcastState)"></a>广播状态(BroadcastState)</h4><p>有时我们希望<strong>算子并行子任务都保持同一份全局状态</strong>，用来做统一的配置和规则设定。 这时所有分区的所有数据都会访问到同一个状态，状态就像被广播到所有分区一样，这种特殊的算子状态，就叫作广播状态(BroadcastState)。</p>
<p>因为广播状态在每个并行子任务上的实例都一样，所以在并行度调整的时候就比较简单， 只要复制一份到新的并行任务就可以实现扩展；而对于并行度缩小的情况，可以将多余的并行子任务连同状态直接砍掉——因为状态都是复制出来的，并不会丢失。</p>
<p>在底层，广播状态是以类似映射结构(map)的键值对(key-value)来保存的，必须基于一个广播流(BroadcastStream)来创建。</p>
<p>我们举一个广播状态的应用案例。考虑在电商应用中，往往需要判断用户先后发生的行为的组合模式，比如登录-下单或者登录-支付，检测出这些连续的行为进行统计，就可以了解平台的运用状况以及用户的行为习惯。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取用户行为事件流</span></span><br><span class="line">    DataStreamSource&lt;Action&gt; actionStream = env.fromElements(</span><br><span class="line">            <span class="keyword">new</span> Action(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;login&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> Action(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;pay&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> Action(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;login&quot;</span>),</span><br><span class="line">            <span class="keyword">new</span> Action(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;buy&quot;</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义行为模式流，代表了要检测的标准</span></span><br><span class="line">    DataStreamSource&lt;Pattern&gt; patternStream = env</span><br><span class="line">            .fromElements(</span><br><span class="line">                    <span class="keyword">new</span> Pattern(<span class="string">&quot;login&quot;</span>, <span class="string">&quot;pay&quot;</span>),</span><br><span class="line">                    <span class="keyword">new</span> Pattern(<span class="string">&quot;login&quot;</span>, <span class="string">&quot;buy&quot;</span>)</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义广播状态的描述器，创建广播流</span></span><br><span class="line">    MapStateDescriptor&lt;Void, Pattern&gt; bcStateDescriptor = <span class="keyword">new</span> MapStateDescriptor&lt;&gt;(</span><br><span class="line">            <span class="string">&quot;patterns&quot;</span>, Types.VOID, Types.POJO(Pattern.class));</span><br><span class="line">    BroadcastStream&lt;Pattern&gt; bcPatterns = patternStream.broadcast(bcStateDescriptor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将事件流和广播流连接起来，进行处理</span></span><br><span class="line">    DataStream&lt;Tuple2&lt;String, Pattern&gt;&gt; matches = actionStream</span><br><span class="line">            .keyBy(data -&gt; data.userId)</span><br><span class="line">            .connect(bcPatterns)</span><br><span class="line">            .process(<span class="keyword">new</span> PatternEvaluator());</span><br><span class="line"></span><br><span class="line">    matches.print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PatternEvaluator</span> <span class="keyword">extends</span> <span class="title">KeyedBroadcastProcessFunction</span>&lt;<span class="title">String</span>, <span class="title">Action</span>, <span class="title">Pattern</span>, <span class="title">Tuple2</span>&lt;<span class="title">String</span>, <span class="title">Pattern</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个值状态，保存上一次用户行为</span></span><br><span class="line">    ValueState&lt;String&gt; prevActionState;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration conf)</span> </span>&#123;</span><br><span class="line">        prevActionState = getRuntimeContext().getState(</span><br><span class="line">                <span class="keyword">new</span> ValueStateDescriptor&lt;&gt;(<span class="string">&quot;lastAction&quot;</span>, Types.STRING));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processBroadcastElement</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            Pattern pattern,</span></span></span><br><span class="line"><span class="params"><span class="function">            Context ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">            Collector&lt;Tuple2&lt;String, Pattern&gt;&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        BroadcastState&lt;Void, Pattern&gt; bcState = ctx.getBroadcastState(</span><br><span class="line">                <span class="keyword">new</span> MapStateDescriptor&lt;&gt;(<span class="string">&quot;patterns&quot;</span>, Types.VOID, Types.POJO(Pattern.class)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将广播状态更新为当前的pattern</span></span><br><span class="line">        bcState.put(<span class="keyword">null</span>, pattern);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(Action action, ReadOnlyContext ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">                               Collector&lt;Tuple2&lt;String, Pattern&gt;&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Pattern pattern = ctx.getBroadcastState(</span><br><span class="line">                <span class="keyword">new</span> MapStateDescriptor&lt;&gt;(<span class="string">&quot;patterns&quot;</span>, Types.VOID, Types.POJO(Pattern.class))).get(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        String prevAction = prevActionState.value();</span><br><span class="line">        <span class="keyword">if</span> (pattern != <span class="keyword">null</span> &amp;&amp; prevAction != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果前后两次行为都符合模式定义，输出一组匹配</span></span><br><span class="line">            <span class="keyword">if</span> (pattern.action1.equals(prevAction) &amp;&amp; pattern.action2.equals(action.action)) &#123;</span><br><span class="line">                out.collect(<span class="keyword">new</span> Tuple2&lt;&gt;(ctx.getCurrentKey(), pattern));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新状态</span></span><br><span class="line">        prevActionState.update(action.action);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义用户行为事件POJO类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String userId;</span><br><span class="line">    <span class="keyword">public</span> String action;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Action</span><span class="params">(String userId, String action)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userId = userId;</span><br><span class="line">        <span class="keyword">this</span>.action = action;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Action&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;userId=&quot;</span> + userId +</span><br><span class="line">                <span class="string">&quot;, action=&#x27;&quot;</span> + action + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义行为模式POJO类，包含先后发生的两个行为</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pattern</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String action1;</span><br><span class="line">    <span class="keyword">public</span> String action2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pattern</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pattern</span><span class="params">(String action1, String action2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.action1 = action1;</span><br><span class="line">        <span class="keyword">this</span>.action2 = action2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Pattern&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;action1=&#x27;&quot;</span> + action1 + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, action2=&#x27;&quot;</span> + action2 + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="状态持久化和状态后端"><a href="#状态持久化和状态后端" class="headerlink" title="状态持久化和状态后端"></a>状态持久化和状态后端</h3><h4 id="检查点-Checkpoint"><a href="#检查点-Checkpoint" class="headerlink" title="检查点(Checkpoint)"></a>检查点(Checkpoint)</h4><p>有状态流应用中的检查点(checkpoint)，其实就是所有任务的状态在某个时间点的一个快照(一份拷贝)。</p>
<p>我们对状态进行持久化保存的目的是为了故障恢复；在发生故障、重启应用后，数据还会被发往之前分配的分区吗？显然不是，因为并行度可能发生了调整，不论是按键(key)的哈希值分区，还是直接轮询(round-robin)分区，数据分配到的分区都会发生变化。这很好理解，当打牌的人数 3 个增加到 4 个时，即使牌的次序不变，轮流发到每个人手里的牌也会不同。数据分区发生变化，带来的问题就是，怎么保证原先的状态跟故障恢复后数据的对应关系呢？</p>
<p>对于Keyed State这个问题很好解决：状态都是跟key相关的，而相同key的数据不管发往哪个分区，总是会全部进入一个分区的；于是只要将状态也按照 key 的哈希值计算出对应的分区，进行重组分配就可以了。恢复状态后继续处理数据，就总能按照 key 找到对应之前的状态，就保证了结果的一致性。所以 Flink 对 Keyed State 进行了非常完善的包装，我们不需实现 任何接口就可以直接使用。</p>
<p>而对于 Operator State 来说就会有所不同。因为不存在 key，所有数据发往哪个分区是不可预测的；也就是说，当发生故障重启之后，我们不能保证某个数据跟之前一样，进入到同一个并行子任务、访问同一个状态。所以 Flink 无法直接判断该怎样保存和恢复状态，而是提供了接口，让我们根据业务需求自行设计状态的快照保存(snapshot)和恢复(restore)逻辑。</p>
<p>在 Flink 中，对状态进行持久化保存的快照机制叫作检查点(Checkpoint)。于是使用算子状态时，就需要对检查点的相关操作进行定义，实现一个 CheckpointedFunction 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CheckpointedFunction</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保存状态快照到检查点时(外部持久化)，调用这个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">snapshotState</span><span class="params">(FunctionSnapshotContext context)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">    <span class="comment">// 初始化状态时调用这个方法，也会在恢复状态时调用</span></span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">initializeState</span><span class="params">(FunctionInitializationContext context)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BufferingSinkExample</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    env.enableCheckpointing(<span class="number">10000L</span>);</span><br><span class="line">      <span class="comment">//env.setStateBackend(new EmbeddedRocksDBStateBackend());</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//env.getCheckpointConfig().setCheckpointStorage(new FileSystemCheckpointStorage(&quot;&quot;));</span></span><br><span class="line"></span><br><span class="line">    CheckpointConfig checkpointConfig = env.getCheckpointConfig();</span><br><span class="line">    checkpointConfig.setCheckpointingMode(CheckpointingMode.EXACTLY_ONCE);</span><br><span class="line">    checkpointConfig.setMinPauseBetweenCheckpoints(<span class="number">500</span>);</span><br><span class="line">    checkpointConfig.setCheckpointTimeout(<span class="number">60000</span>);</span><br><span class="line">    checkpointConfig.setMaxConcurrentCheckpoints(<span class="number">1</span>);</span><br><span class="line">    checkpointConfig.enableExternalizedCheckpoints(CheckpointConfig.ExternalizedCheckpointCleanup.RETAIN_ON_CANCELLATION);</span><br><span class="line">    checkpointConfig.enableUnalignedCheckpoints();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    SingleOutputStreamOperator&lt;Event&gt; stream = env.addSource(<span class="keyword">new</span> ClickSource())</span><br><span class="line">            .assignTimestampsAndWatermarks(WatermarkStrategy.&lt;Event&gt;forMonotonousTimestamps()</span><br><span class="line">                    .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Event&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Event element, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> element.timestamp;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    stream.print(<span class="string">&quot;input&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 批量缓存输出</span></span><br><span class="line">    stream.addSink(<span class="keyword">new</span> BufferingSink(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferingSink</span> <span class="keyword">implements</span> <span class="title">SinkFunction</span>&lt;<span class="title">Event</span>&gt;, <span class="title">CheckpointedFunction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threshold;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ListState&lt;Event&gt; checkpointedState;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Event&gt; bufferedElements;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BufferingSink</span><span class="params">(<span class="keyword">int</span> threshold)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.threshold = threshold;</span><br><span class="line">        <span class="keyword">this</span>.bufferedElements = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Event value, Context context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        bufferedElements.add(value);</span><br><span class="line">        <span class="keyword">if</span> (bufferedElements.size() == threshold) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Event element: bufferedElements) &#123;</span><br><span class="line">                <span class="comment">// 输出到外部系统，这里用控制台打印模拟</span></span><br><span class="line">                System.out.println(element);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;==========输出完毕=========&quot;</span>);</span><br><span class="line">            bufferedElements.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">snapshotState</span><span class="params">(FunctionSnapshotContext context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        checkpointedState.clear();</span><br><span class="line">        <span class="comment">// 把当前局部变量中的所有元素写入到检查点中</span></span><br><span class="line">        <span class="keyword">for</span> (Event element : bufferedElements) &#123;</span><br><span class="line">            checkpointedState.add(element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initializeState</span><span class="params">(FunctionInitializationContext context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ListStateDescriptor&lt;Event&gt; descriptor = <span class="keyword">new</span> ListStateDescriptor&lt;&gt;(</span><br><span class="line">                <span class="string">&quot;buffered-elements&quot;</span>,</span><br><span class="line">                Types.POJO(Event.class));</span><br><span class="line"></span><br><span class="line">        checkpointedState = context.getOperatorStateStore().getListState(descriptor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是从故障中恢复，就将ListState中的所有元素添加到局部变量中</span></span><br><span class="line">        <span class="keyword">if</span> (context.isRestored()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Event element : checkpointedState.get()) &#123;</span><br><span class="line">                bufferedElements.add(element);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果保存检查点之后又处理了一些数据，然后发生了故障，那么重启恢复状态之后这些数据带来的状态改变会丢失。为了让最终处理结果正确，我们还需要让源(Source)算子重新读取这些数据，再次处理一遍。这就需要流的数据源具有<strong>数据重放</strong>的能力，一个典型的例子就是 Kafka，我们可以通过保存消费数据的偏移量、故障重启后重新提交来实现数据的重放。 这是对**至少一次(at least once)**状态一致性的保证，如果希望实现精确一次(exactly once) 的一致性，还需要数据写入外部系统时的相关保证。</p>
<p>默认情况下，检查点是被禁用的，需要在代码中手动开启。直接调用执行环境 的.enableCheckpointing()方法就可以开启检查点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StreamExecutionEnvironment env = StreamExecutionEnvironment.getEnvironment();</span><br><span class="line"><span class="comment">//这里传入的参数是检查点的间隔时间，单位为毫秒</span></span><br><span class="line">env.enableCheckpointing(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>除了检查点之外，Flink 还提供了保存点(savepoint)的功能。保存点在原理和形式上跟检查点完全一样，也是状态持久化保存的一个快照；区别在于，保存点是自定义的镜像保存，所以不会由 Flink 自动创建，而需要用户手动触发。这在有计划地停止、重启应用时非常有用。</p>
<h4 id="状态后端-State-Backends"><a href="#状态后端-State-Backends" class="headerlink" title="状态后端(State Backends)"></a>状态后端(State Backends)</h4><p>检查点的保存离不开 JobManager 和 TaskManager，以及外部存储系统的协调。在应用进行检查点保存时，首先会由 JobManager 向所有 TaskManager 发出触发检查点的命令；TaskManger 收到之后，将当前任务的所有状态进行快照保存，持久化到远程的存储介质中；完成之后向 JobManager 返回确认信息。这个过程是分布式的，当 JobManger 收到所有 TaskManager 的返回信息后，就会确认当前检查点成功保存，如图 9-5 所示。而这一切工作的协调，就需要一个专职人员来完成。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-03-28%20%E4%B8%8B%E5%8D%883.40.58.png" alt="截屏2022-03-28 下午3.40.58"></p>
<p>在 Flink 中，状态的存储、访问以及维护，都是由一个可插拔的组件决定的，这个组件就叫作状态后端(state backend)。状态后端主要负责两件事：一是本地的状态管理，二是将检查点(checkpoint)写入远程的持久化存储。</p>
<h5 id="状态后端的分类"><a href="#状态后端的分类" class="headerlink" title="状态后端的分类"></a><strong>状态后端的分类</strong></h5><p>状态后端是一个开箱即用的组件，可以在不改变应用程序逻辑的情况下独立配置。 Flink 中提供了两类不同的状态后端，一种是哈希表状态后端(HashMapStateBackend)，另一种是内嵌 RocksDB 状态后端(EmbeddedRocksDBStateBackend)。如果没有特别配置，系统默认的状态后端是 HashMapStateBackend。</p>
<p><strong>哈希表状态后端(HashMapStateBackend)</strong></p>
<p>这种方式就是我们之前所说的，把状态存放在<strong>内存</strong>里。具体实现上，哈希表状态后端在内部会直接把状态当作对象(objects)，保存在 Taskmanager 的 JVM 堆(heap)上。普通的<strong>状态</strong>，以及<strong>窗口中收集的数据</strong>和**触发器(triggers)**，都会以键值对(key-value)的形式存储起来，所以底层是一个哈希表(HashMap)，这种状态后端也因此得名。</p>
<p>对于检查点的保存，一般是放在持久化的分布式文件系统(file system)中，也可以通过配置检查点存储(CheckpointStorage)来另外指定。</p>
<p>HashMapStateBackend 是将本地状态全部放入内存的，这样可以获得最快的读写速度，使计算性能达到最佳；代价则是内存的占用。它适用于具有大状态、长窗口、大键值状态的作业，对所有高可用性设置也是有效的。</p>
<p><strong>内嵌 RocksDB 状态后端(EmbeddedRocksDBStateBackend)</strong></p>
<p>RocksDB 是一种内嵌的 key-value 存储介质，可以把数据持久化到<strong>本地硬盘</strong>。配置 EmbeddedRocksDBStateBackend 后，会将处理中的数据全部放入 RocksDB 数据库中，RocksDB 默认存储在 TaskManager 的本地数据目录里。</p>
<p>与 HashMapStateBackend 直接在堆内存中存储对象不同，这种方式下状态主要是放在 RocksDB 中的。数据被存储为**序列化的字节数组(Byte Arrays)**，读写操作需要序列化/反序列化，因此状态的访问性能要差一些。另外，因为做了序列化，key 的比较也会按照字节进行，而不是直接调用.hashCode()和.equals()方法。</p>
<p>对于检查点，同样会写入到远程的持久化文件系统中。</p>
<p>EmbeddedRocksDBStateBackend 始终执行的是异步快照，也就是不会因为保存检查点而阻塞数据的处理；而且它还提供了增量式保存检查点的机制，这在很多情况下可以大大提升保存效率。</p>
<p>由于它会把状态数据落盘，而且支持增量化的检查点，所以在状态非常大、窗口非常长、 键/值状态很大的应用场景中是一个好选择，同样对所有高可用性设置有效。</p>
<h5 id="如何选择正确的状态后端"><a href="#如何选择正确的状态后端" class="headerlink" title="如何选择正确的状态后端"></a>如何选择正确的状态后端</h5><p>HashMap 和 RocksDB 两种状态后端最大的区别，就在于本地状态存放在哪里：前者是内存，后者是 RocksDB。在实际应用中，选择那种状态后端，主要是需要根据业务需求在处理性能和应用的扩展性上做一个选择。</p>
<p>HashMapStateBackend 是内存计算，读写速度非常快；但是，状态的大小会受到集群可用内存的限制，如果应用的状态随着时间不停地增长，就会耗尽内存资源。</p>
<p>而 RocksDB 是硬盘存储，所以可以根据可用的磁盘空间进行扩展，而且是唯一支持增量检查点的状态后端，所以它非常适合于超级海量状态的存储。不过由于每个状态的读写都需要做序列化/反序列化，而且可能需要直接从磁盘读取数据，这就会导致性能的降低，平均读写性能要比 HashMapStateBackend 慢一个数量级。</p>
<h5 id="状态后端的配置"><a href="#状态后端的配置" class="headerlink" title="状态后端的配置"></a>状态后端的配置</h5><p>在不做配置的时候，应用程序使用的默认状态后端是由集群配置文件 flink-conf.yaml 中指定的，配置的键名称为 state.backend。这个默认配置对集群上运行的所有作业都有效，我们可以通过更改配置值来改变默认的状态后端。另外，我们还可以在代码中为当前作业单独配置状态后端，这个配置会覆盖掉集群配置文件的默认值。</p>
<p>配置默认的状态后端：</p>
<p>在 flink-conf.yaml 中，可以使用 state.backend 来配置默认状态后端。配置项的可能值为 hashmap，这样配置的就是 HashMapStateBackend；也可以是 rocksdb，这样配置的就是 EmbeddedRocksDBStateBackend。另外，也可以是一个实现了状态后端工厂 StateBackendFactory 的类的完全限定类名。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认状态后端</span></span><br><span class="line"><span class="attr">state.backend:</span> <span class="string">hashmap</span></span><br><span class="line"><span class="comment"># 存放检查点的文件路径</span></span><br><span class="line"><span class="attr">state.checkpoints.dir:</span> <span class="string">hdfs://namenode:40010/flink/checkpoints</span></span><br></pre></td></tr></table></figure>

<p>这里的 state.checkpoints.dir 配置项，定义了状态后端将检查点和元数据写入的目录。</p>
<p>为每个作业(Per-job)单独配置状态后端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">env.setStateBackend(<span class="keyword">new</span> HashMapStateBackend());</span><br><span class="line"><span class="comment">//env.setStateBackend(new EmbeddedRocksDBStateBackend());</span></span><br></pre></td></tr></table></figure>

<p>需添加依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-statebackend-rocksdb_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.13.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="容错机制"><a href="#容错机制" class="headerlink" title="容错机制"></a>容错机制</h2><h3 id="检查点的保存"><a href="#检查点的保存" class="headerlink" title="检查点的保存"></a>检查点的保存</h3><h4 id="周期性的触发保存"><a href="#周期性的触发保存" class="headerlink" title="周期性的触发保存"></a>周期性的触发保存</h4><p>随时存档确实恢复起来方便，可是需要我们不停地做存档操作。如果每处理一条数据就进行检查点的保存，当大量数据同时到来时，就会耗费很多资源来频繁做检查点，数据处理的速度就会受到影响。所以更好的方式是，每隔一段时间去做一次存档，这样既不会影响数据的正常处理，也不会有太大的延迟——毕竟故障恢复的情况不是随时发生的。在 Flink 中，检查点的保存是周期性触发的，间隔时间可以进行设置。</p>
<p>所以检查点作为应用状态的一份存档，其实就是所有任务状态在同一时间点的一个快照(snapshot)，它的触发是周期性的。具体来说，当每隔一段时间检查点保存操作被触发时， 就把每个任务当前的状态复制一份，按照一定的逻辑结构放在一起持久化保存起来，就构成了检查点。</p>
<h4 id="保存的时间点"><a href="#保存的时间点" class="headerlink" title="保存的时间点"></a>保存的时间点</h4><p>这里有一个关键问题：当检查点的保存被触发时，任务有可能正在处理某个数据，这时该怎么办呢？最简单的想法是，可以在某个时刻按下暂停键，让所有任务停止处理数据。这样状态就不再更改，大家可以一起复制保存；保存完毕之后，再同时恢复数据处理就可以了。 然而仔细思考就会发现这有很多问题。这种想法其实是粗暴地停止一切来拍照，在保存检查点的过程中，任务完全中断了，这会造成很大的延迟；我们之前为了实时性做出的所有设计就毁在了做快照上。另一方面，我们做快照的目的是为了故障恢复；现在的快照中，有些任务正在处理数据，那它保存的到底是处理到什么程度的状态呢？举个例子，我们在程序中某一步操作中自定义了一个 ValueState，处理的逻辑是：当遇到一个数据时，状态先加 1；而后经过一些其他步骤后再加 1。现在停止处理数据，状态到底是被加了 1 还是加了 2 呢？这很重要，因为状态恢复之后，我们需要知道当前数据从哪里开始继续处理。要满足这个要求，就必须将暂停时的所有环境信息都保存下来——而这显然是很麻烦的。 为了解决这个问题，我们不应该一刀切把所有任务同时停掉，而是至少得先把手头正在处理的数据弄完。这样的话，我们在检查点中就不需要保存所有上下文信息，只要知道当前处理到哪个数据就可以了。</p>
<p>但这样依然会有问题：分布式系统的节点之间需要通过网络通信来传递数据，如果我们保存检查点的时候刚好有数据在网络传输的路上，那么下游任务是没法将数据保存起来的；故障重启之后，我们只能期待上游任务重新发送这个数据。然而上游任务是无法知道下游任务是否收到数据的，只能盲目地重发，这可能导致下游将数据处理两次，结果就会出现错误。</p>
<p>所以我们最终的选择是；当所有任务都恰好处理完一个相同的输入数据的时候，将它们的状态保存下来。首先，这样避免了除状态之外其他额外信息的存储，提高了检查点保存的效率。 其次，一个数据要么就是被所有任务完整地处理完，状态得到了保存；要么就是没处理完，状态全部没保存：这就相当于构建了一个事务(transaction)。如果出现故障，我们恢复到之前保存的状态，故障时正在处理的所有数据都需要重新处理；所以我们只需要让源(source) 任务向数据源重新提交偏移量、请求重放数据就可以了。这<strong>需要源任务可以把偏移量作为算子状态保存下来</strong>，而且<strong>外部数据源能够重置偏移量</strong>；Kafka 就是满足这些要求的一个最好的例子。</p>
<h4 id="保存的具体流程"><a href="#保存的具体流程" class="headerlink" title="保存的具体流程"></a>保存的具体流程</h4><p>检查点的保存，最关键的就是要等所有任务将同一个数据处理完毕。下面我们通过一个具体的例子，来详细描述一下检查点具体的保存过程。回忆一下我们最初实现的统计词频的程序——WordCount。这里为了方便，我们直接从数据源读入已经分开的一个个单词，例如这里输入的就是：hello world hello flink hello world hello flink …… 对应的代码就可以简化为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SingleOutputStreamOperator&lt;Tuple2&lt;String, Long&gt;&gt; wordCountStream =</span><br><span class="line">   env.addSource(...)</span><br><span class="line">       .map(word -&gt; Tuple2.of(word, <span class="number">1L</span>))</span><br><span class="line">       .returns(Types.TUPLE(Types.STRING, Types.LONG))</span><br><span class="line">       .keyBy(t -&gt; t.f0)</span><br><span class="line">       .sum(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>源(Source)任务从外部数据源读取数据，并<strong>记录当前的偏移量</strong>，作为<strong>算子状态(Operator State)<strong>保存下来。然后将数据发给下游的 Map 任务，它会将一个单词转换成(word, count)二元组，初始 count 都是 1，也就是(“hello”, 1)、(“world”, 1)这样的形式；这是一个无状态的算子任务。进而以 word 作为键(key)进行分区，调用.sum()方法就可以对 count 值进行求和统计了；Sum 算子会把当前</strong>求和的结果</strong>作为**按键分区状态(Keyed State)**保存下来。最后得到的就是当前单词的频次统计(word, count)，如图 10-2 所示。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-07-11%20%E4%B8%8B%E5%8D%883.02.09.png" alt="截屏2022-07-11 下午3.02.09"></p>
<p>当我们需要保存检查点(checkpoint)时，就是在所有任务处理完同一条数据后，对状态做个快照保存下来。例如上图中，已经处理了 3 条数据：”hello” “world” “hello”，所以我们会看到 Source 算子的偏移量为 3；后面的 Sum 算子处理完第三条数据”hello”之后，此时已经有 2 个”hello”和 1 个”world”，所以对应的状态为”hello”-&gt; 2，”world”-&gt; 1(这里 KeyedState 底层会以 key-value 形式存储)。此时所有任务都已经处理完了前三个数据，所以我们可以把当前的状态保存成一个检查点，写入外部存储中。至于具体保存到哪里，这是由状态后端的配置项检查点存储(CheckpointStorage)来决定的，可以有作业管理器的堆内存(JobManagerCheckpointStorage)和文件系统(FileSystemCheckpointStorage)两种选择。一般情况下，我们会将检查点写入持久化的分布式文件系统。</p>
<h3 id="从检查点恢复状态"><a href="#从检查点恢复状态" class="headerlink" title="从检查点恢复状态"></a>从检查点恢复状态</h3><p>在运行流处理程序时，Flink 会周期性地保存检查点。当发生故障时，就需要找到最近一次成功保存的检查点来恢复状态。例如在上节的 word count 示例中，我们处理完三个数据后保存了一个检查点。之后继续运行，又正常处理了一个数据”flink”，在处理第五个数据”hello”时发生了故障，如图 10-3 所示。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-07-11%20%E4%B8%8B%E5%8D%883.09.55.png" alt="截屏2022-07-11 下午3.09.55"></p>
<p>这里 Source 任务已经处理完毕，所以偏移量为 5；Map 任务也处理完成了。而 Sum 任务在处理中发生了故障，此时状态并未保存。</p>
<p>接下来就需要从检查点来恢复状态了。具体的步骤为：</p>
<h4 id="重启应用"><a href="#重启应用" class="headerlink" title="重启应用"></a>重启应用</h4><p>遇到故障之后，第一步当然就是重启。我们将应用重新启动后，<strong>所有任务的状态会清空</strong>， 如图 10-4 所示。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-07-11%20%E4%B8%8B%E5%8D%883.12.40.png" alt="截屏2022-07-11 下午3.12.40"></p>
<h4 id="读取检查点，重置状态"><a href="#读取检查点，重置状态" class="headerlink" title="读取检查点，重置状态"></a>读取检查点，重置状态</h4><p>找到最近一次保存的检查点，从中读出每个算子任务状态的快照，分别填充到对应的状态中。这样，Flink 内部所有任务的状态，就恢复到了保存检查点的那一时刻，也就是刚好处理完第三个数据的时候，如图 10-5 所示。这里 key 为”flink”并没有数据到来，所以初始为 0。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-07-11%20%E4%B8%8B%E5%8D%883.32.10.png" alt="截屏2022-07-11 下午3.32.10"></p>
<h4 id="重放数据"><a href="#重放数据" class="headerlink" title="重放数据"></a>重放数据</h4><p>从检查点恢复状态后还有一个问题：如果直接继续处理数据，那么保存检查点之后、到发生故障这段时间内的数据，也就是第 4、5 个数据(“flink” “hello”)就相当于丢掉了；这会造成计算结果的错误。为了不丢数据，我们应该从保存检查点后开始重新读取数据，这可以通过 Source 任务**向外部数据源重新提交偏移量(offset)**来实现，如图 10-6 所示。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-07-11%20%E4%B8%8B%E5%8D%883.35.06.png" alt="截屏2022-07-11 下午3.35.06"></p>
<h4 id="继续处理数据"><a href="#继续处理数据" class="headerlink" title="继续处理数据"></a>继续处理数据</h4><p>接下来，我们就可以正常处理数据了。首先是重放第 4、5 个数据，然后继续读取后面的数据，如图 10-7 所示。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-07-11%20%E4%B8%8B%E5%8D%883.35.40.png" alt="截屏2022-07-11 下午3.35.40"></p>
<p>当处理到第 5 个数据时，就已经追上了发生故障时的系统状态。之后继续处理，就好像没有发生过故障一样；我们既没有丢掉数据也没有重复计算数据，这就保证了计算结果的正确性。 在分布式系统中，这叫作实现了”精确一次”(exactly-once)的状态一致性保证。</p>
<p>这里我们也可以发现，想要正确地从检查点中读取并恢复状态，必须知道**每个算子任务状态的类型和它们的先后顺序(拓扑结构)**；因此为了可以从之前的检查点中恢复状态，我们在改动程序、修复 bug 时要保证状态的拓扑顺序和类型不变。状态的拓扑结构在 JobManager 上可以由 JobGraph 分析得到，而检查点保存的定期触发也是由 JobManager 控制的；所以故障恢复的过程需要 JobManager 的参与。</p>
<h3 id="检查点算法"><a href="#检查点算法" class="headerlink" title="检查点算法"></a>检查点算法</h3><p>略</p>
<h3 id="检查点配置"><a href="#检查点配置" class="headerlink" title="检查点配置"></a>检查点配置</h3><h4 id="启用检查点"><a href="#启用检查点" class="headerlink" title="启用检查点"></a>启用检查点</h4><p>默认情况下，Flink 程序是禁用检查点的。如果想要为 Flink 应用开启自动保存快照的功能，需要在代码中显式地调用执行环境的.enableCheckpointing()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment(); </span><br><span class="line"><span class="comment">// 每隔1秒启动一次检查点保存 </span></span><br><span class="line">env.enableCheckpointing(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>这里需要传入一个长整型的<strong>毫秒数</strong>，表示周期性保存检查点的间隔时间。如果不传参数直接启用检查点，默认的间隔周期为 500 毫秒，这种方式已经被弃用。检查点的间隔时间是对处理性能和故障恢复速度的一个权衡。如果我们希望对性能的影响更小，可以调大间隔时间；而如果希望故障重启后迅速赶上实时的数据处理，就需要将间隔时间设小一些。</p>
<h4 id="检查点存储-Checkpoint-Storage"><a href="#检查点存储-Checkpoint-Storage" class="headerlink" title="检查点存储(Checkpoint Storage)"></a>检查点存储(Checkpoint Storage)</h4><p>检查点具体的持久化存储位置，取决于”检查点存储”(CheckpointStorage)的设置。默认情况下，检查点存储在 JobManager 的堆(heap)内存中。而对于大状态的持久化保存，Flink 也提供了在其他存储位置进行保存的接口，这就是 CheckpointStorage。具体可以通过调用检查点配置的.setCheckpointStorage()来配置，需要传入一个 CheckpointStorage 的实现类。Flink 主要提供了两种 CheckpointStorage：**作业管理器的堆内存(JobManagerCheckpointStorage)<strong>和</strong>文件系统(FileSystemCheckpointStorage)**。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置存储检查点到JobManager堆内存 </span></span><br><span class="line">env.getCheckpointConfig().setCheckpointStorage(<span class="keyword">new</span> JobManagerCheckpointStorage());</span><br><span class="line"><span class="comment">//配置存储检查点到文件系统 </span></span><br><span class="line">env.getCheckpointConfig().setCheckpointStorage(<span class="keyword">new</span> FileSystemCheckpointStorage(<span class="string">&quot;hdfs://namenode:40010/flink/checkpoints&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>对于实际生产应用，我们一般会将 CheckpointStorage 配置为高可用的分布式文件系统 (HDFS，S3 等)。</p>
<h4 id="其他高级配置"><a href="#其他高级配置" class="headerlink" title="其他高级配置"></a><strong>其他高级配置</strong></h4><p>检查点还有很多可以配置的选项，可以通过获取检查点配置(CheckpointConfig)来进行设置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CheckpointConfig checkpointConfig = env.getCheckpointConfig();</span><br></pre></td></tr></table></figure>

<p>我们这里做一个简单的列举说明：</p>
<h5 id="检查点模式-CheckpointingMode"><a href="#检查点模式-CheckpointingMode" class="headerlink" title="检查点模式(CheckpointingMode)"></a>检查点模式(CheckpointingMode)</h5><p>设置检查点一致性的保证级别，有”精确一次”(exactly-once)和”至少一次”(at-least-once)两个选项。默认级别为 exactly-once，而对于大多数低延迟的流处理程序，at-least-once 就够用了，而且处理效率会更高。</p>
<h5 id="超时时间-checkpointTimeout"><a href="#超时时间-checkpointTimeout" class="headerlink" title="超时时间(checkpointTimeout)"></a>超时时间(checkpointTimeout)</h5><p>用于指定检查点保存的超时时间，超时没完成就会被丢弃掉。传入一个长整型毫秒数作为参数，表示超时时间。</p>
<h5 id="最小间隔时间-minPauseBetweenCheckpoints"><a href="#最小间隔时间-minPauseBetweenCheckpoints" class="headerlink" title="最小间隔时间(minPauseBetweenCheckpoints)"></a>最小间隔时间(minPauseBetweenCheckpoints)</h5><p>用于指定在上一个检查点完成之后，检查点协调器(checkpoint coordinator)最快等多久可以出发保存下一个检查点的指令。这就意味着即使已经达到了周期触发的时间点，只要距离上一个检查点完成的间隔不够，就依然不能开启下一次检查点的保存。这就为正常处理数据留下了充足的间隙。当指定这个参数时，maxConcurrentCheckpoints 的值强制为 1。</p>
<h5 id="最大并发检查点数量-maxConcurrentCheckpoints"><a href="#最大并发检查点数量-maxConcurrentCheckpoints" class="headerlink" title="最大并发检查点数量(maxConcurrentCheckpoints)"></a>最大并发检查点数量(maxConcurrentCheckpoints)</h5><p>用于指定运行中的检查点最多可以有多少个。由于每个任务的处理进度不同，完全可能出现后面的任务还没完成前一个检查点的保存、前面任务已经开始保存下一个检查点了。这个参数就是限制同时进行的最大数量。如果前面设置了 minPauseBetweenCheckpoints，则 maxConcurrentCheckpoints 这个参数就不起作用了。</p>
<h5 id="开启外部持久化存储-enableExternalizedCheckpoints"><a href="#开启外部持久化存储-enableExternalizedCheckpoints" class="headerlink" title="开启外部持久化存储(enableExternalizedCheckpoints)"></a>开启外部持久化存储(enableExternalizedCheckpoints)</h5><p>用于开启检查点的外部持久化，而且默认在作业失败的时候不会自动清理，如果想释放空间需要自己手工清理。里面传入的参数ExternalizedCheckpointCleanup 指定了当作业取消的时候外部的检查点该如何清理。</p>
<p>DELETE_ON_CANCELLATION：在作业取消的时候会自动删除外部检查点，但是如果是作业失败退出，则会保留检查点。</p>
<p>RETAIN_ON_CANCELLATION：作业取消的时候也会保留外部检查点。 </p>
<p><strong>检查点异常时是否让整个任务失败(failOnCheckpointingErrors)</strong></p>
<p>用于指定在检查点发生异常的时候，是否应该让任务直接失败退出。默认为 true，如果设置为 false，则任务会丢弃掉检查点然后继续运行。 </p>
<p><strong>不对齐检查点(enableUnalignedCheckpoints)</strong></p>
<p>不再执行检查点的分界线对齐操作，启用之后可以大大减少产生背压时的检查点保存时间。这个设置要求检查点模式(CheckpointingMode)必须为 exctly-once，并且并发的检查点个数为 1。</p>
<p>代码中具体设置如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"><span class="comment">//启用检查点，间隔时间1秒</span></span><br><span class="line">env.enableCheckpointing(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">CheckpointConfig checkpointConfig = env.getCheckpointConfig();</span><br><span class="line"><span class="comment">//设置精确一次模式</span></span><br><span class="line">checkpointConfig.setCheckpointingMode(CheckpointingMode.EXACTLY_ONCE); </span><br><span class="line"><span class="comment">//最小间隔时间500毫秒</span></span><br><span class="line">checkpointConfig.setMinPauseBetweenCheckpoints(<span class="number">500</span>);</span><br><span class="line"><span class="comment">//超时时间1分钟</span></span><br><span class="line">checkpointConfig.setCheckpointTimeout(<span class="number">60000</span>);</span><br><span class="line"><span class="comment">//同时只能有一个检查点</span></span><br><span class="line">checkpointConfig.setMaxConcurrentCheckpoints(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//开启检查点的外部持久化保存，作业取消后依然保留</span></span><br><span class="line">checkpointConfig.enableExternalizedCheckpoints(ExternalizedCheckpointCleanup.RETAIN_ON_CANCELLATION);</span><br><span class="line"><span class="comment">//启用不对齐的检查点保存方式</span></span><br><span class="line">checkpointConfig.enableUnalignedCheckpoints();</span><br><span class="line"><span class="comment">//设置检查点存储，可以直接传入一个String，指定文件系统的路径</span></span><br><span class="line">checkpointConfig.setCheckpointStorage(<span class="string">&quot;hdfs://my/checkpoint/dir&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="保存点-Savepoint"><a href="#保存点-Savepoint" class="headerlink" title="保存点(Savepoint)"></a>保存点(Savepoint)</h3><p>除了检查点(checkpoint)外，Flink 还提供了另一个非常独特的镜像保存功能——保存点 (Savepoint)。</p>
<p>从名称就可以看出，这也是一个存盘的备份，它的原理和算法与检查点完全相同，只是<strong>多了一些额外的元数据</strong>。事实上，保存点就是通过检查点的机制来创建流式作业状态的一致性镜像(consistent image)的。</p>
<p>保存点中的状态快照，是以算子 ID 和状态名称组织起来的，相当于一个键值对。从保存点启动应用程序时，Flink 会将保存点的状态数据重新分配给相应的算子任务。</p>
<h4 id="保存点的用途"><a href="#保存点的用途" class="headerlink" title="保存点的用途"></a>保存点的用途</h4><p>保存点与检查点最大的区别，就是<strong>触发的时机</strong>。检查点是由 Flink 自动管理的，定期创建， 发生故障之后自动读取进行恢复，这是一个”自动存盘”的功能；而<strong>保存点不会自动创建</strong>，必须由用户明确地<strong>手动触发</strong>保存操作，所以就是”手动存盘”。因此两者尽管原理一致，但用途就有所差别了：检查点主要用来做故障恢复，是容错机制的核心；保存点则更加灵活，可以用来做有计划的手动备份和恢复。</p>
<p>保存点可以当作一个强大的运维工具来使用。我们可以在需要的时候创建一个保存点，然后停止应用，做一些处理调整之后再从保存点重启。它适用的具体场景有：</p>
<p><strong>版本管理和归档存储</strong></p>
<p>对重要的节点进行手动备份，设置为某一版本，归档(archive)存储应用程序的状态。 </p>
<p><strong>更新Flink版本</strong></p>
<p>目前 Flink 的底层架构已经非常稳定，所以当 Flink 版本升级时，程序本身一般是兼容的。</p>
<p>这时不需要重新执行所有的计算，只要创建一个保存点，停掉应用、升级 Flink 后，从保存点重启就可以继续处理了。</p>
<p><strong>更新应用程序</strong></p>
<p>我们不仅可以在应用程序不变的时候，更新 Flink 版本；还可以直接更新应用程序。前提是程序必须是兼容的，也就是说更改之后的程序，状态的拓扑结构和数据类型都是不变的，这样才能正常从之前的保存点去加载。这个功能非常有用。我们可以及时修复应用程序中的逻辑 bug，更新之后接着继续处理；也可以用于有不同业务逻辑的场景，比如 A/B 测试等等。</p>
<p><strong>调整并行度</strong></p>
<p>如果应用运行的过程中，发现需要的资源不足或已经有了大量剩余，也可以通过从保存点重启的方式，将应用程序的并行度增大或减小。</p>
<p><strong>暂停应用程序</strong></p>
<p>有时候我们不需要调整集群或者更新程序，只是单纯地希望把应用暂停、释放一些资源来处理更重要的应用程序。使用保存点就可以灵活实现应用的暂停和重启，可以对有限的集群资源做最好的优化配置。 </p>
<p>需要注意的是，保存点能够在程序更改的时候依然兼容，前提是状态的拓扑结构和数据类型不变。我们知道保存点中状态都是以<strong>算子ID-状态名称</strong>这样的 key-value 组织起来的，算子ID可以在代码中直接调用 SingleOutputStreamOperator 的.uid() 方法来进行指定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;String&gt; stream = env</span><br><span class="line">  .addSource(<span class="keyword">new</span> StatefulSource())</span><br><span class="line">  .uid(<span class="string">&quot;source-id&quot;</span>)</span><br><span class="line">  .map(<span class="keyword">new</span> StatefulMapper())</span><br><span class="line">  .uid(<span class="string">&quot;mapper-id&quot;</span>)</span><br><span class="line">  .print();</span><br></pre></td></tr></table></figure>

<p>对于没有设置 ID 的算子，Flink 默认会自动进行设置，所以在重新启动应用后可能会导致 ID 不同而无法兼容以前的状态。所以为了方便后续的维护，强烈建议在程序中为每一个算子手动指定 ID。</p>
<h4 id="使用保存点"><a href="#使用保存点" class="headerlink" title="使用保存点"></a>使用保存点</h4><p>保存点的使用非常简单，我们可以使用命令行工具来创建保存点，也可以从保存点恢复作业。</p>
<p><strong>创建保存点</strong></p>
<p>要在命令行中为运行的作业创建一个保存点镜像，只需要执行:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/flink savepoint :jobId [:targetDirectory]</span><br></pre></td></tr></table></figure>

<p>这里 jobId 需要填充要做镜像保存的作业 ID，目标路径 targetDirectory 可选，表示保存点存储的路径。</p>
<p>对于保存点的默认路径，可以通过配置文件 flink-conf.yaml 中的 state.savepoints.dir 项来设定：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">state.savepoints.dir: hdfs:///flink/savepoints</span><br></pre></td></tr></table></figure>

<p>当然对于单独的作业，我们也可以在程序代码中通过执行环境来设置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env.setDefaultSavepointDir(<span class="string">&quot;hdfs:///flink/savepoints&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>由于创建保存点一般都是希望更改环境之后重启，所以创建之后往往紧接着就是停掉作业的操作。除了对运行的作业创建保存点，我们也可以在停掉一个作业时直接创建保存点：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/flink stop --savepointPath [:targetDirectory] :jobId</span><br></pre></td></tr></table></figure>

<p><strong>从保存点重启应用</strong><br> 我们已经知道，提交启动一个Flink作业，使用的命令是flink run；现在要从保存点重启一个应用，其实本质是一样的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/flink run -s :savepointPath [:runArgs]</span><br></pre></td></tr></table></figure>

<p>这里只要增加一个-s 参数，指定保存点的路径就可以了，其他启动时的参数还是完全一样的。</p>
<h3 id="状态一致性"><a href="#状态一致性" class="headerlink" title="状态一致性"></a>状态一致性</h3><p>完整的流处理应用，应该包括了<strong>数据源</strong>、<strong>流处理器</strong>和<strong>外部存储系统</strong>三个部分。这个完整应用的一致性，就叫作端到端(end-to-end)的状态一致性，它取决于三个组件中最弱的那一环。一般来说，能否达到 at-least-once 一致性级别，主要看数据源能够重放数据；而能否达到 exactly-once 级别，流处理器内部、数据源、外部存储都要有相应的保证机制。</p>
<h4 id="输入端保障"><a href="#输入端保障" class="headerlink" title="输入端保障"></a>输入端保障</h4><p>输入端主要指的就是 Flink 读取的<strong>外部数据源</strong>。对于一些数据源来说，并不提供数据的缓冲或是持久化保存，数据被消费之后就彻底不存在了。例如 socket 文本流就是这样，socket 服务器是不负责存储数据的，发送一条数据之后，我们只能消费一次，是一锤子买卖。对于这样的数据源，故障后我们即使通过检查点恢复之前的状态，可保存检查点之后到发生故障期间的数据已经不能重发了，这就会导致数据丢失。所以就只能保证 at-most-once 的一致性语 义，相当于没有保证。</p>
<p>想要在故障恢复后不丢数据，外部数据源就必须拥有重放数据的能力。常见的做法就是<strong>对数据进行持久化保存</strong>，并且可以<strong>重设数据的读取位置</strong>。一个最经典的应用就是 Kafka。在 Flink 的 Source 任务中将数据读取的偏移量保存为状态，这样就可以在故障恢复时从检查点中读取出来，对数据源重置偏移量，重新获取数据。</p>
<p>数据源可重放数据，或者说可重置读取数据偏移量，加上 Flink 的 Source 算子将偏移量作为状态保存进检查点，就可以保证数据不丢。这是达到 at-least-once 一致性语义的基本要求， 当然也是实现端到端 exactly-once 的基本要求。</p>
<h4 id="输出端保障"><a href="#输出端保障" class="headerlink" title="输出端保障"></a>输出端保障</h4><p>有了 Flink 的检查点机制，以及可重放数据的外部数据源，我们已经能做到 at-least-once 了。但是想要实现 exactly-once 却有更大的困难：数据有可能重复写入外部系统。因为检查点保存之后，继续到来的数据也会一一处理，任务的状态也会更新，最终通过 Sink 任务将计算结果输出到外部系统；只是状态改变还没有存到下一个检查点中。这时如果出现故障，这些数据都会重新来一遍，就计算了两次。我们知道对 Flink 内部状态来说，重复计算的动作是没有影响的，因为状态已经回滚，最终改变只会发生一次；但对于外部系统来说， 已经写入的结果就是泼出去的水，已经无法收回了，再次执行写入就会把同一个数据写入两次。所以这时，我们只保证了端到端的 at-least-once 语义。</p>
<p>为了实现端到端 exactly-once，我们还需要对外部存储系统、以及 Sink 连接器有额外的要求。能够保证 exactly-once 一致性的写入方式有两种：<strong>幂等写入</strong><br>和<strong>事务写入</strong>，我们需要外部存储系统对这两种写入方式的支持，而 Flink 也为提供了一些 Sink 连接器接口。</p>
<h5 id="幂等-idempotent-写入"><a href="#幂等-idempotent-写入" class="headerlink" title="幂等(idempotent)写入"></a><strong>幂等(idempotent)写入</strong></h5><p>所谓幂等操作，就是说一个操作可以重复执行很多次，但只导致一次结果更改。也就是说，后面再重复执行就不会对结果起作用了。</p>
<p>数学中一个典型的例子是，ex 的求导下操作，无论做多少次，得到的都是自身。而在数据处理领域，最典型的就是对 HashMap 的插入操作：如果是相同的键值对，后面的重复插入就都没什么作用了。</p>
<p>这相当于说，我们并没有真正解决数据重复计算、写入的问题；而是说，重复写入也没关系，结果不会改变。所以这种方式主要的限制在于外部存储系统必须支持这样的幂等写入：比如 Redis 中键值存储，或者关系型数据库(如 MySQL)中满足查询条件的更新操作。</p>
<p>需要注意，对于幂等写入，遇到故障进行恢复时，有可能会出现短暂的不一致。因为保存点完成之后到发生故障之间的数据，其实已经写入了一遍，回滚的时候并不能消除它们。如果有一个外部应用读取写入的数据，可能会看到奇怪的现象：短时间内，结果会突然跳回到之前的某个值，然后重播一段之前的数据。不过当数据的重放逐渐超过发生故障的点的时候，最终的结果还是一致的。</p>
<h5 id="事务-transactional-写入"><a href="#事务-transactional-写入" class="headerlink" title="事务(transactional)写入"></a>事务(transactional)写入</h5><p>如果说幂等写入对应用场景限制太多，那么事务写入可以说是更一般化的保证一致性的方式。我们都知道，事务(transaction)是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所做的所有更改都会被撤消。事务有四个基本特性：原子性(Atomicity)、 一致性(Correspondence)、隔离性(Isolation)和持久性(Durability)，这就是著名的 ACID。</p>
<p>在 Flink 流处理的结果写入外部系统时，如果能够构建一个事务，<strong>让写入操作可以随着检查点来提交和回滚</strong>，那么自然就可以解决重复写入的问题了。所以事务写入的基本思想就是：用一个事务来进行数据向外部系统的写入，这个事务是与检查点绑定在一起的。当 Sink 任务遇到 barrier 时，开始保存状态的同时就开启一个事务，接下来所有数据的写入都在这个事务中；待到当前检查点保存完毕时，将事务提交，所有写入的数据就真正可用了。如果中间过程出现故障，状态会回退到上一个检查点，而当前事务没有正常关闭(因为当前检查点没有保存完)，所以也会回滚，写入到外部的数据就被撤销了。</p>
<p>具体来说，又有两种实现方式：<strong>预写日志(WAL)<strong>和</strong>两阶段提交(2PC)</strong> </p>
<p><strong>预写日志(write-ahead-log，WAL)</strong></p>
<p>我们发现，事务提交是需要外部存储系统支持事务的，否则没有办法真正实现写入的回撤。 那对于一般不支持事务的存储系统，能够实现事务写入呢？预写日志(WAL)就是一种非常简单的方式。具体步骤是：1、先把结果数据作为日志(log)状态保存起来 2、进行检查点保存时，也会将这些结果数据一并做持久化存储 3、在收到检查点完成的通知时，将所有结果一次性写入外部系统。 我们会发现，这种方式类似于检查点完成时做一个批处理，一次性的写入会带来一些性能上的问题；而优点就是比较简单，由于数据提前在状态后端中做了缓存，所以无论什么外部存储系统，理论上都能用这种方式一批搞定。在 Flink 中 DataStream API 提供了一个模板类 GenericWriteAheadSink，用来实现这种事务型的写入方式。</p>
<p>需要注意的是，预写日志这种一批写入的方式，有可能会写入失败；所以在执行写入动作之后，必须等待发送成功的返回确认消息。在成功写入所有数据后，在内部再次确认相应的检查点，这才代表着检查点的真正完成。这里需要将确认信息也进行持久化保存，在故障恢复时，只有存在对应的确认信息，才能保证这批数据已经写入，可以恢复到对应的检查点位置。 但这种”再次确认”的方式，也会有一些缺陷。如果我们的检查点已经成功保存、数据也成功地一批写入到了外部系统，但是最终保存确认信息时出现了故障，Flink 最终还是会认为没有成功写入。于是发生故障时，不会使用这个检查点，而是需要回退到上一个；这样就会导致这批数据的重复写入。</p>
<p><strong>两阶段提交(two-phase-commit，2PC)</strong></p>
<p>前面提到的各种实现 exactly-once 的方式，多少都有点缺陷，有没有更好的方法呢？自然是有的，这就是传说中的两阶段提交(2PC)。</p>
<p>顾名思义，它的想法是分成两个阶段：先做”预提交”，等检查点完成之后再正式提交。 这种提交方式是真正基于事务的，它需要外部系统提供事务支持。</p>
<p>具体的实现步骤为：1、当第一条数据到来时，或者收到检查点的分界线时，Sink 任务都会启动一个事务。 2、接下来接收到的所有数据，都通过这个事务写入外部系统；这时由于事务没有提交，所以数据尽管写入了外部系统，但是不可用，是”预提交”的状态。3、当 Sink 任务收到 JobManager 发来检查点完成的通知时，正式提交事务，写入的结果就真正可用了。 当中间发生故障时，当前未提交的事务就会回滚，于是所有写入外部系统的数据也就实现了撤回。这种两阶段提交(2PC)的方式充分利用了 Flink 现有的检查点机制：分界线的到来， 就标志着开始一个新事务；而收到来自 JobManager 的 checkpoint 成功的消息，就是提交事务的指令。每个结果数据的写入，依然是流式的，不再有预写日志时批处理的性能问题；最终提交时，也只需要额外发送一个确认信息。所以 2PC 协议不仅真正意义上实现了 exactly-once，而且通过搭载 Flink 的检查点机制来实现事务，只给系统增加了很少的开销。</p>
<p>Flink 提供了 TwoPhaseCommitSinkFunction 接口，方便我们自定义实现两阶段提交的 SinkFunction 的实现，提供了真正端到端的 exactly-once 保证。</p>
<p>不过两阶段提交虽然精巧，却对外部系统有很高的要求。这里将 2PC 对外部系统的要求列举如下:</p>
<p>1、外部系统必须提供事务支持，或者Sink任务必须能够模拟外部系统上的事务。</p>
<p>2、在检查点的间隔期间里，必须能够开启一个事务并接受数据写入。</p>
<p>3、在收到检查点完成的通知之前，事务必须是“等待提交”的状态。在故障恢复的情况下，这可能需要一些时间。如果这个时候外部系统关闭事务(例如超时了)，那么未提交的数据就会丢失。</p>
<p>4、Sink任务必须能够在进程失败后恢复事务。</p>
<p>5、提交事务必须是幂等操作。也就是说，事务的重复提交应该是无效的。</p>
<p>可见，2PC 在实际应用同样会受到比较大的限制。具体在项目中的选型，最终还应该是一致性级别和处理性能的权衡考量。</p>
<h4 id="Flink-和-Kafka-连接时的精确一次保证"><a href="#Flink-和-Kafka-连接时的精确一次保证" class="headerlink" title="Flink 和 Kafka 连接时的精确一次保证"></a>Flink 和 Kafka 连接时的精确一次保证</h4><p>在流处理的应用中，最佳的数据源当然就是可重置偏移量的消息队列了；它不仅可以提供<strong>数据重放</strong>的功能，而且天生就是以流的方式存储和处理数据的。所以作为大数据工具中消息队列的代表，Kafka 可以说与 Flink 是天作之合，实际项目中也经常会看到以 Kafka 作为<strong>数据源</strong>和<strong>写入的外部系统</strong>的应用。</p>
<h5 id="整体介绍"><a href="#整体介绍" class="headerlink" title="整体介绍"></a>整体介绍</h5><p>既然是端到端的 exactly-once，我们依然可以从三个组件的角度来进行分析：</p>
<p>(1)Flink 内部</p>
<p>Flink 内部可以通过<strong>检查点机制</strong>保证状态和处理结果的 exactly-once 语义。</p>
<p>(2)输入端</p>
<p>输入数据源端的 Kafka 可以对数据进行持久化保存，并可以**重置偏移量(offset)**。所以我们可以在 Source 任务(FlinkKafkaConsumer)中将当前读取的偏移量保存为算子状态，写入到检查点中；当发生故障时，从检查点中读取恢复状态，并由连接器 FlinkKafkaConsumer 向 Kafka 重新提交偏移量，就可以重新消费数据、保证结果的一致性了。</p>
<p>(3)输出端<br>输出端保证 exactly-once 的最佳实现，当然就是**两阶段提交(2PC)**。Flink 官方实现的 Kafka 连接器中，提供了写入到 Kafka 的 FlinkKafkaProducer，它就实现了 TwoPhaseCommitSinkFunction 接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlinkKafkaProducer</span>&lt;<span class="title">IN</span>&gt; <span class="keyword">extends</span> <span class="title">TwoPhaseCommitSinkFunction</span>&lt;<span class="title">IN</span>, <span class="title">FlinkKafkaProducer</span>.<span class="title">KafkaTransactionState</span>, <span class="title">FlinkKafkaProducer</span>.<span class="title">KafkaTransactionContext</span>&gt; </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，我们写入 Kafka 的过程实际上是一个两段式的提交：处理完毕得到结果，写入 Kafka 时是基于事务的”预提交”；等到检查点保存完毕，才会提交事务进行”正式提交”。如果中间出现故障，事务进行回滚，预提交就会被放弃；恢复状态之后，也只能恢复所有已经确认提交的操作。</p>
<h5 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h5><p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-07-11%20%E4%B8%8B%E5%8D%884.33.23.png" alt="截屏2022-07-11 下午4.33.23"></p>
<p>这是一个 Flink 与 Kafka 构建的完整数据管道，Source 任务从 Kafka 读取数据，经过一系列处理(比如窗口计算)，然后由 Sink 任务将结果再写入 Kafka。</p>
<p>Flink 与 Kafka 连接的两阶段提交，离不开检查点的配合，这个过程需要 JobManager 协调各个 TaskManager 进行状态快照，而检查点具体存储位置则是由状态后端(State Backend)来配置管理的。一般情况，我们会将检查点存储到分布式文件系统上。</p>
<p>实现端到端 exactly-once 的具体过程可以分解如下：</p>
<p><strong>(1)启动检查点保存</strong></p>
<p>检查点保存的启动，标志着我们进入了两阶段提交协议的”预提交”阶段。当然，现在还没有具体提交的数据。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-07-11%20%E4%B8%8B%E5%8D%884.35.15.png" alt="截屏2022-07-11 下午4.35.15"></p>
<p>如图 10-15 所示，JobManager 通知各个 TaskManager 启动检查点保存，Source 任务会将检查点分界线(barrier)注入数据流。这个 barrier 可以将数据流中的数据，分为进入当前检查点的集合和进入下一个检查点的集合。</p>
<p><strong>(2)算子任务对状态做快照</strong><br>分界线(barrier)会在算子间传递下去。每个算子收到 barrier 时，会将当前的状态做个快照，保存到状态后端。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-07-11%20%E4%B8%8B%E5%8D%884.36.20.png" alt="截屏2022-07-11 下午4.36.20"></p>
<p>如图 10-16 所示，Source 任务将 barrier 插入数据流后，也会将当前读取数据的偏移量作为状态写入检查点，存入状态后端；然后把 barrier 向下游传递，自己就可以继续读取数据了。接下来 barrier 传递到了内部的 Window 算子，它同样会对自己的状态进行快照保存，写入远程的持久化存储。</p>
<p><strong>(3)Sink 任务开启事务，进行预提交</strong></p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-07-11%20%E4%B8%8B%E5%8D%884.37.24.png" alt="截屏2022-07-11 下午4.37.24"></p>
<p>如图 10-17 所示，分界线(barrier)终于传到了 Sink 任务，这时 Sink 任务会开启一个事务。接下来到来的所有数据，Sink 任务都会通过这个事务来写入 Kafka。这里 barrier 是检查点的分界线，也是事务的分界线。由于之前的检查点可能尚未完成，因此上一个事务也可能尚未提交；此时 barrier 的到来开启了新的事务，上一个事务尽管可能没有被提交，但也不再接收新的数据了。</p>
<p>对于 Kafka 而言，提交的数据会被标记为未确认(uncommitted)。这个过程就是所谓的预提交(pre-commit)。</p>
<p><strong>(4)检查点保存完成，提交事务</strong></p>
<p>当所有算子的快照都完成，也就是这次的检查点保存最终完成时，JobManager 会向所有任务发确认通知，告诉大家当前检查点已成功保存，如图 10-18 所示。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-07-11%20%E4%B8%8B%E5%8D%884.39.01.png" alt="截屏2022-07-11 下午4.39.01"></p>
<p>当 Sink 任务收到确认通知后，就会正式提交之前的事务，把之前未确认的数据标为已确认，接下来就可以正常消费了。</p>
<p>在任务运行中的任何阶段失败，都会从上一次的状态恢复，所有没有正式提交的数据也会回滚。这样，Flink 和 Kafka 连接构成的流处理系统，就实现了端到端的 exactly-once 状态一致性。</p>
<h5 id="需要的配置"><a href="#需要的配置" class="headerlink" title="需要的配置"></a>需要的配置</h5><p>在具体应用中，实现真正的端到端 exactly-once，还需要有一些额外的配置：</p>
<p>(1)必须启用检查点</p>
<p>(2)在 FlinkKafkaProducer 的构造函数中传入参数 Semantic.EXACTLY_ONCE</p>
<p>(3)配置 Kafka 读取数据的消费者的隔离级别</p>
<p>这里所说的 Kafka，是写入的外部系统。预提交阶段数据已经写入，只是被标记为未提交(uncommitted)，而 Kafka 中默认的隔离级别 isolation.level 是 read_uncommitted，也就是可以读取未提交的数据。这样一来，外部应用就可以直接消费未提交的数据，对于事务性的保证就失效了。所以应该将隔离级别配置为 read_committed，表示消费者遇到未提交的消息时，会停止从分区中消费数据，直到消息被标记为已提交才会再次恢复消费。当然，这样做的话，外部应用消费数据就会有显著的延迟。</p>
<p>(4)事务超时配置</p>
<p>Flink 的 Kafka 连接器中配置的事务超时时间 transaction.timeout.ms 默认是 1 小时，而 Kafka集群配置的事务最大超时时间 transaction.max.timeout.ms 默认是 15 分钟。所以在检查点保存时间很长时，有可能出现 Kafka 已经认为事务超时了，丢弃了预提交的数据；而 Sink 任务认为还可以继续等待。如果接下来检查点保存成功，发生故障后回滚到这个检查点的状态，这部分数据就被真正丢掉了。所以这两个超时时间，前者应该小于等于后者。</p>
<h2 id="TableAPI和SQL"><a href="#TableAPI和SQL" class="headerlink" title="TableAPI和SQL"></a>TableAPI和SQL</h2><p>在 Flink 中这两种 API 被集成在一起，SQL 执行的对象也是 Flink 中的表(Table)，所以我们一般会认为它们是一体的。Flink 是批流统一的处理框架，无论是批处理(DataSet API)还是流处理(DataStream API)，在上层应用中都可以直接使用 Table API 或者 SQL 来实现；这两种 API 对于一张表执行相同的查询操作，得到的结果是完全一样的。</p>
<p>如果我们对关系型数据库和 SQL 非常熟悉，那么 Table API 和 SQL 的使用其实非常简单：只要得到一个表(Table)，然后对它调用 Table API，或者直接写 SQL 就可以了。接下来我们就以一个非常简单的例子上手，初步了解一下这种高层级 API 的使用方法。</p>
<p>我们想要在代码中使用 Table API，必须引入相关的依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-table-api-java-bridge_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里的依赖是一个 Java 的桥接器(bridge)，主要就是负责 Table API 和下层 DataStream API 的连接支持，按照不同的语言分为 Java 版和 Scala 版。</p>
<p>如果我们希望在本地的集成开发环境(IDE)里运行Table API和SQL，还需要引入以下依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-table-planner-blink_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-streaming-scala_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里主要添加的依赖是一个”计划器”(planner)，它是 Table API 的核心组件，负责提供运行时环境，并生成程序的执行计划。这里我们用到的是新版的blink planner。由于Flink安装包的 lib 目录下会自带 planner，所以在生产集群环境中提交的作业不需要打包这个依赖。而在 Table API 的内部实现上，部分相关的代码是用 Scala 实现的，所以还需要额外添加一个 Scala 版流处理的相关依赖。</p>
<p>另外，如果想实现自定义的数据格式来做序列化，可以引入下面的依赖:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-table-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h3><p>有了基本的依赖，接下来我们就可以尝试在 Flink 代码中使用 Table API 和 SQL 了。比如， 我们可以自定义一些 Event 类型(包含了 user、url 和 timestamp 三个字段，作为输入的数据源；而后从中提取 url 地址和用户名 user 两个字段作为输出。</p>
<p>如果使用 DataStream API，我们可以直接读取数据源后，用一个简单转换算子 map 来做字段的提取。而这个需求直接写 SQL 的话，实现会更加简单：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> url, <span class="keyword">user</span> <span class="keyword">from</span> EventTable;</span><br></pre></td></tr></table></figure>

<p>这里我们把流中所有数据组成的表叫作 EventTable。在 Flink 代码中直接对这个表执行上面的 SQL，就可以得到想要提取的数据了。</p>
<p>在代码中具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TableExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取流执行环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        env.setParallelism(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//读取数据源</span></span><br><span class="line">        SingleOutputStreamOperator&lt;Event&gt; eventStream = env.fromElements(</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./cart&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod?id=1&quot;</span>, <span class="number">5</span> * <span class="number">1000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Cary&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">60</span> * <span class="number">1000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./prod?id=3&quot;</span>, <span class="number">90</span> * <span class="number">1000L</span>),</span><br><span class="line">            <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod?id=7&quot;</span>, <span class="number">105</span> * <span class="number">1000L</span>)</span><br><span class="line">        );</span><br><span class="line">        <span class="comment">//获取表环境</span></span><br><span class="line">        StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env);</span><br><span class="line">        <span class="comment">//将数据流转换成表</span></span><br><span class="line">        Table eventTable = tableEnv.fromDataStream(eventStream);</span><br><span class="line">        <span class="comment">//用执行SQL的方式提取数据</span></span><br><span class="line">        Table visitTable = tableEnv.sqlQuery(<span class="string">&quot;select url, user from &quot;</span> + eventTable);</span><br><span class="line">        <span class="comment">//将表转换成数据流，打印输出</span></span><br><span class="line">        tableEnv.toDataStream(visitTable).print();</span><br><span class="line">        <span class="comment">//执行程序</span></span><br><span class="line">        env.execute();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们需要创建一个表环境(TableEnvironment)，然后将数据流(DataStream)转换成一个表(Table)；之后就可以执行 SQL 在这个表中查询数据了。查询得到的结果依然是一个表，把它重新转换成流就可以打印输出了。</p>
<p>代码执行的结果如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+<span class="selector-tag">I</span><span class="selector-attr">[./home, Alice]</span></span><br><span class="line">+<span class="selector-tag">I</span><span class="selector-attr">[./cart, Bob]</span></span><br><span class="line">+<span class="selector-tag">I</span><span class="selector-attr">[./prod?id=1, Alice]</span></span><br><span class="line">+<span class="selector-tag">I</span><span class="selector-attr">[./home, Cary]</span></span><br><span class="line">+<span class="selector-tag">I</span><span class="selector-attr">[./prod?id=3, Bob]</span></span><br><span class="line">+<span class="selector-tag">I</span><span class="selector-attr">[./prod?id=7, Alice]</span></span><br></pre></td></tr></table></figure>

<p>基于 Table 我们也可以调用一系列查询方法直接进行转换，这就是所谓 Table API 的处理方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用Table API方式提取数据</span></span><br><span class="line">Table clickTable2 = eventTable.select($(<span class="string">&quot;url&quot;</span>), $(<span class="string">&quot;user&quot;</span>));</span><br></pre></td></tr></table></figure>

<h3 id="基本API"><a href="#基本API" class="headerlink" title="基本API"></a>基本API</h3><h4 id="程序架构"><a href="#程序架构" class="headerlink" title="程序架构"></a>程序架构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建表环境</span></span><br><span class="line">TableEnvironment tableEnv = ...;</span><br><span class="line"><span class="comment">//创建输入表，连接外部系统读取数据</span></span><br><span class="line">tableEnv.executeSql(<span class="string">&quot;CREATE TEMPORARY TABLE inputTable ... WITH ( &#x27;connector&#x27; = ... )&quot;</span>);</span><br><span class="line"><span class="comment">//注册一个表，连接到外部系统，用于输出</span></span><br><span class="line">tableEnv.executeSql(<span class="string">&quot;CREATE TEMPORARY TABLE outputTable ... WITH ( &#x27;connector&#x27; = ... )&quot;</span>);</span><br><span class="line"><span class="comment">//执行 SQL 对表进行查询转换，得到一个新的表</span></span><br><span class="line">Table table1 = tableEnv.sqlQuery(<span class="string">&quot;SELECT ... FROM inputTable... &quot;</span>);</span><br><span class="line"><span class="comment">//使用 Table API 对表进行查询转换，得到一个新的表</span></span><br><span class="line">Table table2 = tableEnv.from(<span class="string">&quot;inputTable&quot;</span>).select(...);</span><br><span class="line"><span class="comment">//将得到的结果写入输出表</span></span><br><span class="line">TableResult tableResult = table1.executeInsert(<span class="string">&quot;outputTable&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这里不是从一个 DataStream 转换成 Table，而是通过执行 DDL 来直接创建一个表。这里执行的 CREATE 语句中<strong>用 WITH 指定了外部系统的连接器</strong>，于是就可以连接外部系统读取数据了。这其实是更加一般化的程序架构，因为这样我们就可以完全抛开 DataStream API，直接用 SQL 语句实现全部的流处理过程。而后面对于输出表的定义是完全一样的。可以发现，<strong>在创建表的过程中，其实并不区分输入还是输出</strong>，只需要将这个表<strong>注册</strong>进来、连接到外部系统就可以了；这里的 inputTable、 outputTable 只是注册的表名，并不代表处理逻辑，可以随意更换。至于表的具体作用，则要等到执行后面的查询转换操作时才能明确。我们直接从 inputTable 中查询数据，那么 inputTable 就是输入表；而 outputTable 会接收另外表的结果进行写入，那么就是输出表。</p>
<h4 id="创建表环境"><a href="#创建表环境" class="headerlink" title="创建表环境"></a>创建表环境</h4><p>对于 Flink 这样的流处理框架来说，数据流和表在结构上还是有所区别的。所以使用 Table API 和 SQL 需要一个特别的运行时环境，这就是所谓的表环境(TableEnvironment)。它主要负责：</p>
<p>(1)注册 Catalog 和表</p>
<p>(2)执行 SQL 查询</p>
<p>(3)注册用户自定义函数(UDF)</p>
<p>(4)DataStream 和表之间的转换</p>
<p>这里的 Catalog 就是目录，与标准 SQL 中的概念是一致的，主要用来管理所有数据库(database)和表(table)的元数据(metadata)。通过 Catalog 可以方便地对数据库和表进行查询的管理，所以可以认为我们所定义的表都会挂靠在某个目录下，这样就可以快速检索。 在表环境中可以由用户自定义 Catalog，并在其中注册表和自定义函数(UDF)。默认的 Catalog 就叫作 default_catalog。</p>
<p>每个表和 SQL 的执行，都必须绑定在一个表环境(TableEnvironment)中。TableEnvironment 是Table API中提供的基本接口类，可以通过调用静态的create()方法来创建一个表环境实例。 方法需要传入一个环境的配置参数 EnvironmentSettings，它可以指定当前表环境的执行模式和计划器(planner)。执行模式有批处理和流处理两种选择，默认是流处理模式；计划器默认使用 blink planner。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.table.api.EnvironmentSettings;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.table.api.TableEnvironment;</span><br><span class="line"></span><br><span class="line">EnvironmentSettings settings = EnvironmentSettings</span><br><span class="line">                                .newInstance()</span><br><span class="line">                                .inStreamingMode() <span class="comment">// 使用流处理模式</span></span><br><span class="line">                                .build();</span><br><span class="line">TableEnvironment tableEnv = TableEnvironment.create(settings);</span><br></pre></td></tr></table></figure>

<p>对于流处理场景，其实默认配置就完全够用了。所以我们也可以用另一种更加简单的方式来创建表环境：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.table.api.EnvironmentSettings;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.table.api.bridge.java.StreamTableEnvironment;</span><br><span class="line"></span><br><span class="line">StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env);</span><br></pre></td></tr></table></figure>

<p>这里我们引入了一个<strong>流式表环境</strong>(StreamTableEnvironment)，它是继承自 TableEnvironment 的子接口。调用它的 create()方法，只需要直接将当前的流执行环境 (StreamExecutionEnvironment)传入，就可以创建出对应的流式表环境了。</p>
<h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><p>表(Table)是我们非常熟悉的一个概念，它是关系型数据库中数据存储的基本形式，也是 SQL 执行的基本对象。Flink 中的表概念也并不特殊，是由多个行数据构成的，每个行(Row) 又可以有定义好的多个列(Column)字段；整体来看，表就是固定类型的数据组成的二维矩阵。</p>
<p>为了方便地查询表，表环境中会维护一个目录(Catalog)和表的对应关系。所以表都是通过 Catalog 来进行注册创建的。表在环境中有一个唯一的 ID，由三部分组成：目录(catalog)名，数据库(database)名，以及表名。在默认情况下，目录名为 default_catalog，数据库名为 default_database。所以如果我们直接创建一个叫作 MyTable 的表，它的 ID 就是：</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span><span class="number">_</span>catalog.<span class="keyword">default</span><span class="number">_</span>database.MyTable</span><br></pre></td></tr></table></figure>

<p>具体创建表的方式，有通过<strong>连接器</strong>(connector)和<strong>虚拟表</strong>(virtual tables)两种。</p>
<h5 id="连接器表-Connector-Tables"><a href="#连接器表-Connector-Tables" class="headerlink" title="连接器表(Connector Tables)"></a>连接器表(Connector Tables)</h5><p>最直观的创建表的方式，就是通过连接器(connector)连接到一个外部系统，然后定义出对应的表结构。例如我们可以连接到 Kafka 或者文件系统，将存储在这些外部系统的数据以表的形式定义出来，这样对表的读写就可以通过连接器转换成对外部系统的读写了。当我们在表环境中读取这张表，连接器就会从外部系统读取数据并进行转换；而当我们向这张表写入数据，连接器就会将数据输出(Sink)到外部系统中。</p>
<p>在代码中，我们可以调用表环境的 executeSql()方法，可以传入一个 DDL 作为参数执行 SQL 操作。这里我们传入一个 CREATE 语句进行表的创建，并通过 WITH 关键字指定连接到外部系统的连接器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tableEnv.executeSql(<span class="string">&quot;CREATE [TEMPORARY] TABLE MyTable ... WITH ( &#x27;connector&#x27;= ... )&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这里的 TEMPORARY 关键字可以省略。这里没有定义 Catalog 和 Database，所以都是默认的，表的完整 ID 就是default_catalog.default_database.MyTable。如果希望使用自定义的目录名和库名，可以在环境中进行设置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tEnv.useCatalog(<span class="string">&quot;custom_catalog&quot;</span>);</span><br><span class="line">tEnv.useDatabase(<span class="string">&quot;custom_database&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这样我们创建的表完整 ID 就变成了 custom_catalog.custom_database.MyTable。之后在表环境中创建的所有表，ID 也会都以 custom_catalog.custom_database 作为前缀。</p>
<h5 id="虚拟表-Virtual-Tables"><a href="#虚拟表-Virtual-Tables" class="headerlink" title="虚拟表(Virtual Tables)"></a>虚拟表(Virtual Tables)</h5><p>在环境中注册之后，我们就可以在 SQL 中直接使用这张表进行查询转换了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Table newTable = tableEnv.sqlQuery(<span class="string">&quot;SELECT ... FROM MyTable... &quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这里调用了表环境的 sqlQuery()方法，直接传入一条 SQL 语句作为参数执行查询，得到的结果是一个 Table 对象。Table 是 Table API 中提供的核心接口类，就代表了一个 Java 中定义的表实例。得到的 newTable 是一个中间转换结果，如果之后又希望直接使用这个表执行 SQL，又该怎么做呢？</p>
<p>由于 newTable 是一个 Table 对象，并没有在表环境中注册；所以我们还需要将这个中间结果表注册到环境中，才能在 SQL 中使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tableEnv.createTemporaryView(<span class="string">&quot;NewTable&quot;</span>, newTable);</span><br></pre></td></tr></table></figure>

<p>我们发现，这里的注册其实是创建了一个虚拟表(Virtual Table)。这个概念与 SQL 语法中的视图(View)非常类似，所以调用的方法也叫作创建虚拟视图(createTemporaryView)。 视图之所以是虚拟的，是因为我们并不会直接保存这个表的内容，并没有实体；只是在用到这张表的时候，会将它对应的查询语句嵌入到 SQL 中。</p>
<p>注册为虚拟表之后，我们就又可以在 SQL 中直接使用 NewTable 进行查询转换了。不难看到，通过虚拟表可以非常方便地让 SQL 分步骤执行得到中间结果，这为代码编写提供了很大的便利。另外，虚拟表也可以让我们在 Table API 和 SQL 之间进行自由切换。一个 Java 中的 Table 对象可以直接调用 Table API 中定义好的查询转换方法，得到一个中间结果表；这跟对注册好的表直接执行 SQL 结果是一样的。</p>
<h4 id="表的查询"><a href="#表的查询" class="headerlink" title="表的查询"></a>表的查询</h4><p>创建好了表，接下来自然就是对表进行查询转换了。对一个表的查询(Query)操作，就对应着流数据的转换(Transform)处理。</p>
<p>Flink 为我们提供了两种查询方式：SQL 和 Table API。</p>
<h5 id="执行-SQL-进行查询"><a href="#执行-SQL-进行查询" class="headerlink" title="执行 SQL 进行查询"></a>执行 SQL 进行查询</h5><p>调用表环境的 sqlQuery()方法，传入一个字符串形式的 SQL 查询语句就可以了。执行得到的结果，是一个 Table 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建表环境</span></span><br><span class="line">TableEnvironment tableEnv = ...;</span><br><span class="line"><span class="comment">//创建表</span></span><br><span class="line">tableEnv.executeSql(<span class="string">&quot;CREATE TABLE EventTable ... WITH ( &#x27;connector&#x27; = ... )&quot;</span>);</span><br><span class="line"><span class="comment">//查询用户Alice的点击事件，并提取表中前两个字段 </span></span><br><span class="line">Table aliceVisitTable = tableEnv.sqlQuery(</span><br><span class="line">   <span class="string">&quot;SELECT user, url &quot;</span> +</span><br><span class="line">   <span class="string">&quot;FROM EventTable &quot;</span> +</span><br><span class="line">   <span class="string">&quot;WHERE user = &#x27;Alice&#x27; &quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>前 Flink 支持标准 SQL 中的绝大部分用法，并提供了丰富的计算函数。这样我们就可以把已有的技术迁移过来，像在 MySQL、Hive 中那样直接通过编写 SQL 实现自己的处理需求，从而大大降低了 Flink 上手的难度。</p>
<p>例如，我们也可以通过 GROUP BY 关键字定义分组聚合，调用 COUNT()、SUM()这样的函数来进行统计计算：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Table urlCountTable = tableEnv.sqlQuery(</span><br><span class="line">   <span class="string">&quot;SELECT user, COUNT(url) &quot;</span> +</span><br><span class="line">   <span class="string">&quot;FROM EventTable &quot;</span> +</span><br><span class="line">   <span class="string">&quot;GROUP BY user &quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面的例子得到的是一个新的 Table 对象，我们可以再次将它注册为虚拟表继续在 SQL 中调用。另外，我们也可以直接将查询的结果写入到已经注册的表中，这需要调用表环境的 executeSql() 方法来执行 DDL，传入的是一个 INSERT 语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册表</span></span><br><span class="line">tableEnv.executeSql(<span class="string">&quot;CREATE TABLE EventTable ... WITH ( &#x27;connector&#x27; = ... )&quot;</span>);</span><br><span class="line">tableEnv.executeSql(<span class="string">&quot;CREATE TABLE OutputTable ... WITH ( &#x27;connector&#x27; = ... )&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将查询结果输出到OutputTable中 </span></span><br><span class="line">tableEnv.executeSql (</span><br><span class="line"><span class="string">&quot;INSERT INTO OutputTable &quot;</span> +</span><br><span class="line">   <span class="string">&quot;SELECT user, url &quot;</span> +</span><br><span class="line">   <span class="string">&quot;FROM EventTable &quot;</span> +</span><br><span class="line">   <span class="string">&quot;WHERE user = &#x27;Alice&#x27; &quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h5 id="调用-Table-API-进行查询"><a href="#调用-Table-API-进行查询" class="headerlink" title="调用 Table API 进行查询"></a>调用 Table API 进行查询</h5><p>另外一种查询方式就是调用Table API。这是嵌入在Java和Scala语言内的查询API，核心就是 Table 接口类，通过一步步链式调用 Table 的方法，就可以定义出所有的查询转换操作。 每一步方法调用的返回结果，都是一个 Table。</p>
<p>由于 Table API 是基于 Table 的 Java 实例进行调用的，因此我们首先要得到表的 Java 对象。 基于环境中已注册的表，可以通过表环境的 from() 方法非常容易地得到一个 Table 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Table eventTable = tableEnv.from(<span class="string">&quot;EventTable&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>传入的参数就是注册好的表名。注意这里 <strong>eventTable 是一个 Table 对象</strong>，而 <strong>EventTable 是在环境中注册的表名</strong>。得到 Table 对象之后，就可以调用 API 进行各种转换操作了，得到的是一个新的 Table 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Table maryClickTable = eventTable</span><br><span class="line">       .where($(<span class="string">&quot;user&quot;</span>).isEqual(<span class="string">&quot;Alice&quot;</span>))</span><br><span class="line">       .select($(<span class="string">&quot;url&quot;</span>), $(<span class="string">&quot;user&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>这里每个方法的参数都是一个表达式(Expression)，用方法调用的形式直观地说明了想要表达的内容；$符号用来指定表中的一个字段。上面的代码和直接执行 SQL 是等效的。 Table API 是嵌入编程语言中的 DSL，SQL 中的很多特性和功能必须要有对应的实现才可以使用，因此跟直接写 SQL 比起来肯定就要麻烦一些。目前 Table API 支持的功能相对更少， 可以预见未来 Flink 社区也会以扩展 SQL 为主，为大家提供更加通用的接口方式。</p>
<h5 id="两种-API-的结合使用"><a href="#两种-API-的结合使用" class="headerlink" title="两种 API 的结合使用"></a>两种 API 的结合使用</h5><p>可以发现，无论是调用 Table API 还是执行 SQL，得到的结果都是一个 Table 对象；所以这两种 API 的查询可以很方便地结合在一起。</p>
<p>(1)无论是那种方式得到的 Table 对象，都可以继续调用 Table API 进行查询转换</p>
<p>(2)如果想要对一个表执行 SQL 操作(用 FROM 关键字引用)，必须先在环境中对它进行注册。所以我们可以通过创建虚拟表的方式实现两者的转换</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tableEnv.createTemporaryView(<span class="string">&quot;MyTable&quot;</span>, myTable);</span><br></pre></td></tr></table></figure>

<p>注意：这里的<strong>第一个参数MyTable是注册的表名</strong>，而<strong>第二个参数myTable是Java中的Table对象</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Table clickTable = tableEnvironment.sqlQuery(<span class="string">&quot;select url, user from &quot;</span> + eventTable);</span><br></pre></td></tr></table></figure>

<p>这其实是一种简略的写法，我们将 Table 对象名 eventTable 直接以字符串拼接的形式添加到 SQL 语句中，在解析时会自动注册一个同名的虚拟表到环境中，这样就省略了创建虚拟视图的步骤。</p>
<h4 id="输出表"><a href="#输出表" class="headerlink" title="输出表"></a>输出表</h4><p>表的创建和查询，就对应着流处理中的读取数据源(Source)和转换(Transform)；而最后一个步骤 Sink，也就是将结果数据输出到外部系统，就对应着表的输出操作。</p>
<p>在代码上，输出一张表最直接的方法，就是调用 Table 的方法 executeInsert() 方法将一个 Table 写入到注册过的表中，方法传入的参数就是注册的表名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册表，用于输出数据到外部系统</span></span><br><span class="line">tableEnv.executeSql(<span class="string">&quot;CREATE TABLE OutputTable ... WITH ( &#x27;connector&#x27; = ... )&quot;</span>);</span><br><span class="line"><span class="comment">//经过查询转换，得到结果表</span></span><br><span class="line">Table result = ...</span><br><span class="line"><span class="comment">//将结果表写入已注册的输出表中 </span></span><br><span class="line">result.executeInsert(<span class="string">&quot;OutputTable&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在底层，表的输出是通过将数据写入到 TableSink 来实现的。TableSink 是 Table API 中提供的一个向外部系统写入数据的通用接口，可以支持不同的文件格式(比如 CSV、Parquet)、 存储数据库(比如 JDBC、HBase、Elasticsearch)和消息队列(比如 Kafka)。它有些类似于 DataStream API 中调用 addSink()方法时传入的 SinkFunction，有不同的连接器对它进行了实现。 </p>
<p>这里可以发现，我们在环境中注册的表，其实在写入数据的时候就对应着一个 TableSink。</p>
<h4 id="表和流的转换"><a href="#表和流的转换" class="headerlink" title="表和流的转换"></a>表和流的转换</h4><p>创建表环境开始，历经表的创建、查询转换和输出，我们已经可以使用 Table API 和 SQL 进行完整的流处理了。不过在应用的开发过程中，我们测试业务逻辑一般不会将结果直接写入到外部系统，而是在本地控制台打印输出。对于 DataStream 这非常容易，直接调用 print() 方法就可以看到结果数据流的内容了；但对于 Table 就比较悲剧——它没有提供 print() 方法。 这该怎么办呢？</p>
<p>在 Flink 中我们可以将 Table 再转换成 DataStream，然后进行打印输出。这就涉及了表和流的转换。</p>
<h5 id="将表-Table-转换成流-DataStream"><a href="#将表-Table-转换成流-DataStream" class="headerlink" title="将表(Table)转换成流(DataStream)"></a>将表(Table)转换成流(DataStream)</h5><p><strong>(1)调用 toDataStream() 方法</strong></p>
<p>将一个 Table 对象转换成 DataStream 非常简单，只要直接调用表环境的方法 toDataStream() 就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Table aliceVisitTable = tableEnv.sqlQuery(</span><br><span class="line">	<span class="string">&quot;SELECT user, url &quot;</span> +</span><br><span class="line">	<span class="string">&quot;FROM EventTable &quot;</span> +</span><br><span class="line">	<span class="string">&quot;WHERE user = &#x27;Alice&#x27; &quot;</span></span><br><span class="line">  );</span><br><span class="line"><span class="comment">//将表转换成数据流</span></span><br><span class="line">tableEnv.toDataStream(aliceVisitTable).print();</span><br></pre></td></tr></table></figure>

<p><strong>(2)调用 toChangelogStream() 方法</strong></p>
<p>将 maryClickTable 转换成流打印输出是很简单的；然而，如果我们同样希望将用户点击次数统计表 urlCountTable 进行打印输出，就会抛出一个 TableException 异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> org.apache.flink.table.api.TableException: Table sink <span class="string">&#x27;default_catalog.default_database.Unregistered_DataStream_Sink_1&#x27;</span> doesn<span class="string">&#x27;t support consuming update changes ...</span></span><br></pre></td></tr></table></figure>

<p>这表示当前的 TableSink 并不支持表的更新(update)操作。这是什么意思呢？因为 print 本身也可以看作一个 Sink 操作，所以这个异常就是说打印输出的 Sink 操作不支持对数据进行更新。具体来说，urlCountTable 这个表中进行了<strong>分组聚合统计</strong>，所以表中的每一行是会<strong>更新</strong>的。也就是说，Alice的第一个点击事件到来，表中会有一行(Alice, 1)；第二个点击事件到来，这一行就要更新为(Alice, 2)。但之前的(Alice, 1)已经打印输出了，我们怎么能对它进行更改呢？所以就会抛出异常。</p>
<p>解决的思路是，对于这样有更新操作的表，我们不要试图直接把它转换成 DataStream 打印输出，而是记录一下它的更新日志(change log)。这样一来，对于表的所有更新操作， 就变成了一条更新日志的流，我们就可以转换成流打印输出了。</p>
<p>代码中需要调用的是表环境的 toChangelogStream()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Table urlCountTable = tableEnv.sqlQuery(</span><br><span class="line">   <span class="string">&quot;SELECT user, COUNT(url) &quot;</span> +</span><br><span class="line">   <span class="string">&quot;FROM EventTable &quot;</span> +</span><br><span class="line">   <span class="string">&quot;GROUP BY user &quot;</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//将表转换成更新日志流</span></span><br><span class="line">tableEnv.toChangelogStream(urlCountTable).print();</span><br></pre></td></tr></table></figure>

<p>与更新日志流(Changelog Streams)对应的，是那些只做了简单转换、没有进行聚合统计的表，例如前面提到的maryClickTable。它们的特点是数据只会插入、不会更新，所以也被叫作仅插入流(Insert-Only Streams)。</p>
<h5 id="将流-DataStream-转换成表-Table"><a href="#将流-DataStream-转换成表-Table" class="headerlink" title="将流(DataStream)转换成表(Table)"></a>将流(DataStream)转换成表(Table)</h5><p><strong>(1)调用 fromDataStream()方法</strong></p>
<p>想要将一个DataStream转换成表也很简单，可以通过调用表环境的fromDataStream()方法来实现，返回的就是一个Table对象。例如，我们可以直接将事件流 eventStream 转换成一个表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"><span class="comment">// 获取表环境</span></span><br><span class="line">StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env);</span><br><span class="line"><span class="comment">// 读取数据源</span></span><br><span class="line">SingleOutputStreamOperator&lt;Event&gt; eventStream = env.addSource(...)</span><br><span class="line"><span class="comment">// 将数据流转换成表</span></span><br><span class="line">Table eventTable = tableEnv.fromDataStream(eventStream);</span><br></pre></td></tr></table></figure>

<p>由于流中的数据本身就是定义好的 POJO 类型 Event，所以我们将流转换成表之后，每一行数据就对应着一个 Event，而表中的列名就对应着 Event 中的属性。另外，我们还可以在 fromDataStream() 方法中增加参数，用来指定提取哪些属性作为表中的字段名，并可以任意指定位置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提取 Event 中的 timestamp 和 url 作为表中的列</span></span><br><span class="line">Table eventTable2 = tableEnv.fromDataStream(eventStream, $(<span class="string">&quot;timestamp&quot;</span>), $(<span class="string">&quot;url&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>需要注意的是，timestamp 本身是 SQL 中的关键字，所以我们在定义表名、列名时要尽量避免。这时可以通过表达式的 <strong>as()</strong> 方法对字段进行重命名：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 timestamp 字段重命名为 ts</span></span><br><span class="line">Table eventTable2 = tableEnv.fromDataStream(eventStream, $(<span class="string">&quot;timestamp&quot;</span>).as(<span class="string">&quot;ts&quot;</span>), $(<span class="string">&quot;url&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><strong>(2)调用 createTemporaryView()方法</strong></p>
<p>调用 fromDataStream() 方法简单直观，可以直接实现 DataStream 到 Table 的转换；不过如果我们希望直接在 SQL 中引用这张表，就还需要调用表环境的 createTemporaryView() 方法来创建虚拟视图了。</p>
<p>对于这种场景，也有一种更简洁的调用方式。我们可以直接调用 createTemporaryView() 方法创建虚拟表，传入的两个参数，第一个依然是注册的表名，而第二个可以直接就是 DataStream。之后仍旧可以传入多个参数，用来指定表中的字段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tableEnv.createTemporaryView(<span class="string">&quot;EventTable&quot;</span>, eventStream,$(<span class="string">&quot;timestamp&quot;</span>).as(<span class="string">&quot;ts&quot;</span>),$(<span class="string">&quot;url&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><strong>(3)调用 fromChangelogStream ()方法</strong></p>
<p>表环境还提供了一个方法 fromChangelogStream()，可以将一个更新日志流转换成表。这个方法要求流中的数据类型只能是 Row，而且每一个数据都需要指定当前行的更新类型 (RowKind)；所以一般是由连接器帮我们实现的，直接应用比较少见。</p>
<h5 id="支持的数据类型"><a href="#支持的数据类型" class="headerlink" title="支持的数据类型"></a>支持的数据类型</h5><p>整体来看，DataStream 中支持的数据类型，Table 中也是都支持的，只不过在进行转换时需要注意一些细节。</p>
<p><strong>(1)原子类型</strong></p>
<p>在 Flink 中，基础数据类型(Integer、Double、String)和通用数据类型(也就是不可再拆分的数据类型)统一称作原子类型。原子类型的 DataStream，转换之后就成了<strong>只有一列</strong>的 Table，列字段(field)的数据类型可以由原子类型推断出。另外，还可以在 fromDataStream() 方法里增加参数，用来重新命名列字段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StreamTableEnvironment tableEnv = ...;</span><br><span class="line">DataStream&lt;Long&gt; stream = ...;</span><br><span class="line"><span class="comment">// 将数据流转换成动态表，动态表只有一个字段，重命名为 myLong</span></span><br><span class="line">Table table = tableEnv.fromDataStream(stream, $(<span class="string">&quot;myLong&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><strong>(2)Tuple 类型</strong></p>
<p>当原子类型不做重命名时，默认的字段名就是f0，容易想到，这其实就是将原子类型看作了一元组 Tuple1 的处理结果。Table 支持 Flink 中定义的元组类型 Tuple，对应在表中字段名默认就是元组中元素的属性名 f0、f1、f2…。所有字段都可以被重新排序，也可以提取其中的一部分字段。字段还可以通过调用表达式的 as() 方法来进行重命名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">StreamTableEnvironment tableEnv = ...;</span><br><span class="line">DataStream&lt;Tuple2&lt;Long, Integer&gt;&gt; stream = ...;</span><br><span class="line"><span class="comment">// 将数据流转换成只包含 f1 字段的表</span></span><br><span class="line">Table table = tableEnv.fromDataStream(stream, $(<span class="string">&quot;f1&quot;</span>));</span><br><span class="line"><span class="comment">// 将数据流转换成包含 f0 和 f1 字段的表，在表中 f0 和 f1 位置交换</span></span><br><span class="line">Table table = tableEnv.fromDataStream(stream, $(<span class="string">&quot;f1&quot;</span>), $(<span class="string">&quot;f0&quot;</span>));</span><br><span class="line"><span class="comment">// 将 f1 字段命名为 myInt，f0 命名为 myLong</span></span><br><span class="line">Table table = tableEnv.fromDataStream(stream, $(<span class="string">&quot;f1&quot;</span>).as(<span class="string">&quot;myInt&quot;</span>), $(<span class="string">&quot;f0&quot;</span>).as(<span class="string">&quot;myLong&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><strong>(3)POJO 类型</strong></p>
<p>Flink 也支持多种数据类型组合成的复合类型，最典型的就是简单 Java 对象(POJO 类型)。由于 POJO 中已经定义好了可读性强的字段名，这种类型的数据流转换成 Table 就显得无比顺畅了。将 POJO 类型的 DataStream 转换成 Table，如果不指定字段名称，就会直接使用原始 POJO 类型中的字段名称。POJO 中的字段同样可以被重新排序、提却和重命名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">StreamTableEnvironment tableEnv = ...;</span><br><span class="line">DataStream&lt;Event&gt; stream = ...;</span><br><span class="line">Table table = tableEnv.fromDataStream(stream);</span><br><span class="line">Table table = tableEnv.fromDataStream(stream,$(<span class="string">&quot;user&quot;</span>));</span><br><span class="line">Table table = tableEnv.fromDataStream(stream,$(<span class="string">&quot;user&quot;</span>).as(<span class="string">&quot;myUser&quot;</span>),$(<span class="string">&quot;url&quot;</span>).as(<span class="string">&quot;myUrl&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><strong>(4)Row 类型</strong></p>
<p>Flink 中还定义了一个在关系型表中更加通用的数据类型——行(Row)，它是 Table 中数据的基本组织形式。Row 类型也是一种复合类型，它的长度固定，而且无法直接推断出每个字段的类型，所以在使用时必须指明具体的类型信息；我们在创建 Table 时调用的 CREATE 语句就会将所有的字段名称和类型指定，这在 Flink 中被称为表的模式结构(Schema)。除此之外，Row 类型还附加了一个属性 RowKind，用来表示当前行在更新操作中的类型。这样， Row 就可以用来表示更新日志流(changelog stream)中的数据，从而架起了 Flink 中流和表的转换桥梁。所以在更新日志流中，元素的类型必须是 Row，而且需要调用 ofKind() 方法来指定更新类型。下面是一个具体的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;Row&gt; dataStream = env.fromElements(</span><br><span class="line">                    Row.ofKind(RowKind.INSERT, <span class="string">&quot;Alice&quot;</span>, <span class="number">12</span>),</span><br><span class="line">                    Row.ofKind(RowKind.INSERT, <span class="string">&quot;Bob&quot;</span>, <span class="number">5</span>),</span><br><span class="line">                    Row.ofKind(RowKind.UPDATE_BEFORE, <span class="string">&quot;Alice&quot;</span>, <span class="number">12</span>),</span><br><span class="line">                    Row.ofKind(RowKind.UPDATE_AFTER, <span class="string">&quot;Alice&quot;</span>, <span class="number">100</span>)</span><br><span class="line">                );</span><br><span class="line"><span class="comment">// 将更新日志流转换为表</span></span><br><span class="line">Table table = tableEnv.fromChangelogStream(dataStream);</span><br></pre></td></tr></table></figure>

<h5 id="综合应用示例"><a href="#综合应用示例" class="headerlink" title="综合应用示例"></a>综合应用示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 获取流环境</span></span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取数据源</span></span><br><span class="line">    SingleOutputStreamOperator&lt;Event&gt; eventStream = env</span><br><span class="line">            .fromElements(</span><br><span class="line">                    <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">                    <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./cart&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">                    <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod?id=1&quot;</span>, <span class="number">5</span> * <span class="number">1000L</span>),</span><br><span class="line">                    <span class="keyword">new</span> Event(<span class="string">&quot;Cary&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">60</span> * <span class="number">1000L</span>),</span><br><span class="line">                    <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./prod?id=3&quot;</span>, <span class="number">90</span> * <span class="number">1000L</span>),</span><br><span class="line">                    <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod?id=7&quot;</span>, <span class="number">105</span> * <span class="number">1000L</span>)</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取表环境</span></span><br><span class="line">    StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数据流转换成表</span></span><br><span class="line">    tableEnv.createTemporaryView(<span class="string">&quot;EventTable&quot;</span>, eventStream);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询Alice的访问url列表</span></span><br><span class="line">    Table aliceVisitTable = tableEnv.sqlQuery(<span class="string">&quot;SELECT url, user FROM EventTable WHERE user = &#x27;Alice&#x27;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计每个用户的点击次数</span></span><br><span class="line">    Table urlCountTable = tableEnv.sqlQuery(<span class="string">&quot;SELECT user, COUNT(url) FROM EventTable GROUP BY user&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将表转换成数据流，在控制台打印输出</span></span><br><span class="line">    tableEnv.toDataStream(aliceVisitTable).print(<span class="string">&quot;alice visit&quot;</span>);</span><br><span class="line">    tableEnv.toChangelogStream(urlCountTable).print(<span class="string">&quot;count&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行程序</span></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="流处理中的表"><a href="#流处理中的表" class="headerlink" title="流处理中的表"></a>流处理中的表</h3><p>当我们将一个 Table 转换成 DataStream 时，有仅插入流(Insert-Only Streams)和更新日志流(Changelog Streams) 两种不同的方式，具体使用哪种方式取决于表中是否存在更新(update)操作。</p>
<p>这种麻烦其实是不可避免的。我们知道，Table API 和 SQL 本质上都是基于关系型表的操作方式；而关系型表(Table)本身是有界的，更适合批处理的场景。所以在 MySQL、Hive 这样的固定数据集中进行查询，使用 SQL 就会显得得心应手。而对于 Flink 这样的流处理框架来说，要处理的是源源不断到来的无界数据流，我们无法等到数据都到齐再做查询，每来一条数据就应该更新一次结果；这时如果一定要使用表和 SQL 进行处理，就会显得有些别扭了，需要引入一些特殊的概念。</p>
<h4 id="动态表和持续查询"><a href="#动态表和持续查询" class="headerlink" title="动态表和持续查询"></a>动态表和持续查询</h4><p>流处理面对的数据是连续不断的，这导致了流处理中的表跟我们熟悉的关系型数据库中的表完全不同；而基于表执行的查询操作，也就有了新的含义。</p>
<p>如果我们希望把流数据转换成表的形式，那么这<strong>表中的数据就会不断增长</strong>；如果进一步基于表执行 SQL 查询，那么得到的结果就不是一成不变的，而是会随着新数据的到来持续更新。</p>
<p><strong>动态表(Dynamic Tables)</strong></p>
<p>当流中有新数据到来，初始的表中会插入一行；而基于这个表定义的 SQL 查询，就应该在之前的基础上更新结果。这样得到的表就会不断地动态变化，被称为动态表(Dynamic Tables)。动态表是 Flink 在 Table API 和 SQL 中的核心概念，它为流数据处理提供了表和 SQL 支持。 我们所熟悉的表一般用来做批处理，面向的是固定的数据集，可以认为是静态表；而动态表则完全不同，它里面的数据会随时间变化。</p>
<p>其实动态表的概念，我们在传统的关系型数据库中已经有所接触。数据库中的表，其实是一系列 INSERT、UPDATE 和 DELETE 语句执行的结果；在关系型数据库中，我们一般把它称为更新日志流(changelog stream)。如果我们保存了表在某一时刻的快照(snapshot)，那么接下来只要读取更新日志流，就可以得到表之后的变化过程和最终结果了。在很多高级关系型数据库(比如 Oracle、DB2)中都有物化视图(Materialized Views)的概念，可以用来缓存 SQL 查询的结果；它的更新其实就是不停地处理更新日志流的过程。</p>
<p><strong>持续查询(Continuous Query)</strong></p>
<p>动态表可以像静态的批处理表一样进行查询操作。由于数据在不断变化，因此基于它定义的 SQL 查询也不可能执行一次就得到最终结果。这样一来，我们对动态表的查询也就永远不会停止，一直在随着新数据的到来而继续执行。这样的查询就被称作持续查询(Continuous Query)。对动态表定义的查询操作，都是持续查询；而持续查询的结果也会是一个动态表。</p>
<p>由于每次数据到来都会触发查询操作，因此可以认为一次查询面对的数据集，就是当前输入动态表中收到的所有数据。这相当于是对输入动态表做了一个快照(snapshot)，当作有限数据集进行批处理；流式数据的到来会触发连续不断的快照查询，像动画一样连贯起来，就构成了持续查询。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-07-18%20%E4%B8%8B%E5%8D%885.10.28.png" alt="截屏2022-07-18 下午5.10.28"></p>
<p>持续查询的步骤如下：</p>
<p>(1)流(stream)被转换为动态表(dynamic table)；</p>
<p>(2)对动态表进行持续查询(continuous query)，生成新的动态表；</p>
<p>(3)生成的动态表被转换成流。</p>
<p>这样，只要 API 将流和动态表的转换封装起来，我们就可以直接在数据流上执行 SQL 查询，用处理表的方式来做流处理了。</p>
<h4 id="用-SQL-持续查询"><a href="#用-SQL-持续查询" class="headerlink" title="用 SQL 持续查询"></a>用 SQL 持续查询</h4><h5 id="更新-Update-查询"><a href="#更新-Update-查询" class="headerlink" title="更新(Update)查询"></a>更新(Update)查询</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分组聚合统计每个用户的点击次数</span></span><br><span class="line"><span class="comment">//结果表的更新日志(changelog) 流中，包含了 INSERT 和 UPDATE 两种操作</span></span><br><span class="line">Table urlCountTable = tableEnv.sqlQuery(<span class="string">&quot;SELECT user, COUNT(url) as cnt FROM EventTable GROUP BY user&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="追加-Append-查询"><a href="#追加-Append-查询" class="headerlink" title="追加(Append)查询"></a>追加(Append)查询</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结果表的更新日志 (changelog)流中只有 INSERT 操作</span></span><br><span class="line">Table aliceVisitTable = tableEnv.sqlQuery(<span class="string">&quot;SELECT url, user FROM EventTable WHERE user = &#x27;Cary&#x27;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>我们似乎可以总结一个规律：只要用到了聚合，在之前的结果上有叠加，就会产生更新操作，就是一个更新查询。但事实上，更新查询的判断标准是结果表中的数据是否会有 UPDATE 操作，如果聚合的结果不再改变，那么同样也不是更新查询。</p>
<p>什么时候聚合的结果会保持不变呢？一个典型的例子就是窗口聚合。</p>
<p>我们考虑开一个滚动窗口，统计每一小时内所有用户的点击次数，并在结果表中增加一个 endT 字段，表示当前统计窗口的结束时间。这时结果表的字段定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">user: VARCHAR, <span class="comment">// 用户名</span></span><br><span class="line">endT: TIMESTAMP, <span class="comment">// 窗口结束时间 </span></span><br><span class="line">cnt: BIGINT <span class="comment">// 用户访问 url 的次数</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-07-18%20%E4%B8%8B%E5%8D%888.23.04.png" alt="截屏2022-07-18 下午8.23.04"></p>
<p>由于窗口的统计结果是一次性写入结果表的，所以结果表的更新日志流中只会包含插入 INSERT 操作，而没有更新 UPDATE 操作。所以这里的持续查询，依然是一个追加(Append)查询。结果表 result 如果转换成 DataStream，可以直接调用 toDataStream()方 法。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+<span class="selector-tag">I</span><span class="selector-attr">[Alice, 1970-01-01T01:00, 3]</span></span><br><span class="line">+<span class="selector-tag">I</span><span class="selector-attr">[Bob, 1970-01-01T01:00, 1]</span></span><br><span class="line">+<span class="selector-tag">I</span><span class="selector-attr">[Cary, 1970-01-01T02:00, 2]</span></span><br><span class="line">+<span class="selector-tag">I</span><span class="selector-attr">[Bob, 1970-01-01T02:00, 1]</span></span><br></pre></td></tr></table></figure>

<h5 id="查询限制"><a href="#查询限制" class="headerlink" title="查询限制"></a>查询限制</h5><p>在实际应用中，有些持续查询会因为计算代价太高而受到限制。所谓的代价太高，可能是由于需要维护的状态持续增长，也可能是由于更新数据的计算太复杂。</p>
<p><strong>状态大小</strong></p>
<p>用持续查询做流处理，往往会运行至少几周到几个月；所以持续查询处理的数据总量可能非常大。例如我们之前举的更新查询的例子，需要记录每个用户访问 url 的次数。如果随着时间的推移用户数越来越大，那么要维护的状态也将逐渐增长，最终可能会耗尽存储空间导致查询失败。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">user</span>, <span class="built_in">COUNT</span>(url)</span><br><span class="line"><span class="keyword">FROM</span> clicks</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<p><strong>更新计算</strong></p>
<p>于有些查询来说，更新计算的复杂度可能很高。每来一条新的数据，更新结果的时候可能需要全部重新计算，并且对很多已经输出的行进行更新。一个典型的例子就是 RANK() 函数， 它会基于一组数据计算当前值的排名。例如下面的 SQL 查询，会根据用户最后一次点击的时间为每个用户计算一个排名。当我们收到一个新的数据，用户的最后一次点击时间(lastAction)就会更新，进而所有用户必须重新排序计算一个新的排名。当一个用户的排名发生改变时，被他超过的那些用户的排名也会改变；这样的更新操作无疑代价巨大，而且还会随着用户的增多越来越严重。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">user</span>, <span class="built_in">RANK</span>() <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> lastAction)</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="keyword">user</span>, <span class="built_in">MAX</span>(ts) <span class="keyword">AS</span> lastAction <span class="keyword">FROM</span> EventTable <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">user</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="时间属性和窗口"><a href="#时间属性和窗口" class="headerlink" title="时间属性和窗口"></a>时间属性和窗口</h3><p>基于时间的操作(比如时间窗口)，需要定义相关的时间语义和时间数据来源的信息。在 Table API 和 SQL 中，会给表单独提供一个逻辑上的时间字段，专门用来在表处理程序中指示时间。</p>
<p>所以所谓的时间属性(time attributes)，其实就是每个表模式结构(schema)的一部分。 它可以在创建表的 DDL 里直接定义为一个字段，也可以在 DataStream 转换成表时定义。一旦定义了时间属性，它就可以作为一个普通字段引用，并且可以在基于时间的操作中使用。</p>
<p>时间属性的数据类型为 TIMESTAMP，它的行为类似于常规时间戳，可以直接访问并且进行计算。</p>
<p>按照时间语义的不同，我们可以把时间属性的定义分成事件时间(event time)和处理时间(processing time)两种情况。</p>
<h4 id="事件时间"><a href="#事件时间" class="headerlink" title="事件时间"></a>事件时间</h4><p><strong>在创建表的 DDL 中定义</strong></p>
<p>在创建表的DDL(CREATE TABLE语句)中，可以增加一个字段，通过WATERMARK 语句来定义事件时间属性。WATERMARK 语句主要用来定义水位线(watermark)的生成表达式，这个表达式会将带有事件时间戳的字段标记为事件时间属性，并在它基础上给出水位线的延迟时间。具体定义方式如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> EventTable(</span><br><span class="line">  <span class="keyword">user</span> STRING,</span><br><span class="line">  url STRING,</span><br><span class="line">  ts <span class="type">TIMESTAMP</span>(<span class="number">3</span>),</span><br><span class="line">  WATERMARK <span class="keyword">FOR</span> ts <span class="keyword">AS</span> ts <span class="operator">-</span> <span class="type">INTERVAL</span> <span class="string">&#x27;5&#x27;</span> <span class="keyword">SECOND</span></span><br><span class="line">) <span class="keyword">WITH</span> ( ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这里我们把 ts 字段定义为事件时间属性，而且基于 ts 设置了 5 秒的水位线延迟。这里的 5秒 是以时间间隔的形式定义的，格式是 INTERVAL &lt;数值&gt; &lt;时间单位&gt;：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">INTERVAL</span> <span class="string">&#x27;5&#x27;</span> <span class="keyword">SECOND</span></span><br></pre></td></tr></table></figure>

<p>这里的数值必须用<strong>单引号</strong>引起来，而单位用 SECOND 和 SECONDS 是等效的。</p>
<p>Flink 中支持的事件时间属性数据类型必须为 <strong>TIMESTAMP</strong> 或者 <strong>TIMESTAMP_LTZ</strong>。这里 TIMESTAMP_LTZ 是指带有本地时区信息的时间戳(TIMESTAMP WITH LOCAL TIME ZONE)；一般情况下如果数据中的时间戳是”年-月-日-时-分-秒”的形式，那就是不带时区信息的，可以将事件时间属性定义为 TIMESTAMP 类型。</p>
<p>而如果原始的时间戳就是一个长整型的毫秒数，这时就需要另外定义一个字段来表示事件时间属性，类型定义为 TIMESTAMP_LTZ 会更方便：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> events (</span><br><span class="line">  <span class="keyword">user</span> STRING,</span><br><span class="line">  url STRING,</span><br><span class="line">  ts <span class="type">BIGINT</span>,</span><br><span class="line">  ts_ltz <span class="keyword">AS</span> TO_TIMESTAMP_LTZ(ts, <span class="number">3</span>),</span><br><span class="line">  WATERMARK <span class="keyword">FOR</span> ts_ltz <span class="keyword">AS</span> ts_ltz <span class="operator">-</span> <span class="type">INTERVAL</span> <span class="string">&#x27;5&#x27;</span> <span class="keyword">SECOND</span></span><br><span class="line">) <span class="keyword">WITH</span> (</span><br><span class="line">... );</span><br></pre></td></tr></table></figure>

<p>这里我们另外定义了一个字段 ts_ltz，是把长整型的 ts 转换为 TIMESTAMP_LTZ 得到的；进而使用 WATERMARK 语句将它设为事件时间属性，并设置 5 秒的水位线延迟。</p>
<p><strong>在数据流转换为表时定义</strong></p>
<p>事件时间属性也可以在将 DataStream 转换为表的时候来定义。我们调用 fromDataStream() 方法创建表时，可以追加参数来定义表中的字段结构；这时可以给某个字段加上 .rowtime() 后缀，就表示将当前字段指定为事件时间属性。这个字段可以是数据中本不存在、额外追加上去的逻辑字段，就像之前 DDL 中定义的第二种情况；也可以是本身固有的字段，那么这个字段就会被事件时间属性所覆盖，类型也会被转换为 TIMESTAMP。不论那种方式，时间属性字段中保存的都是事件的时间戳(TIMESTAMP类型)。</p>
<p>需要注意的是，这种方式只负责指定时间属性，而时间戳的提取和水位线的生成应该之前就在 DataStream 上定义好了。由于 DataStream 中没有时区概念，因此 Flink 会将事件时间属性解析成不带时区的 TIMESTAMP 类型，所有的时间值都被当作 UTC 标准时间。</p>
<p>在代码中的定义方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一:</span></span><br><span class="line"><span class="comment">// 流中数据类型为二元组 Tuple2，包含两个字段；需要自定义提取时间戳并生成水位线 </span></span><br><span class="line">DataStream&lt;Tuple2&lt;String, String&gt;&gt; stream = inputStream.assignTimestampsAndWatermarks(...);</span><br><span class="line"><span class="comment">// 声明一个额外的逻辑字段作为事件时间属性</span></span><br><span class="line">Table table = tEnv.fromDataStream(stream, $(<span class="string">&quot;user&quot;</span>), $(<span class="string">&quot;url&quot;</span>), $(<span class="string">&quot;ts&quot;</span>).rowtime());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二:</span></span><br><span class="line"><span class="comment">// 流中数据类型为三元组 Tuple3，最后一个字段就是事件时间戳 </span></span><br><span class="line">DataStream&lt;Tuple3&lt;String, String, Long&gt;&gt; stream = inputStream.assignTimestampsAndWatermarks(...);</span><br><span class="line"><span class="comment">// 不再声明额外字段，直接用最后一个字段作为事件时间属性</span></span><br><span class="line">Table table = tEnv.fromDataStream(stream, $(<span class="string">&quot;user&quot;</span>), $(<span class="string">&quot;url&quot;</span>), $(<span class="string">&quot;ts&quot;</span>).rowtime());</span><br></pre></td></tr></table></figure>

<h4 id="处理时间"><a href="#处理时间" class="headerlink" title="处理时间"></a>处理时间</h4><p>相比之下处理时间就比较简单了，它就是我们的系统时间，使用时不需要提取时间戳 (timestamp)和生成水位线(watermark)。因此在定义处理时间属性时，必须要额外声明一个字段，专门用来保存当前的处理时间。</p>
<p>类似地，处理时间属性的定义也有两种方式：创建表 DDL 中定义，或者在数据流转换成表时定义。</p>
<p><strong>在创建表的 DDL 中定义</strong></p>
<p>在创建表的 DDL(CREATE TABLE 语句)中，可以增加一个额外的字段，通过调用系统内置的 PROCTIME() 函数来指定当前的处理时间属性，返回的类型是 TIMESTAMP_LTZ。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> EventTable(</span><br><span class="line">  <span class="keyword">user</span> STRING,</span><br><span class="line">  url STRING,</span><br><span class="line">  ts <span class="keyword">AS</span> PROCTIME()</span><br><span class="line">) <span class="keyword">WITH</span> ( ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这里的时间属性，其实是以计算列(computed column)的形式定义出来的。所谓的计算列是Flink SQL中引入的特殊概念，可以用一个AS语句来在表中产生数据中不存在的列， 并且可以利用原有的列、各种运算符及内置函数。在前面事件时间属性的定义中，将 ts 字段转换成 TIMESTAMP_LTZ 类型的 ts_ltz，也是计算列的定义方式。</p>
<p><strong>在数据流转换为表时定义</strong></p>
<p>处理时间属性同样可以在将 DataStream 转换为表的时候来定义。我们调用 fromDataStream() 方法创建表时，可以用.proctime()后缀来指定处理时间属性字段。由于处理时间是系统时间，原始数据中并没有这个字段，所以处理时间属性一定不能定义在一个已有字段上，只能定义在表结构<strong>所有字段的最后</strong>，作为额外的逻辑字段出现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;Tuple2&lt;String, String&gt;&gt; stream = ...; </span><br><span class="line"><span class="comment">// 声明一个额外的字段作为处理时间属性字段</span></span><br><span class="line">Table table = tEnv.fromDataStream(stream, $(<span class="string">&quot;user&quot;</span>), $(<span class="string">&quot;url&quot;</span>), $(<span class="string">&quot;ts&quot;</span>).proctime());</span><br></pre></td></tr></table></figure>

<h4 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h4><p>窗口可以将无界流切割成大小有限的桶(bucket)来做计算，通过截取有限数据集来处理无限的流数据。在 DataStream API 中提供了对不同类型的窗口进行定义和处理的接口，而在 Table API 和 SQL 中，类似的功能也都可以实现。</p>
<h5 id="分组窗口-Group-Window，老版本"><a href="#分组窗口-Group-Window，老版本" class="headerlink" title="分组窗口(Group Window，老版本)"></a>分组窗口(Group Window，老版本)</h5><p>在 Flink 1.12 之前的版本中，Table API 和 SQL 提供了一组分组窗口(Group Window) 函数，常用的时间窗口如滚动窗口、滑动窗口、会话窗口都有对应的实现；具体在 SQL 中就是调用 TUMBLE()、HOP()、SESSION()，传入时间属性字段、窗口大小等参数就可以了。以滚动窗口为例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TUMBLE(ts, <span class="type">INTERVAL</span> <span class="string">&#x27;1&#x27;</span> <span class="keyword">HOUR</span>)</span><br></pre></td></tr></table></figure>

<p>这里的 ts 是定义好的时间属性字段，窗口大小用时间间隔 INTERVAL 来定义。</p>
<p>在进行窗口计算时，分组窗口是将窗口本身当作一个字段对数据进行分组的，可以对组内的数据进行聚合。基本使用方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Table result = tableEnv.sqlQuery(</span><br><span class="line">    <span class="string">&quot;SELECT &quot;</span> +</span><br><span class="line">        <span class="string">&quot;user, &quot;</span> +</span><br><span class="line">        <span class="string">&quot;TUMBLE_END(ts, INTERVAL &#x27;1&#x27; HOUR) as endT, &quot;</span> +</span><br><span class="line">        <span class="string">&quot;COUNT(url) AS cnt &quot;</span> +</span><br><span class="line">    <span class="string">&quot;FROM EventTable &quot;</span> +</span><br><span class="line">    <span class="string">&quot;GROUP BY &quot;</span> + <span class="comment">// 使用窗口和用户名进行分组</span></span><br><span class="line">        <span class="string">&quot;user, &quot;</span> +</span><br><span class="line">    <span class="string">&quot;TUMBLE(ts, INTERVAL &#x27;1&#x27; HOUR)&quot;</span> <span class="comment">// 定义 1 小时滚动窗口</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这里定义了 1 小时的滚动窗口，将窗口和用户 user 一起作为分组的字段。用聚合函数 COUNT() 对分组数据的个数进行了聚合统计，并将结果字段重命名为 cnt；用 TUPMBLE_END() 函数获取滚动窗口的结束时间，重命名为 endT 提取出来。</p>
<p>分组窗口的功能比较有限，只支持窗口聚合，所以目前已经处于弃用(deprecated)的状态。</p>
<h5 id="窗口表值函数-Windowing-TVFs，新版本"><a href="#窗口表值函数-Windowing-TVFs，新版本" class="headerlink" title="窗口表值函数(Windowing TVFs，新版本)"></a>窗口表值函数(Windowing TVFs，新版本)</h5><p>从 1.13 版本开始，Flink 开始使用窗口表值函数(Windowing table-valued functions， Windowing TVFs)来定义窗口。窗口表值函数是 Flink 定义的多态表函数(PTF)，可以将表进行扩展后返回。表函数(table function)可以看作是返回一个表的函数。</p>
<p>目前 Flink 提供了以下几个窗口 TVF：</p>
<p><strong>滚动窗口(Tumbling Windows)</strong></p>
<p><strong>滑动窗口(Hop Windows，跳跃窗口)</strong></p>
<p><strong>累积窗口(Cumulate Windows)</strong></p>
<p><strong>会话窗口(Session Windows，目前尚未完全支持)</strong></p>
<p>窗口表值函数可以完全替代传统的分组窗口函数。窗口 TVF 更符合 SQL 标准，性能得到了优化，拥有更强大的功能；可以支持基于窗口的复杂计算，例如窗口 Top-N、窗口联结(window join)等等。当然，目前窗口 TVF 的功能还不完善，会话窗口和很多高级功能还不支持，不过正在快速地更新完善。可以预见在未来的版本中，窗口 TVF 将越来越强大，将会是窗口处理的唯一入口。</p>
<p>在窗口 TVF 的返回值中，除去原始表中的所有列，还增加了用来描述窗口的额外 3 个列：窗口起始点(window_start)、窗口结束点(window_end)、窗口时间(window_time)。 起始点和结束点比较好理解，这里的窗口时间指的是窗口中的时间属性，它的值等于 window_end - 1ms，所以相当于是窗口中能够包含数据的最大时间戳。</p>
<p>在 SQL 中的声明方式，与以前的分组窗口是类似的，直接调用 TUMBLE()、HOP()、 CUMULATE()就可以实现滚动、滑动和累积窗口，不过传入的参数会有所不同。</p>
<p><strong>(1)滚动窗口(TUMBLE)</strong></p>
<p>在 SQL 中通过调用 TUMBLE()函数就可以声明一个滚动窗口，只有一个核心参数就是窗口大小(size)。在 SQL 中不考虑计数窗口，所以滚动窗口就是滚动时间窗口，参数中还需要将当前的时间属性字段传入；另外，窗口 TVF 本质上是表函数，可以对表进行扩展，所以还应该把当前查询的表作为参数整体传入。具体声明如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TUMBLE(TABLE EventTable, DESCRIPTOR(ts), INTERVAL <span class="string">&#x27;1&#x27;</span> HOUR)</span><br></pre></td></tr></table></figure>

<p><strong>(2)滑动窗口(HOP)</strong></p>
<p>滑动窗口的使用与滚动窗口类似，可以通过设置滑动步长来控制统计输出的频率。在 SQL 中通过调用 HOP() 来声明滑动窗口；除了也要传入表名、时间属性外，还需要传入窗口大小(size)和滑动步长(slide)两个参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HOP(TABLE EventTable, DESCRIPTOR(ts), INTERVAL <span class="string">&#x27;5&#x27;</span> MINUTES, INTERVAL <span class="string">&#x27;1&#x27;</span> HOURS));</span><br></pre></td></tr></table></figure>

<p>这里我们基于时间属性 ts，在表 EventTable 上创建了大小为 1 小时的滑动窗口，每 5 分钟滑动一次。需要注意的是，紧跟在时间属性字段后面的第三个参数是步长(slide)，第四个参数才是窗口大小(size)。</p>
<p><strong>(3)累积窗口(CUMULATE)</strong></p>
<p>滚动窗口和滑动窗口，可以用来计算大多数周期性的统计指标。不过在实际应用中还会遇到这样一类需求：我们的统计周期可能较长，因此希望中间每隔一段时间就输出一次当前的统计值；与滑动窗口不同的是，在一个统计周期内，我们会多次输出统计值，它们应该是不断叠加累积的。</p>
<p>例如，我们按天来统计网站的PV(Page View，页面浏览量)，如果用1天的滚动窗口， 那需要到每天 24 点才会计算一次，输出频率太低；如果用滑动窗口，计算频率可以更高，但统计的就变成了”过去 24 小时的 PV”。所以我们真正希望的是，还是按照自然日统计每天的 PV，不过需要每隔 1 小时就输出一次当天到目前为止的 PV 值。这种特殊的窗口就叫作累积窗口(Cumulate Window)。</p>
<p>累积窗口是窗口 TVF 中新增的窗口功能，它会在一定的统计周期内进行累积计算。累积窗口中有两个核心的参数：最大窗口长度(max window size)和累积步长(step)。所谓的<strong>最大窗口长度其实就是我们所说的统计周期</strong>，最终目的就是统计这段时间内的数据。在 SQL 中可以用 CUMULATE() 函数来定义，具体如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CUMULATE(TABLE EventTable, DESCRIPTOR(ts), INTERVAL <span class="string">&#x27;1&#x27;</span> HOURS, INTERVAL <span class="string">&#x27;1&#x27;</span> DAYS))</span><br></pre></td></tr></table></figure>

<p>这里我们基于时间属性 ts，在表 EventTable 上定义了一个统计周期为 1 天、累积步长为 1 小时的累积窗口。注意第三个参数为步长 step，第四个参数则是最大窗口长度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//累计窗口案例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取数据源，并分配时间戳、生成水位线</span></span><br><span class="line">    SingleOutputStreamOperator&lt;Event&gt; eventStream = env</span><br><span class="line">            .fromElements(</span><br><span class="line">                    <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">                    <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./cart&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">                    <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod?id=1&quot;</span>, <span class="number">25</span> * <span class="number">60</span> * <span class="number">1000L</span>),</span><br><span class="line">                    <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod?id=4&quot;</span>, <span class="number">55</span> * <span class="number">60</span> * <span class="number">1000L</span>),</span><br><span class="line">                    <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./prod?id=5&quot;</span>, <span class="number">3600</span> * <span class="number">1000L</span> + <span class="number">60</span> * <span class="number">1000L</span>),</span><br><span class="line">                    <span class="keyword">new</span> Event(<span class="string">&quot;Cary&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">3600</span> * <span class="number">1000L</span> + <span class="number">30</span> * <span class="number">60</span> * <span class="number">1000L</span>),</span><br><span class="line">                    <span class="keyword">new</span> Event(<span class="string">&quot;Cary&quot;</span>, <span class="string">&quot;./prod?id=7&quot;</span>, <span class="number">3600</span> * <span class="number">1000L</span> + <span class="number">59</span> * <span class="number">60</span> * <span class="number">1000L</span>)</span><br><span class="line">            )</span><br><span class="line">            .assignTimestampsAndWatermarks(</span><br><span class="line">                    WatermarkStrategy.&lt;Event&gt;forMonotonousTimestamps()</span><br><span class="line">                            .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Event&gt;() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Event element, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                                    <span class="keyword">return</span> element.timestamp;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;)</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建表环境</span></span><br><span class="line">    StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数据流转换成表，并指定时间属性</span></span><br><span class="line">    Table eventTable = tableEnv.fromDataStream(</span><br><span class="line">            eventStream,</span><br><span class="line">            $(<span class="string">&quot;user&quot;</span>),</span><br><span class="line">            $(<span class="string">&quot;url&quot;</span>),</span><br><span class="line">            $(<span class="string">&quot;timestamp&quot;</span>).rowtime().as(<span class="string">&quot;ts&quot;</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为方便在SQL中引用，在环境中注册表EventTable</span></span><br><span class="line">    tableEnv.createTemporaryView(<span class="string">&quot;EventTable&quot;</span>, eventTable);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置累积窗口，执行SQL统计查询</span></span><br><span class="line">    Table result = tableEnv</span><br><span class="line">            .sqlQuery(</span><br><span class="line">                    <span class="string">&quot;SELECT &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;user, &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;window_end AS endT, &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;COUNT(url) AS cnt &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;FROM TABLE( &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;CUMULATE( TABLE EventTable, &quot;</span> +    <span class="comment">// 定义累积窗口</span></span><br><span class="line">                            <span class="string">&quot;DESCRIPTOR(ts), &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;INTERVAL &#x27;30&#x27; MINUTE, &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;INTERVAL &#x27;1&#x27; HOUR)) &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;GROUP BY user, window_start, window_end &quot;</span></span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    tableEnv.toDataStream(result).print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//窗口案例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 在创建表的DDL中直接定义时间属性</span></span><br><span class="line">    String createDDL = <span class="string">&quot;CREATE TABLE clickTable (&quot;</span> +</span><br><span class="line">            <span class="string">&quot; user_name STRING, &quot;</span> +</span><br><span class="line">            <span class="string">&quot; url STRING, &quot;</span> +</span><br><span class="line">            <span class="string">&quot; ts BIGINT, &quot;</span> +</span><br><span class="line">            <span class="string">&quot; et AS TO_TIMESTAMP( FROM_UNIXTIME(ts / 1000) ), &quot;</span> +</span><br><span class="line">            <span class="string">&quot; WATERMARK FOR et AS et - INTERVAL &#x27;1&#x27; SECOND &quot;</span> +</span><br><span class="line">            <span class="string">&quot;) WITH (&quot;</span> +</span><br><span class="line">            <span class="string">&quot; &#x27;connector&#x27; = &#x27;filesystem&#x27;, &quot;</span> +</span><br><span class="line">            <span class="string">&quot; &#x27;path&#x27; = &#x27;input/clicks.csv&#x27;, &quot;</span> +</span><br><span class="line">            <span class="string">&quot; &#x27;format&#x27; =  &#x27;csv&#x27; &quot;</span> +</span><br><span class="line">            <span class="string">&quot;)&quot;</span>;</span><br><span class="line"></span><br><span class="line">    tableEnv.executeSql(createDDL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 在流转换成Table时定义时间属性</span></span><br><span class="line">    SingleOutputStreamOperator&lt;Event&gt; clickStream = env.addSource(<span class="keyword">new</span> ClickSource())</span><br><span class="line">            .assignTimestampsAndWatermarks(WatermarkStrategy.&lt;Event&gt;forBoundedOutOfOrderness(Duration.ZERO)</span><br><span class="line">                    .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Event&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Event event, <span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> event.timestamp;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;));</span><br><span class="line"></span><br><span class="line">    Table clickTable = tableEnv.fromDataStream(clickStream, $(<span class="string">&quot;user&quot;</span>), $(<span class="string">&quot;url&quot;</span>), $(<span class="string">&quot;timestamp&quot;</span>).as(<span class="string">&quot;ts&quot;</span>),</span><br><span class="line">            $(<span class="string">&quot;et&quot;</span>).rowtime());</span><br><span class="line"></span><br><span class="line">      clickTable.printSchema();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 聚合查询转换</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 分组聚合</span></span><br><span class="line">    Table aggTable = tableEnv.sqlQuery(<span class="string">&quot;SELECT user_name, COUNT(1) FROM clickTable GROUP BY user_name&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 分组窗口聚合</span></span><br><span class="line">    Table groupWindowResultTable = tableEnv.sqlQuery(<span class="string">&quot;SELECT &quot;</span> +</span><br><span class="line">            <span class="string">&quot;user_name, &quot;</span> +</span><br><span class="line">            <span class="string">&quot;COUNT(1) AS cnt, &quot;</span> +</span><br><span class="line">            <span class="string">&quot;TUMBLE_END(et, INTERVAL &#x27;10&#x27; SECOND) as endT &quot;</span> +</span><br><span class="line">            <span class="string">&quot;FROM clickTable &quot;</span> +</span><br><span class="line">            <span class="string">&quot;GROUP BY &quot;</span> +                     <span class="comment">// 使用窗口和用户名进行分组</span></span><br><span class="line">            <span class="string">&quot;  user_name, &quot;</span> +</span><br><span class="line">            <span class="string">&quot;  TUMBLE(et, INTERVAL &#x27;10&#x27; SECOND)&quot;</span> <span class="comment">// 定义1小时滚动窗口</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 窗口聚合</span></span><br><span class="line">    <span class="comment">// 3.1 滚动窗口</span></span><br><span class="line">    Table tumbleWindowResultTable = tableEnv.sqlQuery(<span class="string">&quot;SELECT user_name, COUNT(url) AS cnt, &quot;</span> +</span><br><span class="line">            <span class="string">&quot; window_end AS endT &quot;</span> +</span><br><span class="line">            <span class="string">&quot;FROM TABLE( &quot;</span> +</span><br><span class="line">            <span class="string">&quot;  TUMBLE( TABLE clickTable, DESCRIPTOR(et), INTERVAL &#x27;10&#x27; SECOND)&quot;</span> +</span><br><span class="line">            <span class="string">&quot;) &quot;</span> +</span><br><span class="line">            <span class="string">&quot;GROUP BY user_name, window_start, window_end &quot;</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.2 滑动窗口</span></span><br><span class="line">    Table hopWindowResultTable = tableEnv.sqlQuery(<span class="string">&quot;SELECT user_name, COUNT(url) AS cnt, &quot;</span> +</span><br><span class="line">            <span class="string">&quot; window_end AS endT &quot;</span> +</span><br><span class="line">            <span class="string">&quot;FROM TABLE( &quot;</span> +</span><br><span class="line">            <span class="string">&quot;  HOP( TABLE clickTable, DESCRIPTOR(et), INTERVAL &#x27;5&#x27; SECOND, INTERVAL &#x27;10&#x27; SECOND)&quot;</span> +</span><br><span class="line">            <span class="string">&quot;) &quot;</span> +</span><br><span class="line">            <span class="string">&quot;GROUP BY user_name, window_start, window_end &quot;</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.3 累积窗口</span></span><br><span class="line">    Table cumulateWindowResultTable = tableEnv.sqlQuery(<span class="string">&quot;SELECT user_name, COUNT(url) AS cnt, &quot;</span> +</span><br><span class="line">            <span class="string">&quot; window_end AS endT &quot;</span> +</span><br><span class="line">            <span class="string">&quot;FROM TABLE( &quot;</span> +</span><br><span class="line">            <span class="string">&quot;  CUMULATE( TABLE clickTable, DESCRIPTOR(et), INTERVAL &#x27;5&#x27; SECOND, INTERVAL &#x27;10&#x27; SECOND)&quot;</span> +</span><br><span class="line">            <span class="string">&quot;) &quot;</span> +</span><br><span class="line">            <span class="string">&quot;GROUP BY user_name, window_start, window_end &quot;</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 开窗聚合</span></span><br><span class="line">    Table overWindowResultTable = tableEnv.sqlQuery(<span class="string">&quot;SELECT user_name, &quot;</span> +</span><br><span class="line">            <span class="string">&quot; avg(ts) OVER (&quot;</span> +</span><br><span class="line">            <span class="string">&quot;   PARTITION BY user_name &quot;</span> +</span><br><span class="line">            <span class="string">&quot;   ORDER BY et &quot;</span> +</span><br><span class="line">            <span class="string">&quot;   ROWS BETWEEN 3 PRECEDING AND CURRENT ROW&quot;</span> +</span><br><span class="line">            <span class="string">&quot;) AS avg_ts &quot;</span> +</span><br><span class="line">            <span class="string">&quot;FROM clickTable&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结果表转换成流打印输出</span></span><br><span class="line">    tableEnv.toChangelogStream(aggTable).print(<span class="string">&quot;agg: &quot;</span>);</span><br><span class="line">    tableEnv.toDataStream(groupWindowResultTable).print(<span class="string">&quot;group window: &quot;</span>);</span><br><span class="line">    tableEnv.toDataStream(tumbleWindowResultTable).print(<span class="string">&quot;tumble window: &quot;</span>);</span><br><span class="line">    tableEnv.toDataStream(hopWindowResultTable).print(<span class="string">&quot;hop window: &quot;</span>);</span><br><span class="line">    tableEnv.toDataStream(cumulateWindowResultTable).print(<span class="string">&quot;cumulate window: &quot;</span>);</span><br><span class="line">    tableEnv.toDataStream(overWindowResultTable).print(<span class="string">&quot;over window: &quot;</span>);</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="聚合-Aggregation-查询"><a href="#聚合-Aggregation-查询" class="headerlink" title="聚合(Aggregation)查询"></a>聚合(Aggregation)查询</h3><p>Flink 中的 SQL 是流处理与标准 SQL 结合的产物，所以聚合查询也可以分成两种：流处理中特有的聚合(主要指窗口聚合)，以及 SQL 原生的聚合查询方式。</p>
<h4 id="分组聚合"><a href="#分组聚合" class="headerlink" title="分组聚合"></a>分组聚合</h4><p>SQL 中一般所说的聚合我们都很熟悉，主要是通过内置的一些聚合函数来实现的，比如SUM()、MAX()、MIN()、AVG()以及 COUNT()。它们的特点是对多条输入数据进行计算，得到一个唯一的值，属于多对一的转换。</p>
<p>在流处理中，分组聚合同样是一个持续查询，而且是一个更新查询，得到的是一个动态表；每当流中有一个新的数据到来时，都会导致结果表的更新操作。因此，想要将结果表转换成流或输出到外部系统，必须采用<strong>撤回流</strong>(retract stream)或<strong>更新插入流</strong>(upsert stream)的编码方式；如果在代码中直接转换成DataStream打印输出，需要调用toChangelogStream()。</p>
<p>另外，在持续查询的过程中，由于用于分组的 key 可能会不断增加，因此计算结果所需要维护的状态也会持续增长。为了防止状态无限增长耗尽资源，Flink Table API 和 SQL 可以在表环境中配置状态的生存时间(TTL)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TableEnvironment tableEnv = ...</span><br><span class="line"><span class="comment">// 获取表环境的配置</span></span><br><span class="line">TableConfig tableConfig = tableEnv.getConfig();</span><br><span class="line"><span class="comment">// 配置状态保持时间 </span></span><br><span class="line">tableConfig.setIdleStateRetention(Duration.ofMinutes(<span class="number">60</span>));</span><br></pre></td></tr></table></figure>

<p>或者也可以直接设置配置项 table.exec.state.ttl：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TableEnvironment tableEnv = ...</span><br><span class="line">Configuration configuration = tableEnv.getConfig().getConfiguration();</span><br><span class="line">configuration.setString(<span class="string">&quot;table.exec.state.ttl&quot;</span>, <span class="string">&quot;60 min&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这两种方式是等效的。需要注意，配置 TTL 有可能会导致统计结果不准确，这其实是以牺牲正确性为代价换取了资源的释放。</p>
<h4 id="窗口聚合"><a href="#窗口聚合" class="headerlink" title="窗口聚合"></a>窗口聚合</h4><p>在流处理中，往往需要将无限数据流划分成有界数据集，这就是所谓的窗口。</p>
<p>与分组聚合类似，窗口聚合也需要调用SUM()、MAX()、MIN()、COUNT()一类的聚合函数，通过 GROUP BY 子句来指定分组的字段。只不过窗口聚合时，需要将窗口信息作为分组 key 的一部分定义出来。在 Flink 1.12 版本之前，是直接把窗口自身作为分组 key 放在 GROUP BY 之后的，所以也叫分组窗口聚合；而 1.13 版本开始使用了窗口表值函数(Windowing TVF)，<strong>窗口本身返回的就是一个表</strong>，所以窗口会出现在 FROM 后面，GROUP BY 后面的则是窗口新增的字段 window_start 和 window_end。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Table result = tableEnv.sqlQuery(</span><br><span class="line">                    <span class="string">&quot;SELECT &quot;</span> +</span><br><span class="line">                       <span class="string">&quot;user, &quot;</span> +</span><br><span class="line">                       <span class="string">&quot;window_end AS endT, &quot;</span> +</span><br><span class="line">                       <span class="string">&quot;COUNT(url) AS cnt &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;FROM TABLE( &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;TUMBLE( TABLE EventTable, &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;DESCRIPTOR(ts), &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;INTERVAL &#x27;1&#x27; HOUR)) &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;GROUP BY user, window_start, window_end &quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这里我们以 ts 作为时间属性字段、基于 EventTable 定义了 1 小时的滚动窗口，希望统计出每小时每个用户点击 url 的次数。用来分组的字段是用户名 user，以及表示窗口的 window_start 和 window_end；而 TUMBLE() 是表值函数，所以得到的是一个表(Table)，我们的聚合查询就是在这个 Table 中进行的。</p>
<h4 id="开窗-Over-聚合"><a href="#开窗-Over-聚合" class="headerlink" title="开窗(Over)聚合"></a>开窗(Over)聚合</h4><p>在标准 SQL 中还有另外一类比较特殊的聚合方式，可以针对每一行计算一个聚合值。比如说，我们可以以每一行数据为基准，计算它之前 1 小时内所有数据的平均值；也可以计算它之前 10 个数的平均值。就好像是在每一行上打开了一扇窗户、收集数据进行统计一样，这就是所谓的开窗函数。开窗函数的聚合与之前两种聚合有本质的不同：分组聚合、窗口 TVF 聚合都是多对一的关系，将数据分组之后每组只会得到一个聚合结果；而开窗函数是对每行都要做一次开窗聚合，因此聚合之后表中的行数不会有任何减少，是一个多对多的关系。</p>
<p>与标准SQL中一致，Flink SQL中的开窗函数也是通过OVER子句来实现的，所以有时开窗聚合也叫作 OVER 聚合(Over Aggregation)。基本语法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">  &lt;聚合函数&gt; OVER (</span><br><span class="line">    [PARTITION BY &lt;字段 <span class="number">1</span>&gt;[, &lt;字段 <span class="number">2</span>&gt;, ...]] </span><br><span class="line">    ORDER BY &lt;时间属性字段&gt;</span><br><span class="line">    &lt;开窗范围&gt;),</span><br><span class="line">  ...</span><br><span class="line">FROM ...</span><br></pre></td></tr></table></figure>

<p>开窗范围是由 BETWEEN &lt;下界&gt; AND &lt;上界&gt; 来定义的，也就是从下界到上界的范围。目前支持的上界只能是 CURRENT ROW，也就是定义一个<strong>从之前某一行到当前行</strong>的范围，所以一般的形式为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BETWEEN ... PRECEDING AND CURRENT ROW</span><br></pre></td></tr></table></figure>

<p>开窗选择的范围可以基于<strong>时间</strong>，也可以基于<strong>数据的数量</strong>。所以开窗范围还应该在两种模式之间做出选择：**范围间隔(RANGE intervals)<strong>和</strong>行间隔(ROW intervals)**。</p>
<p><strong>范围间隔</strong>以 RANGE 为前缀，就是基于 ORDER BY 指定的时间字段去选取一个范围，一般就是当前行时间戳之前的一段时间。例如开窗范围选择当前行之前 1 小时的数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RANGE BETWEEN INTERVAL <span class="string">&#x27;1&#x27;</span> HOUR PRECEDING AND CURRENT ROW</span><br></pre></td></tr></table></figure>

<p>行间隔以 ROWS 为前缀，就是直接确定要选多少行，由当前行出发向前选取就可以了。例如开窗范围选择当前行之前的 5 行数据(最终聚合会包括当前行，所以一共 6 条数据)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROWS BETWEEN <span class="number">5</span> PRECEDING AND CURRENT ROW</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">user</span>, ts,</span><br><span class="line">       <span class="built_in">COUNT</span>(url) <span class="keyword">OVER</span> (</span><br><span class="line">          <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">user</span></span><br><span class="line">          <span class="keyword">ORDER</span> <span class="keyword">BY</span> ts</span><br><span class="line">          <span class="keyword">RANGE</span> <span class="keyword">BETWEEN</span> <span class="type">INTERVAL</span> <span class="string">&#x27;1&#x27;</span> <span class="keyword">HOUR</span> PRECEDING <span class="keyword">AND</span> <span class="keyword">CURRENT</span> <span class="type">ROW</span></span><br><span class="line">       ) <span class="keyword">AS</span> cnt</span><br><span class="line"><span class="keyword">FROM</span> EventTable</span><br></pre></td></tr></table></figure>

<p>这里我们以 ts 作为时间属性字段，对 EventTable 中的每行数据都选取它之前 1 小时的所有数据进行聚合，统计每个用户访问 url 的总次数，并重命名为 cnt。最终将表中每行的 user， ts 以及扩展出 cnt 提取出来。</p>
<p>整个开窗聚合的结果，是对每一行数据都有一个对应的聚合值，因此就像将表中扩展出了一个新的列一样。由于聚合范围上界只能到当前行，新到的数据一般不会影响之前数据的聚合结果，所以结果表只需要不断插入(INSERT)就可以了。执行上面 SQL 得到的结果表，可以用 toDataStream() 直接转换成流打印输出。</p>
<p>开窗聚合与窗口聚合(窗口 TVF 聚合)本质上不同，不过也还是有一些相似之处的：它们都是在无界的数据流上划定了一个范围，截取出有限数据集进行聚合统计；这其实都是窗口的思路。事实上，在 Table API 中确实就定义了两类窗口：分组窗口(GroupWindow)和开窗窗口(OverWindow)；而在 SQL 中，也可以用 WINDOW 子句来在 SELECT 外部单独定义 一个 OVER 窗口：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">user</span>, ts,</span><br><span class="line">  <span class="built_in">COUNT</span>(url) <span class="keyword">OVER</span> w <span class="keyword">AS</span> cnt,</span><br><span class="line">  <span class="built_in">MAX</span>(<span class="keyword">CHAR_LENGTH</span>(url)) <span class="keyword">OVER</span> w <span class="keyword">AS</span> max_url</span><br><span class="line"><span class="keyword">FROM</span> EventTable</span><br><span class="line"><span class="keyword">WINDOW</span> w <span class="keyword">AS</span> (</span><br><span class="line">  <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">user</span></span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> ts</span><br><span class="line">  <span class="keyword">ROWS</span> <span class="keyword">BETWEEN</span> <span class="number">2</span> PRECEDING <span class="keyword">AND</span> <span class="keyword">CURRENT</span> <span class="type">ROW</span>)</span><br></pre></td></tr></table></figure>

<p>上面的 SQL 中定义了一个选取之前 2 行数据的 OVER 窗口，并重命名为 w；接下来就可以基于它调用多个聚合函数，扩展出更多的列提取出来。比如这里除统计 url 的个数外，还统计了 url 的最大长度：首先用 CHAR_LENGTH() 函数计算出 url 的长度，再调用聚合函数 MAX() 进行聚合统计。这样，我们就可以方便重复引用定义好的 OVER 窗口了，大大增强了代码的可读性。</p>
<h4 id="TopN"><a href="#TopN" class="headerlink" title="TopN"></a>TopN</h4><h5 id="普通TopN"><a href="#普通TopN" class="headerlink" title="普通TopN"></a><strong>普通TopN</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 在创建表的DDL中直接定义时间属性</span></span><br><span class="line">    String createDDL = <span class="string">&quot;CREATE TABLE clickTable (&quot;</span> +</span><br><span class="line">            <span class="string">&quot; `user` STRING, &quot;</span> +</span><br><span class="line">            <span class="string">&quot; url STRING, &quot;</span> +</span><br><span class="line">            <span class="string">&quot; ts BIGINT, &quot;</span> +</span><br><span class="line">            <span class="string">&quot; et AS TO_TIMESTAMP( FROM_UNIXTIME(ts / 1000) ), &quot;</span> +</span><br><span class="line">            <span class="string">&quot; WATERMARK FOR et AS et - INTERVAL &#x27;1&#x27; SECOND &quot;</span> +</span><br><span class="line">            <span class="string">&quot;) WITH (&quot;</span> +</span><br><span class="line">            <span class="string">&quot; &#x27;connector&#x27; = &#x27;filesystem&#x27;, &quot;</span> +</span><br><span class="line">            <span class="string">&quot; &#x27;path&#x27; = &#x27;input/clicks.csv&#x27;, &quot;</span> +</span><br><span class="line">            <span class="string">&quot; &#x27;format&#x27; =  &#x27;csv&#x27; &quot;</span> +</span><br><span class="line">            <span class="string">&quot;)&quot;</span>;</span><br><span class="line"></span><br><span class="line">    tableEnv.executeSql(createDDL);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通Top N，选取当前所有用户中浏览量最大的2个</span></span><br><span class="line"></span><br><span class="line">    Table topNResultTable = tableEnv.sqlQuery(<span class="string">&quot;SELECT user, cnt, row_num &quot;</span> +</span><br><span class="line">            <span class="string">&quot;FROM (&quot;</span> +</span><br><span class="line">            <span class="string">&quot;   SELECT *, ROW_NUMBER() OVER (&quot;</span> +</span><br><span class="line">            <span class="string">&quot;      ORDER BY cnt DESC&quot;</span> +</span><br><span class="line">            <span class="string">&quot;   ) AS row_num &quot;</span> +</span><br><span class="line">            <span class="string">&quot;   FROM (SELECT user, COUNT(url) AS cnt FROM clickTable GROUP BY user)&quot;</span> +</span><br><span class="line">            <span class="string">&quot;) WHERE row_num &lt;= 2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    tableEnv.toChangelogStream(topNResultTable).print(<span class="string">&quot;top 2: &quot;</span>);</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="窗口TopN"><a href="#窗口TopN" class="headerlink" title="窗口TopN"></a><strong>窗口TopN</strong></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取数据源，并分配时间戳、生成水位线</span></span><br><span class="line">    SingleOutputStreamOperator&lt;Event&gt; eventStream = env</span><br><span class="line">            .fromElements(</span><br><span class="line">                    <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">                    <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./cart&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">                    <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod?id=1&quot;</span>,  <span class="number">25</span> * <span class="number">60</span> * <span class="number">1000L</span>),</span><br><span class="line">                    <span class="keyword">new</span> Event(<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;./prod?id=4&quot;</span>, <span class="number">55</span> * <span class="number">60</span> * <span class="number">1000L</span>),</span><br><span class="line">                    <span class="keyword">new</span> Event(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;./prod?id=5&quot;</span>, <span class="number">3600</span> * <span class="number">1000L</span> + <span class="number">60</span> * <span class="number">1000L</span>),</span><br><span class="line">                    <span class="keyword">new</span> Event(<span class="string">&quot;Cary&quot;</span>, <span class="string">&quot;./home&quot;</span>, <span class="number">3600</span> * <span class="number">1000L</span> + <span class="number">30</span> * <span class="number">60</span> * <span class="number">1000L</span>),</span><br><span class="line">                    <span class="keyword">new</span> Event(<span class="string">&quot;Cary&quot;</span>, <span class="string">&quot;./prod?id=7&quot;</span>, <span class="number">3600</span> * <span class="number">1000L</span> + <span class="number">59</span> * <span class="number">60</span> * <span class="number">1000L</span>)</span><br><span class="line">            )</span><br><span class="line">            .assignTimestampsAndWatermarks(</span><br><span class="line">                    WatermarkStrategy.&lt;Event&gt;forMonotonousTimestamps()</span><br><span class="line">                            .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Event&gt;() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Event element, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                                    <span class="keyword">return</span> element.timestamp;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;)</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建表环境</span></span><br><span class="line">    StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数据流转换成表，并指定时间属性</span></span><br><span class="line">    Table eventTable = tableEnv.fromDataStream(</span><br><span class="line">            eventStream,</span><br><span class="line">            $(<span class="string">&quot;user&quot;</span>),</span><br><span class="line">            $(<span class="string">&quot;url&quot;</span>),</span><br><span class="line">            $(<span class="string">&quot;timestamp&quot;</span>).rowtime().as(<span class="string">&quot;ts&quot;</span>)</span><br><span class="line">            <span class="comment">// 将timestamp指定为事件时间，并命名为ts</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为方便在SQL中引用，在环境中注册表EventTable</span></span><br><span class="line">    tableEnv.createTemporaryView(<span class="string">&quot;EventTable&quot;</span>, eventTable);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义子查询，进行窗口聚合，得到包含窗口信息、用户以及访问次数的结果表</span></span><br><span class="line">    String subQuery =</span><br><span class="line">            <span class="string">&quot;SELECT window_start, window_end, user, COUNT(url) as cnt &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;FROM TABLE ( &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;TUMBLE( TABLE EventTable, DESCRIPTOR(ts), INTERVAL &#x27;1&#x27; HOUR )) &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;GROUP BY window_start, window_end, user &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义Top N的外层查询</span></span><br><span class="line">    String topNQuery =</span><br><span class="line">            <span class="string">&quot;SELECT * &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;FROM (&quot;</span> +</span><br><span class="line">                    <span class="string">&quot;SELECT *, &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;ROW_NUMBER() OVER ( &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;PARTITION BY window_start, window_end &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;ORDER BY cnt desc &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;) AS row_num &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;FROM (&quot;</span> + subQuery + <span class="string">&quot;)) &quot;</span> +</span><br><span class="line">                    <span class="string">&quot;WHERE row_num &lt;= 2&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行SQL得到结果表</span></span><br><span class="line">    Table result = tableEnv.sqlQuery(topNQuery);</span><br><span class="line"></span><br><span class="line">    tableEnv.toDataStream(result).print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="联结-Join-查询"><a href="#联结-Join-查询" class="headerlink" title="联结(Join)查询"></a>联结(Join)查询</h3><p>在流处理中，动态表的 Join 对应着两条数据流的 Join 操作。Flink SQL 中的联结查询大体上也可以分为两类：SQL 原生的联结查询方式，和流处理中特有的联结查询。</p>
<h4 id="常规联结查询"><a href="#常规联结查询" class="headerlink" title="常规联结查询"></a>常规联结查询</h4><p>常规联结(Regular Join)是 SQL 中原生定义的 Join 方式，是最通用的一类联结操作。它的具体语法与标准 SQL 的联结完全相同，通过关键字 JOIN 来联结两个表，后面用关键字 ON 来指明联结条件。按照习惯，我们一般以左侧和右侧来区分联结操作的两个表。</p>
<p>在两个动态表的联结中，任何一侧表的插入(INSERT)或更改(UPDATE)操作都会让联结的结果表发生改变。例如，如果左侧有新数据到来，那么它会与右侧表中所有之前的数据进行联结合并，右侧表之后到来的新数据也会与这条数据连接合并。所以，<strong>常规联结查询一般是更新(Update)查询</strong>。</p>
<p>与标准 SQL 一致，Flink SQL 的常规联结也可以分为<strong>内联结(INNER JOIN)<strong>和</strong>外联结 (OUTER JOIN)<strong>，区别在于结果中是否包含不符合联结条件的行。目前</strong>仅支持等值条件</strong>作为联结条件，也就是关键字 ON 后面必须是判断两表中字段相等的逻辑表达式。</p>
<h4 id="间隔联结查询"><a href="#间隔联结查询" class="headerlink" title="间隔联结查询"></a>间隔联结查询</h4><p>DataStream API 中的双流 Join，包括<strong>窗口联结</strong>(window join)和<strong>间隔联结</strong>(interval join)。两条流的 Join 就对应着 SQL 中两个表的 Join，这是流处理中特有的联结方式。<strong>目前 Flink SQL 还不支持窗口联结，而间隔联结则已经实现</strong>。</p>
<p>间隔联结(Interval Join)返回的，同样是符合约束条件的两条数据的笛卡尔积。只不过这里的约束条件除了常规的<strong>联结条件</strong>外，还多了一个<strong>时间间隔的限制</strong>。具体语法有以下要点：</p>
<p><strong>两表的联结</strong></p>
<p>间隔联结不需要用 JOIN 关键字，直接在 FROM 后将要联结的两表列出来就可以，用逗号分隔。这与标准 SQL 中的语法一致，表示一个交叉联结(Cross Join)，会返回两表中所有行的笛卡尔积。</p>
<p><strong>联结条件</strong></p>
<p>联结条件用 WHERE 子句来定义，用一个等值表达式描述。交叉联结之后再用 WHERE 进行条件筛选，效果跟内联结 INNER JOIN … ON …非常类似。</p>
<p><strong>时间间隔限制</strong></p>
<p>我们可以在 WHERE 子句中，联结条件后用 AND 追加一个时间间隔的限制条件；做法是提取左右两侧表中的时间字段，然后用一个表达式来指明两者需要满足的间隔限制。具体定义方式有下面三种，这里分别用 ltime 和 rtime 表示左右表中的时间字段：</p>
<p>(1)ltime = rtime</p>
<p>(2)ltime &gt;= rtime AND ltime &lt; rtime + INTERVAL ‘10’ MINUTE</p>
<p>(3)ltime BETWEEN rtime - INTERVAL ‘10’ SECOND AND rtime + INTERVAL ‘5’ SECOND</p>
<p>判断两者相等，这是最强的时间约束，要求两表中数据的时间必须完全一致才能匹配；一般情况下，我们还是会放宽一些，给出一个间隔。间隔的定义可以用&lt;，&lt;=，&gt;=，&gt;这一类的关系不等式，也可以用 BETWEEN … AND …这样的表达式。</p>
<p>例如，我们现在除了订单表 Order 外，还有一个发货表Shipment，要求在收到订单后 4 个小时内发货。那么我们就可以用一个间隔联结查询，把所有订单与它对应的发货信息连接合并在一起返回。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">Order</span> o, Shipment s</span><br><span class="line"><span class="keyword">WHERE</span> o.id <span class="operator">=</span> s.order_id</span><br><span class="line"><span class="keyword">AND</span> o.order_time <span class="keyword">BETWEEN</span> s.ship_time <span class="operator">-</span> <span class="type">INTERVAL</span> <span class="string">&#x27;4&#x27;</span> <span class="keyword">HOUR</span> <span class="keyword">AND</span> s.ship_time</span><br></pre></td></tr></table></figure>

<p>在流处理中，间隔联结查询只支持具有时间属性的仅追加(Append-only)表。</p>
<p>那对于有更新操作的表，又怎么办呢？除了间隔联结之外，Flink SQL 还支持时间联结 (Temporal Join)，这主要是针对版本表(versioned table)而言的。所谓版本表，就是记录了数据随着时间推移版本变化的表，可以理解成一个更新日志(change log)，它就是具有时间属性、还会进行更新操作的表。当我们联结某个版本表时，并不是把当前的数据连接合并起来就行了，而是希望能够根据数据发生的时间，找到当时的版本；这种根据更新时间提取当时的值进行联结的操作，就叫作时间联结(Temporal Join)。这部分内容可以查阅官网资料。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>Flink 的 Table API 和 SQL 同样提供了函数的功能。两者在调用时略有不同：Table API 中的函数是通过数据对象的方法调用来实现的；而 SQL 则是直接引用函数名称，传入数据作为参数。例如，要把一个字符串 str 转换成全大写的形式，Table API 的写法是调用 str 这个 String 对象的 upperCase() 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.upperCase();</span><br></pre></td></tr></table></figure>

<p>而 SQL 中的写法就是直接引用 UPPER() 函数，将 str 作为参数传入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPPER(str)</span><br></pre></td></tr></table></figure>

<p>由于 Table API 是内嵌在 Java 语言中的，很多方法需要在类中额外添加，因此扩展功能比较麻烦，目前支持的函数比较少；而且 Table API 也不如 SQL 的通用性强，所以一般情况下较少使用。</p>
<p>Flink SQL 中的函数可以分为两类：一类是 SQL 中内置的系统函数，直接通过函数名调用就可以，能够实现一些常用的转换操作，比如之前我们用到的 COUNT()、CHAR_LENGTH()、UPPER() 等等；而另一类函数则是用户自定义的函数(UDF)，需要在表环境中注册才能使用。 </p>
<h4 id="UDF"><a href="#UDF" class="headerlink" title="UDF"></a>UDF</h4><p>系统函数尽管庞大，也不可能涵盖所有的功能；如果有系统函数不支持的需求，我们就需要用自定义函数(User Defined Functions，UDF)来实现了。事实上，系统内置函数仍然在不断扩充，如果我们认为自己实现的自定义函数足够通用、应用非常广泛，也可以在项目跟踪工具 JIRA 上向 Flink 开发团队提出议题(issue)，请求将新的函数添加到系统函数中。</p>
<p>Flink 的 Table API 和 SQL 提供了多种自定义函数的接口，以抽象类的形式定义。当前 UDF 主要有以下几类：</p>
<p><strong>标量函数</strong>(Scalar Functions)：将输入的标量值转换成一个新的标量值。</p>
<p><strong>表函数</strong>(Table Functions)：将标量值转换成一个或多个新的行数据，也就是扩展成一个表。</p>
<p><strong>聚合函数</strong>(Aggregate Functions)：将多行数据里的标量值转换成一个新的标量值。</p>
<p><strong>表聚合函数</strong>(Table Aggregate Functions)：将多行数据里的标量值转换成一个或多个新的行数据。</p>
<h4 id="UDF调用流程"><a href="#UDF调用流程" class="headerlink" title="UDF调用流程"></a>UDF调用流程</h4><p>要想在代码中使用自定义的函数，我们需要首先自定义对应 UDF 抽象类的实现，并在表环境中注册这个函数，然后就可以在 Table API 和 SQL 中调用了。</p>
<p><strong>(1)注册函数</strong></p>
<p>注册函数时需要调用表环境的 createTemporarySystemFunction() 方法，传入注册的函数名以及 UDF 类的 Class 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册函数</span></span><br><span class="line">tableEnv.createTemporarySystemFunction(<span class="string">&quot;MyFunction&quot;</span>, MyFunction.class);</span><br></pre></td></tr></table></figure>

<p>我们自定义的 UDF 类叫作 MyFunction，它应该是上面四种 UDF 抽象类中某一个的具体实现；在环境中将它注册为名叫 MyFunction 的函数。这里 <strong>createTemporarySystemFunction()</strong> 方法的意思是创建了一个临时系统函数，所以 MyFunction 函数名是全局的，可以当作系统函数来使用；我们也可以用 <strong>createTemporaryFunction()</strong> 方法，注册的函数就依赖于当前的数据库(database)和目录(catalog) 了，所以这就不是系统函数，而是目录函数(catalog function)，它的完整名称应该包括所属的 database 和 catalog。一般情况下，我们直接用 createTemporarySystemFunction() 方法将 UDF 注册为系统函数就可以了。</p>
<p><strong>(2)使用 Table API 调用函数</strong></p>
<p>在 Table API 中，需要使用 call() 方法来调用自定义函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tableEnv.from(<span class="string">&quot;MyTable&quot;</span>).select(call(<span class="string">&quot;MyFunction&quot;</span>, $(<span class="string">&quot;myField&quot;</span>)));</span><br></pre></td></tr></table></figure>

<p>此外，在 Table API 中也可以不注册函数，直接用内联(inline)的方式调用 UDF：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tableEnv.from(<span class="string">&quot;MyTable&quot;</span>).select(call(SubstringFunction.class, $(<span class="string">&quot;myField&quot;</span>)));</span><br></pre></td></tr></table></figure>

<p>区别只是在于 call() 方法第一个参数不再是注册好的函数名，而直接就是函数类的 Class 对象了。</p>
<p><strong>(3)在 SQL 中调用函数</strong></p>
<p>当我们将函数注册为系统函数之后，在 SQL 中的调用就与内置系统函数完全一样了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tableEnv.sqlQuery(<span class="string">&quot;SELECT MyFunction(myField) FROM MyTable&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="标量函数-Scalar-Functions"><a href="#标量函数-Scalar-Functions" class="headerlink" title="标量函数(Scalar Functions)"></a>标量函数(Scalar Functions)</h4><p>自定义标量函数可以把 0 个、 1 个或多个标量值转换成一个标量值，它对应的<strong>输入是一行数据中的字段</strong>，<strong>输出则是唯一的值</strong>。所以从输入和输出表中行数据的对应关系看，标量函数是<strong>一对一</strong>的转换。</p>
<p>想要实现自定义的标量函数，我们需要自定义一个类来继承抽象类 ScalarFunction，并实现叫作 eval() 的求值方法。标量函数的行为就取决于求值方法的定义，它必须是<strong>公有的(public)<strong>， 而且</strong>名字必须是 eval</strong>。求值方法 eval 可以重载多次，任何数据类型都可作为求值方法的参数和返回值类型。</p>
<p>这里需要特别说明的是，ScalarFunction 抽象类中并没有定义 eval() 方法，所以我们不能直接在代码中重写(override)；但 Table API 的框架底层又要求了求值方法必须名字为 eval()。这是 Table API 和 SQL 目前还显得不够完善的地方，未来的版本应该会有所改进。</p>
<p>ScalarFunction 以及其它所有的 UDF 接口，都在 org.apache.flink.table.functions 中。</p>
<p>下面我们来看一个具体的例子。我们实现一个自定义的哈希(hash)函数 HashFunction，用来求传入对象的哈希值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 自定义数据源，从流转换</span></span><br><span class="line">    SingleOutputStreamOperator&lt;Event&gt; eventStream = env.addSource(<span class="keyword">new</span> ClickSource())</span><br><span class="line">            .assignTimestampsAndWatermarks(WatermarkStrategy.&lt;Event&gt;forBoundedOutOfOrderness(Duration.ZERO)</span><br><span class="line">                    .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Event&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Event element, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> element.timestamp;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将流转换成表</span></span><br><span class="line">    Table eventTable = tableEnv.fromDataStream(eventStream,</span><br><span class="line">            $(<span class="string">&quot;user&quot;</span>),</span><br><span class="line">            $(<span class="string">&quot;url&quot;</span>),</span><br><span class="line">            $(<span class="string">&quot;timestamp&quot;</span>).rowtime().as(<span class="string">&quot;ts&quot;</span>));</span><br><span class="line"></span><br><span class="line">    tableEnv.createTemporaryView(<span class="string">&quot;EventTable&quot;</span>, eventTable);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 注册自定义标量函数</span></span><br><span class="line">    tableEnv.createTemporarySystemFunction(<span class="string">&quot;MyHash&quot;</span>, MyHash.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 调用UDF查询转换</span></span><br><span class="line">    Table resultTable = tableEnv.sqlQuery(<span class="string">&quot;select user, MyHash(user) from EventTable&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 输出到控制台</span></span><br><span class="line">    tableEnv.executeSql(<span class="string">&quot;create table output (&quot;</span> +</span><br><span class="line">            <span class="string">&quot;uname STRING, &quot;</span> +</span><br><span class="line">            <span class="string">&quot;myhash INT ) &quot;</span> +</span><br><span class="line">            <span class="string">&quot;WITH (&quot;</span> +</span><br><span class="line">            <span class="string">&quot;&#x27;connector&#x27; = &#x27;print&#x27;)&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    resultTable.executeInsert(<span class="string">&quot;output&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 自定义一个ScalarFunction</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHash</span> <span class="keyword">extends</span> <span class="title">ScalarFunction</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eval</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="表函数-Table-Functions"><a href="#表函数-Table-Functions" class="headerlink" title="表函数(Table Functions)"></a>表函数(Table Functions)</h4><p>跟标量函数一样，表函数的输入参数也可以是 0 个、1 个或多个标量值；不同的是，它可以<strong>返回任意多行数据</strong>。多行数据事实上就构成了一个表，所以表函数可以认为就是返回一个表的函数，这是一个<strong>一对多</strong>的转换关系。<strong>窗口 TVF 本质上就是表函数</strong>。</p>
<p>类似地，要实现自定义的表函数，需要自定义类来继承抽象类 TableFunction，内部必须要实现的也是一个名为 eval 的求值方法。与标量函数不同的是，TableFunction 类本身是有一 个泛型参数 T 的，这就是表函数返回数据的类型；而 eval()方法没有返回类型，内部也没有 return 语句，是通过调用 collect() 方法来发送想要输出的行数据的。回忆一下 DataStream API 中的 FlatMapFunction 和 ProcessFunction，它们的 flatMap 和 processElement 方法也没有返回值，也是通过 out.collect() 来向下游发送数据的。</p>
<p>我们使用表函数，可以对一行数据得到一个表，这和 Hive 中的 UDTF 非常相似。那对于原先输入的整张表来说，又该得到什么呢?一个简单的想法是，就让输入表中的每一行，与它转换得到的表进行联结(join)，然后再拼成一个完整的大表，这就相当于对原来的表进行了扩展。在 Hive 的 SQL 语法中，提供了侧向视图(lateral view，也叫横向视图)的功能，可以将表中的一行数据拆分成多行；Flink SQL 也有类似的功能，是用 <strong>LATERAL TABLE</strong> 语法来实现的。</p>
<p>在 SQL 中调用表函数，需要使用 LATERAL TABLE(<TableFunction>)来生成扩展的侧向表，然后与原始表进行联结(Join)。这里的Join操作可以是直接做交叉联结(cross join)， 在 FROM 后用逗号分隔两个表就可以；也可以是以 ON TRUE 为条件的左联结(LEFT JOIN)。</TableFunction></p>
<p>下面是表函数的一个具体示例。我们实现了一个分隔字符串的函数 SplitFunction，可以将一个字符串转换成(字符串，长度)的二元组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 自定义数据源，从流转换</span></span><br><span class="line">    SingleOutputStreamOperator&lt;Event&gt; eventStream = env.addSource(<span class="keyword">new</span> ClickSource())</span><br><span class="line">            .assignTimestampsAndWatermarks(WatermarkStrategy.&lt;Event&gt;forBoundedOutOfOrderness(Duration.ZERO)</span><br><span class="line">                    .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Event&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Event element, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> element.timestamp;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将流转换成表</span></span><br><span class="line">    Table eventTable = tableEnv.fromDataStream(eventStream,</span><br><span class="line">            $(<span class="string">&quot;user&quot;</span>),</span><br><span class="line">            $(<span class="string">&quot;url&quot;</span>),</span><br><span class="line">            $(<span class="string">&quot;timestamp&quot;</span>).rowtime().as(<span class="string">&quot;ts&quot;</span>));</span><br><span class="line"></span><br><span class="line">    tableEnv.createTemporaryView(<span class="string">&quot;EventTable&quot;</span>, eventTable);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 注册自定义表函数</span></span><br><span class="line">    tableEnv.createTemporarySystemFunction(<span class="string">&quot;MySplit&quot;</span>, MySplit.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 调用UDF查询转换</span></span><br><span class="line">    Table resultTable = tableEnv.sqlQuery(<span class="string">&quot;select user, url, word, length &quot;</span> +</span><br><span class="line">            <span class="string">&quot;from EventTable, LATERAL TABLE( MySplit(url) ) AS T(word, length)&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 输出到控制台</span></span><br><span class="line">    tableEnv.executeSql(<span class="string">&quot;create table output (&quot;</span> +</span><br><span class="line">            <span class="string">&quot;uname STRING, &quot;</span> +</span><br><span class="line">            <span class="string">&quot;url STRING, &quot;</span> +</span><br><span class="line">            <span class="string">&quot;word STRING, &quot;</span> +</span><br><span class="line">            <span class="string">&quot;length INT) &quot;</span> +</span><br><span class="line">            <span class="string">&quot;WITH (&quot;</span> +</span><br><span class="line">            <span class="string">&quot;&#x27;connector&#x27; = &#x27;print&#x27;)&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    resultTable.executeInsert(<span class="string">&quot;output&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义一个TableFunction，注意有泛型，这里输出的是两个字段，二元组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MySplit</span> <span class="keyword">extends</span> <span class="title">TableFunction</span>&lt;<span class="title">Tuple2</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>&gt;&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eval</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        String[] fields = str.split(<span class="string">&quot;\\?&quot;</span>);    <span class="comment">// 转义问号，以及反斜杠本身</span></span><br><span class="line">        <span class="keyword">for</span> (String field : fields)&#123;</span><br><span class="line">            collect(Tuple2.of(field, field.length()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 SQL 里调用注册好的函数 </span></span><br><span class="line"><span class="comment">// 1. 交叉联结 </span></span><br><span class="line">tableEnv.sqlQuery(</span><br><span class="line">  <span class="string">&quot;SELECT myField, word, length &quot;</span> +</span><br><span class="line"><span class="string">&quot;FROM MyTable, LATERAL TABLE(SplitFunction(myField))&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 带 ON TRUE 条件的左联结</span></span><br><span class="line">tableEnv.sqlQuery(</span><br><span class="line">  <span class="string">&quot;SELECT myField, word, length &quot;</span> +</span><br><span class="line">  <span class="string">&quot;FROM MyTable &quot;</span> +</span><br><span class="line">  <span class="string">&quot;LEFT JOIN LATERAL TABLE(SplitFunction(myField)) ON TRUE&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重命名侧向表中的字段 </span></span><br><span class="line">tableEnv.sqlQuery(</span><br><span class="line">  <span class="string">&quot;SELECT myField, newWord, newLength &quot;</span> +</span><br><span class="line">  <span class="string">&quot;FROM MyTable &quot;</span> +</span><br><span class="line">  <span class="string">&quot;LEFT JOIN LATERAL TABLE(SplitFunction(myField)) AS T(newWord, newLength) ON TRUE&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="聚合函数-Aggregate-Functions"><a href="#聚合函数-Aggregate-Functions" class="headerlink" title="聚合函数(Aggregate Functions)"></a>聚合函数(Aggregate Functions)</h4><p>用户自定义聚合函数(User Defined AGGregate function，UDAGG)会把一行或多行数据 (也就是一个表)聚合成一个标量值。这是一个标准的<strong>多对一</strong>的转换。</p>
<p>聚合函数的概念我们之前已经接触过多次，如 SUM()、MAX()、MIN()、AVG()、COUNT() 都是常见的系统内置聚合函数。而如果有些需求无法直接调用系统函数解决，我们就必须自定义聚合函数来实现功能了。</p>
<p>自定义聚合函数需要继承抽象类 AggregateFunction。AggregateFunction 有两个泛型参数 &lt;T, ACC&gt;，T 表示聚合输出的结果类型，ACC 则表示聚合的中间状态类型。</p>
<p>Flink SQL 中的聚合函数的工作原理如下：</p>
<p>(1)首先，它需要创建一个累加器(accumulator)，用来存储聚合的中间结果。这与 DataStream API 中的AggregateFunction非常类似，累加器就可以看作是一个聚合状态。调用 createAccumulator() 方法可以创建一个空的累加器。</p>
<p>(2)对于输入的每一行数据，都会调用 accumulate() 方法来更新累加器，这是聚合的核心过程。</p>
<p>(3)当所有的数据都处理完之后，通过调用 getValue() 方法来计算并返回最终的结果。</p>
<p>下面举一个具体的示例。在常用的系统内置聚合函数里，可以用 AVG()来计算平均值;如 果我们现在希望计算的是某个字段的“加权平均值”，又该怎么做呢?系统函数里没有现成的 实现，所以只能自定义一个聚合函数 WeightedAvg 来计算了。</p>
<p>比如我们要从学生的分数表 ScoreTable 中计算每个学生的加权平均分。为了计算加权平均值，应该从输入的每行数据中提取两个值作为参数：要计算的分数值 score，以及它的权重 weight。而在聚合过程中，累加器(accumulator)需要存储当前的加权总和sum，以及目前数据的个数 count。这可以用一个二元组来表示，也可以单独定义一个类 WeightedAvgAccum， 里面包含 sum 和 count 两个属性，用它的对象实例来作为聚合的累加器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 自定义数据源，从流转换</span></span><br><span class="line">    SingleOutputStreamOperator&lt;Event&gt; eventStream = env.addSource(<span class="keyword">new</span> ClickSource())</span><br><span class="line">            .assignTimestampsAndWatermarks(WatermarkStrategy.&lt;Event&gt;forBoundedOutOfOrderness(Duration.ZERO)</span><br><span class="line">                    .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Event&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Event element, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> element.timestamp;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将流转换成表</span></span><br><span class="line">    Table eventTable = tableEnv.fromDataStream(eventStream,</span><br><span class="line">            $(<span class="string">&quot;user&quot;</span>),</span><br><span class="line">            $(<span class="string">&quot;url&quot;</span>),</span><br><span class="line">            $(<span class="string">&quot;timestamp&quot;</span>).as(<span class="string">&quot;ts&quot;</span>),</span><br><span class="line">            $(<span class="string">&quot;rt&quot;</span>).rowtime());</span><br><span class="line">    tableEnv.createTemporaryView(<span class="string">&quot;EventTable&quot;</span>, eventTable);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 注册自定义表函数</span></span><br><span class="line">    tableEnv.createTemporarySystemFunction(<span class="string">&quot;WeightedAverage&quot;</span>, WeightedAverage.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 调用UDF查询转换，这里权重直接给1</span></span><br><span class="line">    Table resultTable = tableEnv.sqlQuery(<span class="string">&quot;select user, &quot;</span> +</span><br><span class="line">            <span class="string">&quot;  WeightedAverage(ts, 1) as weighted_avg &quot;</span> +</span><br><span class="line">            <span class="string">&quot;from EventTable &quot;</span> +</span><br><span class="line">            <span class="string">&quot;group by user&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 输出到控制台</span></span><br><span class="line">    tableEnv.executeSql(<span class="string">&quot;create table output (&quot;</span> +</span><br><span class="line">            <span class="string">&quot;uname STRING, &quot;</span> +</span><br><span class="line">            <span class="string">&quot;weighted_avg BIGINT) &quot;</span> +</span><br><span class="line">            <span class="string">&quot;WITH (&quot;</span> +</span><br><span class="line">            <span class="string">&quot;&#x27;connector&#x27; = &#x27;print&#x27;)&quot;</span>);</span><br><span class="line">    resultTable.executeInsert(<span class="string">&quot;output&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单独定义一个累加器类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WeightedAvgAccumulator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> sum = <span class="number">0</span>;    <span class="comment">// 加权和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> count = <span class="number">0</span>;    <span class="comment">// 数据个数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义一个AggregateFunction，求加权平均值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WeightedAverage</span> <span class="keyword">extends</span> <span class="title">AggregateFunction</span>&lt;<span class="title">Long</span>, <span class="title">WeightedAvgAccumulator</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getValue</span><span class="params">(WeightedAvgAccumulator accumulator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (accumulator.count == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;    <span class="comment">// 防止除数为0</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> accumulator.sum / accumulator.count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> WeightedAvgAccumulator <span class="title">createAccumulator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WeightedAvgAccumulator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 累加计算方法，类似于add</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accumulate</span><span class="params">(WeightedAvgAccumulator accumulator, Long iValue, Integer iWeight)</span></span>&#123;</span><br><span class="line">        accumulator.sum += iValue * iWeight;    <span class="comment">// 这个值要算iWeight次</span></span><br><span class="line">        accumulator.count += iWeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="表聚合函数-Table-Aggregate-Functions"><a href="#表聚合函数-Table-Aggregate-Functions" class="headerlink" title="表聚合函数(Table Aggregate Functions)"></a>表聚合函数(Table Aggregate Functions)</h4><p>用户自定义表聚合函数(UDTAGG)可以把一行或多行数据(也就是一个表)聚合成另一张表，结果表中可以有多行多列。很明显，这就像表函数和聚合函数的结合体，是一个<strong>多对多</strong>的转换。</p>
<p>自定义表聚合函数需要继承抽象类 TableAggregateFunction。TableAggregateFunction 的结构和原理与 AggregateFunction 非常类似，同样有两个泛型参数&lt;T, ACC&gt;，用一个 ACC 类型的累加器(accumulator)来存储聚合的中间结果。聚合函数中必须实现的三个方法，在 TableAggregateFunction 中也必须对应实现：</p>
<p>createAccumulator()：创建累加器的方法，与 AggregateFunction 中用法相同。</p>
<p>accumulate()：聚合计算的核心方法，与 AggregateFunction 中用法相同。</p>
<p>emitValue()：所有输入行处理完成后，输出最终计算结果的方法。这个方法对应着 AggregateFunction 中的 getValue() 方法；区别在于 emitValue 没有输出类型，而输入参数有两个：第一个是 ACC 类型的累加器，第二个则是用于输出数据的收集器 out，它的类型为 Collect<T>。所以很明显，表聚合函数输出数据不是直接 return，而是调用 out.collect() 方法，调用多次就可以输出多行数据了；这一点与表函数非常相似。另外，emitValue() 在抽象类中也没有定义，无法override，必须手动实现。</T></p>
<p>表聚合函数得到的是一张表；在流处理中做持续查询，应该每次都会把这个表重新计算输出。如果输入一条数据后，只是对结果表里一行或几行进行了更新(Update)，这时我们重新计算整个表、全部输出显然就不够高效了。为了提高处理效率，TableAggregateFunction 还提供了一个 emitUpdateWithRetract() 方法，它可以在结果表发生变化时，以撤回(retract)老数据、发送新数据的方式增量地进行更新。如果同时定义了 emitValue() 和 emitUpdateWithRetract() 两个方法，在进行更新操作时会优先调用 emitUpdateWithRetract()。</p>
<p>表聚合函数相对比较复杂，它的一个典型应用场景就是 TopN 查询。比如我们希望选出 一组数据排序后的前两名，这就是最简单的 TOP-2 查询。没有现成的系统函数，那么我们就可以自定义一个表聚合函数来实现这个功能。在累加器中应该能够保存当前最大的两个值，每当来一条新数据就在 accumulate() 方法中进行比较更新，最终在 emitValue() 中调用两次 out.collect() 将前两名数据输出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">    env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    StreamTableEnvironment tableEnv = StreamTableEnvironment.create(env);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 自定义数据源，从流转换</span></span><br><span class="line">    SingleOutputStreamOperator&lt;Event&gt; eventStream = env.addSource(<span class="keyword">new</span> ClickSource())</span><br><span class="line">            .assignTimestampsAndWatermarks(WatermarkStrategy.&lt;Event&gt;forBoundedOutOfOrderness(Duration.ZERO)</span><br><span class="line">                    .withTimestampAssigner(<span class="keyword">new</span> SerializableTimestampAssigner&lt;Event&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Event element, <span class="keyword">long</span> recordTimestamp)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> element.timestamp;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将流转换成表</span></span><br><span class="line">    Table eventTable = tableEnv.fromDataStream(eventStream,</span><br><span class="line">            $(<span class="string">&quot;user&quot;</span>),</span><br><span class="line">            $(<span class="string">&quot;url&quot;</span>),</span><br><span class="line">            $(<span class="string">&quot;timestamp&quot;</span>).as(<span class="string">&quot;ts&quot;</span>),</span><br><span class="line">            $(<span class="string">&quot;rt&quot;</span>).rowtime());</span><br><span class="line">    tableEnv.createTemporaryView(<span class="string">&quot;EventTable&quot;</span>, eventTable);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 开滚动窗口聚合，得到每个用户在每个窗口中的浏览量</span></span><br><span class="line">    Table windowAggTable = tableEnv.sqlQuery(<span class="string">&quot;select user, count(url) as cnt, &quot;</span> +</span><br><span class="line">            <span class="string">&quot;window_end &quot;</span> +</span><br><span class="line">            <span class="string">&quot;from TABLE(&quot;</span> +</span><br><span class="line">            <span class="string">&quot;  TUMBLE( TABLE EventTable, DESCRIPTOR(rt), INTERVAL &#x27;10&#x27; SECOND )&quot;</span> +</span><br><span class="line">            <span class="string">&quot;)&quot;</span> +</span><br><span class="line">            <span class="string">&quot;group by user,&quot;</span> +</span><br><span class="line">            <span class="string">&quot;  window_start,&quot;</span> +</span><br><span class="line">            <span class="string">&quot;  window_end&quot;</span>);</span><br><span class="line">    tableEnv.createTemporaryView(<span class="string">&quot;AggTable&quot;</span>, windowAggTable);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 注册表聚合函数函数</span></span><br><span class="line">    tableEnv.createTemporarySystemFunction(<span class="string">&quot;Top2&quot;</span>, Top2.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 在Table API中调用函数</span></span><br><span class="line">  	<span class="comment">// 目前 SQL 中没有直接使用表聚合函数的方式，所以需要使用 Table API 的方式来调用</span></span><br><span class="line">    Table resultTable = tableEnv.from(<span class="string">&quot;AggTable&quot;</span>)</span><br><span class="line">            .groupBy($(<span class="string">&quot;window_end&quot;</span>))</span><br><span class="line">            .flatAggregate(call(<span class="string">&quot;Top2&quot;</span>, $(<span class="string">&quot;cnt&quot;</span>)).as(<span class="string">&quot;value&quot;</span>, <span class="string">&quot;rank&quot;</span>))</span><br><span class="line">            .select($(<span class="string">&quot;window_end&quot;</span>), $(<span class="string">&quot;value&quot;</span>), $(<span class="string">&quot;rank&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 输出到控制台</span></span><br><span class="line">    tableEnv.toChangelogStream(resultTable).print();</span><br><span class="line"></span><br><span class="line">    env.execute();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 聚合累加器的类型定义，包含最大的第一和第二两个数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Top2Accumulator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Long first;</span><br><span class="line">    <span class="keyword">public</span> Long second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义表聚合函数，查询一组数中最大的两个，返回值为(数值，排名)的二元组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Top2</span> <span class="keyword">extends</span> <span class="title">TableAggregateFunction</span>&lt;<span class="title">Tuple2</span>&lt;<span class="title">Long</span>, <span class="title">Integer</span>&gt;, <span class="title">Top2Accumulator</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Top2Accumulator <span class="title">createAccumulator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Top2Accumulator acc = <span class="keyword">new</span> Top2Accumulator();</span><br><span class="line">        acc.first = Long.MIN_VALUE;    <span class="comment">// 为方便比较，初始值给最小值</span></span><br><span class="line">        acc.second = Long.MIN_VALUE;</span><br><span class="line">        <span class="keyword">return</span> acc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每来一个数据调用一次，判断是否更新累加器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accumulate</span><span class="params">(Top2Accumulator acc, Long value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value &gt; acc.first) &#123;</span><br><span class="line">            acc.second = acc.first;</span><br><span class="line">            acc.first = value;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; acc.second) &#123;</span><br><span class="line">            acc.second = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出(数值，排名)的二元组，输出两行数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">emitValue</span><span class="params">(Top2Accumulator acc, Collector&lt;Tuple2&lt;Long, Integer&gt;&gt; out)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (acc.first != Long.MIN_VALUE) &#123;</span><br><span class="line">            out.collect(Tuple2.of(acc.first, <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (acc.second != Long.MIN_VALUE) &#123;</span><br><span class="line">            out.collect(Tuple2.of(acc.second, <span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SQL客户端"><a href="#SQL客户端" class="headerlink" title="SQL客户端"></a>SQL客户端</h3><p>有了Table API和SQL，我们就可以使用熟悉的SQL来编写查询语句进行流处理了。不过，这种方式还是将 SQL 语句嵌入到 Java/Scala 代码中进行的；另外，写完的代码后想要提交作业还需要使用工具进行打包。这都给 Flink 的使用设置了门槛，如果不是 Java/Scala 程序员，即使是非常熟悉 SQL 的工程师恐怕也会望而生畏了。</p>
<p>基于这样的考虑，Flink 为我们提供了一个工具来进行 Flink 程序的编写、测试和提交，这工具叫作 <strong>SQL 客户端</strong>。SQL 客户端提供了一个命令行交互界面(CLI)，我们可以在里面非常容易地编写 SQL 进行查询，就像使用 MySQL 一样；整个 Flink 应用编写、提交的过程全变成了写 SQL，不需要写一行 Java/Scala 代码。</p>
<p>具体使用流程如下：</p>
<p>(1)首先启动本地集群</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/start-cluster.sh</span><br></pre></td></tr></table></figure>

<p>(2)启动 Flink SQL 客户端</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/sql-client.sh</span><br></pre></td></tr></table></figure>

<p>SQL 客户端的启动脚本同样位于 Flink 的 bin 目录下。默认的启动模式是 embedded，也就是说客户端是一个嵌入在本地的进程，这是目前唯一支持的模式。未来会支持连接到远程 SQL 客户端的模式。</p>
<p>(3)设置运行模式</p>
<p>启动客户端后，就进入了命令行界面，这时就可以开始写 SQL 了。一般我们会在开始之前对环境做一些设置，比较重要的就是运行模式。首先是表环境的运行时模式，有<strong>流处理</strong>和<strong>批处理</strong>两个选项。默认为流处理：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flink SQL&gt; SET &#x27;execution.runtime-mode&#x27; = &#x27;streaming&#x27;;</span><br></pre></td></tr></table></figure>

<p>其次是 SQL 客户端的执行结果模式，主要有 table、changelog、tableau 三种，默认为 table 模式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flink SQL&gt; SET &#x27;sql-client.execution.result-mode&#x27; = &#x27;table&#x27;;</span><br></pre></td></tr></table></figure>

<p>table 模式就是最普通的表处理模式，结果会以逗号分隔每个字段；changelog 则是更新日志模式，会在数据前加上 <strong>+(表示插入)</strong> 或 <strong>-(表示撤回)</strong> 的前缀；而 tableau 则是经典的可视化表模式，结果会是一个虚线框的表格。</p>
<p>此外我们还可以做一些其它可选的设置，比如之前提到的空闲状态生存时间(TTL)：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flink SQL&gt; SET &#x27;table.exec.state.ttl&#x27; = &#x27;1000&#x27;;</span><br></pre></td></tr></table></figure>

<p>除了在命令行进行设置，我们也可以直接在 SQL 客户端的配置文件 sql-cli-defaults.yaml 中进行各种配置，甚至还可以在这个 yaml 文件里预定义表、函数和 catalog。关于配置文件的更多用法，可以查阅官网的详细说明。</p>
<p>(4)执行 SQL 查询</p>
<p>接下来就可以愉快的编写 SQL 语句了，这跟操作 MySQL、Oracle 等关系型数据库没什么区别。</p>
<p>在 SQL 客户端中，每定义一个 SQL 查询，就会把它作为一个 Flink 作业提交到集群上执行。所以通过这种方式，我们可以快速地对流处理程序进行开发测试。</p>
<h3 id="连接到外部系统"><a href="#连接到外部系统" class="headerlink" title="连接到外部系统"></a>连接到外部系统</h3><p>在 Table API 和 SQL 编写的 Flink 程序中，可以在创建表的时候用 WITH 子句指定连接器 (connector)，这样就可以连接到外部系统进行数据交互了。</p>
<p>架构中的 TableSource 负责从外部系统中读取数据并转换成表，TableSink 则负责将结果表写入外部系统。在 Flink 1.13 的 API 调用中，已经不去区分 TableSource 和 TableSink，我们只要建立到外部系统的连接并创建表就可以，Flink 自动会从程序的处理逻辑中解析出它们的用途。</p>
<p>Flink的Table API和SQL支持了各种不同的连接器。当然，最简单的其实就是上一节中提到的连接到控制台打印输出：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ResultTable (</span><br><span class="line">   <span class="keyword">user</span> STRING,</span><br><span class="line">   cnt <span class="type">BIGINT</span></span><br><span class="line"><span class="keyword">WITH</span> (</span><br><span class="line"><span class="string">&#x27;connector&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;print&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这里只需要在 WITH 中定义 connector 为 print 就可以了。而对于其它的外部系统，则需要增加一些配置项。</p>
<h4 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h4><p><strong>引入依赖</strong></p>
<p>Kafka 的 SQL 连接器可以从 Kafka 的主题(topic)读取数据转换成表，也可以将表数据写入 Kafka 的主题。换句话说，创建表的时候指定连接器为 Kafka，则这个表既可以作为输入表，也可以作为输出表。</p>
<p>想要在 Flink 程序中使用 Kafka 连接器，需要引入如下依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-kafka_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里引入的 Flink 和 Kafka 的连接器，与之前 DataStream API 中引入的连接器是一样的。如果想在 SQL 客户端里使用 Kafka 连接器，还需要下载对应的 jar 包放到 lib 目录下。</p>
<p>另外，Flink 为各种连接器提供了一系列的**表格式(table formats)**，比如 CSV、JSON、 Avro、Parquet 等等。这些表格式定义了底层存储的二进制数据和表的列之间的转换方式，相当于表的序列化工具。对于 Kafka 而言，CSV、JSON、Avro 等主要格式都是支持的，根据 Kafka 连接器中配置的格式，我们可能需要引入对应的依赖支持。以 CSV 为例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-csv<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>由于 SQL 客户端中已经内置了 CSV、JSON 的支持，因此使用时无需专门引入；而对于没有内置支持的格式(比如 Avro)，则仍然要下载相应的 jar 包。关于连接器的格式细节详见官网说明。</p>
<p><strong>创建连接到 Kafka 的表</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> KafkaTable (</span><br><span class="line">  `<span class="keyword">user</span>` STRING,</span><br><span class="line">  `url` STRING,</span><br><span class="line">  `ts` <span class="type">TIMESTAMP</span>(<span class="number">3</span>) METADATA <span class="keyword">FROM</span> <span class="string">&#x27;timestamp&#x27;</span></span><br><span class="line">) <span class="keyword">WITH</span> (</span><br><span class="line">  <span class="string">&#x27;connector&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;kafka&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;topic&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;events&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;properties.bootstrap.servers&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;localhost:9092&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;properties.group.id&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;testGroup&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;scan.startup.mode&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;earliest-offset&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;format&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;csv&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这里定义了 Kafka 连接器对应的主题(topic)，Kafka 服务器，消费者组 ID，消费者起始模式以及表格式。需要特别说明的是，在 KafkaTable 的字段中有一个 ts，它的声明中用到了 METADATA FROM，这是表示一个元数据列(metadata column)，它是由Kafka连接器的元数据 timestamp 生成的。<strong>这里的 timestamp 其实就是 Kafka 中数据自带的时间戳</strong>，我们把它直接作为元数据提取出来，转换成一个新的字段 ts。</p>
<p><strong>Upsert Kafka</strong></p>
<p>常情况下，Kafka 作为保持数据顺序的消息队列，读取和写入都应该是流式的数据，对应在表中就是仅追加(append-only)模式。如果我们想要将有更新操作(比如分组聚合)的结果表写入 Kafka，就会因为 Kafka 无法识别撤回(retract)或更新插入(upsert)消息而导致异常。</p>
<p>为了解决这个问题，Flink专门增加了一个<strong>更新插入Kafka(Upsert Kafka)连接器</strong>。这个连接器支持以更新插入(UPSERT)的方式向 Kafka 的 topic 中读写数据。</p>
<p>具体来说，Upsert Kafka 连接器处理的是更新日志(changlog)流。如果作为 TableSource， 连接器会将读取到的topic中的数据(key, value)，解释为对当前key的数据值的更新(UPDATE)， 也就是查找动态表中 key 对应的一行数据，将 value 更新为最新的值；因为是 Upsert 操作，所以如果没有 key 对应的行，那么也会执行插入(INSERT)操作。另外，如果遇到 value 为空 (null)，连接器就把这条数据理解为对相应 key 那一行的删除(DELETE)操作。</p>
<p>如果作为 TableSink，Upsert Kafka 连接器会将有更新操作的结果表，转换成更新日志 (changelog)流。如果遇到插入(INSERT)或者更新后(UPDATE_AFTER)的数据，对应的是一个添加(add)消息，那么就直接正常写入 Kafka 主题；如果是删除(DELETE)或者更新前的数据，对应是一个撤回(retract)消息，那么就把 value 为空(null)的数据写入 Kafka。 由于 Flink 是根据键(key)的值对数据进行分区的，这样就可以保证同一个 key 上的更新和删除消息都会落到同一个分区中。</p>
<p>下面是一个创建和使用 Upsert Kafka 表的例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> pageviews_per_region (</span><br><span class="line">  user_region STRING,</span><br><span class="line">  pv <span class="type">BIGINT</span>,</span><br><span class="line">  uv <span class="type">BIGINT</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (user_region) <span class="keyword">NOT</span> ENFORCED</span><br><span class="line">) <span class="keyword">WITH</span> (</span><br><span class="line">  <span class="string">&#x27;connector&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;upsert-kafka&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;topic&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;pageviews_per_region&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;properties.bootstrap.servers&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;...&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;key.format&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;avro&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;value.format&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;avro&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> pageviews (</span><br><span class="line">  user_id <span class="type">BIGINT</span>,</span><br><span class="line">  page_id <span class="type">BIGINT</span>,</span><br><span class="line">  viewtime <span class="type">TIMESTAMP</span>,</span><br><span class="line">  user_region STRING,</span><br><span class="line">  WATERMARK <span class="keyword">FOR</span> viewtime <span class="keyword">AS</span> viewtime <span class="operator">-</span> <span class="type">INTERVAL</span> <span class="string">&#x27;2&#x27;</span> <span class="keyword">SECOND</span></span><br><span class="line">) <span class="keyword">WITH</span> (</span><br><span class="line">  <span class="string">&#x27;connector&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;kafka&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;topic&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;pageviews&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;properties.bootstrap.servers&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;...&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;format&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;json&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 计算 pv、uv 并插入到 upsert-kafka 表中 </span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> pageviews_per_region <span class="keyword">SELECT</span></span><br><span class="line">  user_region,</span><br><span class="line">  <span class="built_in">COUNT</span>(<span class="operator">*</span>),</span><br><span class="line">  <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> user_id)</span><br><span class="line"><span class="keyword">FROM</span> pageviews</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> user_region;</span><br></pre></td></tr></table></figure>

<p>这里我们从 Kafka 表 pageviews 中读取数据，统计每个区域的 PV(全部浏览量)和 UV (对用户去重)，这是一个分组聚合的更新查询，得到的结果表会不停地更新数据。为了将结果表写入Kafka的pageviews_per_region主题，我们定义了一个Upsert Kafka表，它的字段中需要用PRIMARY KEY来指定主键，并且在WITH子句中分别指定key和value的序列化格式。</p>
<h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><p>另一类非常常见的外部系统就是文件系统(File System)了。Flink 提供了文件系统的连接器，支持从<strong>本地</strong>或者<strong>分布式的文件系统</strong>中读写数据。这个连接器是内置在 Flink 中的，所以使用它并不需要额外引入依赖。</p>
<p>下面是一个连接到文件系统的示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> MyTable (</span><br><span class="line">  column_name1 <span class="type">INT</span>,</span><br><span class="line">  column_name2 STRING,</span><br><span class="line">  ...</span><br><span class="line">  part_name1 <span class="type">INT</span>,</span><br><span class="line">  part_name2 STRING</span><br><span class="line">) </span><br><span class="line">PARTITIONED <span class="keyword">BY</span> (part_name1, part_name2) </span><br><span class="line"><span class="keyword">WITH</span> (</span><br><span class="line">  <span class="string">&#x27;connector&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;filesystem&#x27;</span>, <span class="comment">-- 连接器类型</span></span><br><span class="line">  <span class="string">&#x27;path&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;...&#x27;</span>, <span class="comment">-- 文件路径</span></span><br><span class="line">  <span class="string">&#x27;format&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;...&#x27;</span> <span class="comment">-- 文件格式 </span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这里在 WITH 前使用了 PARTITIONED BY 对数据进行了分区操作。文件系统连接器支持对分区文件的访问。</p>
<h4 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h4><p>关系型数据表本身就是 SQL 最初应用的地方，所以我们也会希望能直接向关系型数据库中读写表数据。Flink 提供的 JDBC 连接器可以通过 JDBC 驱动程序(driver)向任意的关系型数据库<strong>读写</strong>数据，比如 MySQL、PostgreSQL、Derby 等。</p>
<p>作为 TableSink 向数据库写入数据时，运行的模式取决于创建表的 DDL 是否定义了主键 (primary key)。如果有主键，那么 JDBC 连接器就将以更新插入(Upsert)模式运行，可以向外部数据库发送按照指定键(key)的更新(UPDATE)和删除(DELETE)操作；如果没有定义主键，那么就将在追加(Append)模式下运行，不支持更新和删除操作。</p>
<p><strong>引入依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-jdbc_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此外，为了连接到特定的数据库，我们还用引入相关的驱动器依赖，比如 MySQL：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.38<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>创建 JDBC 表</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建一张连接到MySQL的表 </span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> MyTable (</span><br><span class="line">  id <span class="type">BIGINT</span>,</span><br><span class="line">  name STRING,</span><br><span class="line">  age <span class="type">INT</span>,</span><br><span class="line">  status <span class="type">BOOLEAN</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (id) <span class="keyword">NOT</span> ENFORCED</span><br><span class="line">) <span class="keyword">WITH</span> (</span><br><span class="line">	<span class="string">&#x27;connector&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;jdbc&#x27;</span>,</span><br><span class="line">	<span class="string">&#x27;url&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;jdbc:mysql://localhost:3306/mydatabase&#x27;</span>,</span><br><span class="line">	<span class="string">&#x27;table-name&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;users&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将另一张表 T 的数据写入到 MyTable 表中 </span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> MyTable</span><br><span class="line"><span class="keyword">SELECT</span> id, name, age, status <span class="keyword">FROM</span> T;</span><br></pre></td></tr></table></figure>

<p>这里创建表的 DDL 中定义了主键，所以数据会以 Upsert 模式写入到 MySQL 表中；而到 MySQL 的连接，是通过 WITH 子句中的 url 定义的。要注意写入 MySQL 中真正的表名称是 users，而 MyTable 是注册在 Flink 表环境中的表。</p>
<h4 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h4><p>Elasticsearch 作为分布式搜索分析引擎，在大数据应用中有非常多的场景。Flink 提供的 Elasticsearch 的 SQL 连接器<strong>只能作为 TableSink</strong>，可以将表数据写入 Elasticsearch 的索引(index)。 Elasticsearch连接器的使用与JDBC连接器非常相似，写入数据的模式同样是由创建表的DDL 中是否有主键定义决定的。</p>
<p><strong>引入依赖</strong></p>
<p>具体的依赖与 Elasticsearch 服务器的版本有关，对于 6.x 版本引入依赖如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-elasticsearch6_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对于 Elasticsearch 7 以上的版本，引入的依赖则是：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-elasticsearch7_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>创建连接到 Elasticsearch 的表</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建一张连接到Elasticsearch的表 </span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> MyTable (</span><br><span class="line">  user_id STRING,</span><br><span class="line">  user_name STRING</span><br><span class="line">  uv <span class="type">BIGINT</span>,</span><br><span class="line">  pv <span class="type">BIGINT</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (user_id) <span class="keyword">NOT</span> ENFORCED</span><br><span class="line">) <span class="keyword">WITH</span> (</span><br><span class="line">  <span class="string">&#x27;connector&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;elasticsearch-7&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;hosts&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;http://localhost:9200&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;index&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;users&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这里定义了主键，所以会以更新插入(Upsert)模式向 Elasticsearch 写入数据。</p>
<h4 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h4><p>作为高性能、可伸缩的分布式列存储数据库，HBase 在大数据分析中是一个非常重要的工 具。Flink 提供的 HBase 连接器支持面向 HBase 集群的<strong>读写</strong>操作。</p>
<p>在流处理场景下，连接器作为 TableSink 向 HBase 写入数据时，采用的始终是更新插入 (Upsert)模式。也就是说，HBase 要求连接器必须通过定义的主键(primary key)来发送更新日志(changelog)。所以在创建表的 DDL 中，我们必须要定义行键(rowkey)字段，并将它声明为主键；如果没有用 PRIMARY KEY 子句声明主键，连接器会默认把 rowkey 作为主键。</p>
<p><strong>引入依赖</strong></p>
<p>想要在 Flink 程序中使用 HBase 连接器，需要引入对应的依赖。目前 Flink 只对 HBase 的 1.4.x 和 2.2.x 版本提供了连接器支持，而引入的依赖也应该与具体的 HBase 版本有关。对于 1.4 版本引入依赖如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-hbase-1.4_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对于 HBase 2.2 版本，引入的依赖则是：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-hbase-2.2_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>创建连接到 HBase 的表</strong></p>
<p>由于 HBase 并不是关系型数据库，因此转换为 Flink SQL 中的表会稍有一些麻烦。在 DDL 创建出的 HBase 表中，所有的列族(column family)都必须声明为 ROW 类型，在表中占据一个字段；而每个 family 中的列(column qualifier)则对应着 ROW 里的嵌套字段。我们不需要将 HBase 中所有的 family 和 qualifier 都在 Flink SQL 的表中声明出来，只要把那些在查询中用到的声明出来就可以了。</p>
<p>除了所有 ROW 类型的字段(对应着 HBase 中的 family)，表中还应有一个原子类型的字段，它就会被识别为 HBase 的 rowkey。在表中这个字段可以任意取名，不一定非要叫 rowkey。</p>
<p>下面是一个具体示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建一张连接到HBase的表 </span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> MyTable (</span><br><span class="line"> rowkey <span class="type">INT</span>,</span><br><span class="line"> family1 <span class="type">ROW</span><span class="operator">&lt;</span>q1 <span class="type">INT</span><span class="operator">&gt;</span>,</span><br><span class="line"> family2 <span class="type">ROW</span><span class="operator">&lt;</span>q2 STRING, q3 <span class="type">BIGINT</span><span class="operator">&gt;</span>,</span><br><span class="line"> family3 <span class="type">ROW</span><span class="operator">&lt;</span>q4 <span class="keyword">DOUBLE</span>, q5 <span class="type">BOOLEAN</span>, q6 STRING<span class="operator">&gt;</span>,</span><br><span class="line"> <span class="keyword">PRIMARY</span> KEY (rowkey) <span class="keyword">NOT</span> ENFORCED</span><br><span class="line">) <span class="keyword">WITH</span> (</span><br><span class="line"> <span class="string">&#x27;connector&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;hbase-1.4&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;table-name&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;mytable&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;zookeeper.quorum&#x27;</span> <span class="operator">=</span> <span class="string">&#x27;localhost:2181&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 假设表 T 的字段结构是 [rowkey, f1q1, f2q2, f2q3, f3q4, f3q5, f3q6]</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> MyTable</span><br><span class="line"><span class="keyword">SELECT</span> rowkey, <span class="type">ROW</span>(f1q1), <span class="type">ROW</span>(f2q2, f2q3), <span class="type">ROW</span>(f3q4, f3q5, f3q6) <span class="keyword">FROM</span> T;</span><br></pre></td></tr></table></figure>

<h4 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h4><p>Apache Hive作为一个基于Hadoop的数据仓库基础框架，可以说已经成为了进行海量数据分析的核心组件。Hive 支持类 SQL 的查询语言，可以用来方便对数据进行处理和统计分析， 而且基于 HDFS 的数据存储有非常好的可扩展性，是存储分析超大量数据集的唯一选择。Hive 的主要缺点在于查询的延迟很高，几乎成了离线分析的代言人。而 Flink 的特点就是实时性强， 所以 Flink SQL 与 Hive 的结合势在必行。</p>
<p>Flink 与 Hive 的集成比较特别。Flink 提供了 Hive 目录(HiveCatalog)功能，允许使用 Hive 的元存储(Metastore)来管理 Flink 的元数据。这带来的好处体现在两个方面：</p>
<p>(1)Metastore 可以作为一个持久化的目录，因此使用 HiveCatalog 可以跨会话存储 Flink 特定的元数据。这样一来，我们在 HiveCatalog 中执行执行创建 Kafka 表或者 ElasticSearch 表， 就可以把它们的元数据持久化存储在 Hive 的 Metastore 中；对于不同的作业会话就不需要重复创建了，直接在 SQL 查询中重用就可以。</p>
<p>(2)使用 HiveCatalog，Flink 可以作为读写 Hive 表的替代分析引擎。这样一来，在 Hive 中进行批处理会更加高效；与此同时，也有了连续在 Hive 中读写数据、进行流处理的能力，这也使得实时数仓(real-time data warehouse)成为了可能。</p>
<p>HiveCatalog 被设计为开箱即用，与现有的 Hive 配置完全兼容，我们不需要做任何的修改与调整就可以直接使用。注意只有 Blink 的计划器(planner)提供了 Hive 集成的支持，所以需要在使用 Flink SQL 时选择 Blink planner。下面我们就来看以下与 Hive 集成的具体步骤。</p>
<p><strong>引入依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Flink 的 Hive 连接器--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-hive_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Hive 依赖 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hive<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hive-exec<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;hive.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>建议不要把这些依赖打包到结果 jar 文件中，而是在运行时的集群环境中为不同的 Hive 版本添加不同的依赖支持。具体版本对应的依赖关系，可以查询官网说明。</p>
<p><strong>连接到 Hive</strong></p>
<p>在 Flink 中连接 Hive，是通过在表环境中配置 HiveCatalog 来实现的。需要说明的是，配置 HiveCatalog 本身并不需要限定使用哪个 planner，不过对 Hive 表的读写操作只有 Blink 的 planner 才支持。所以一般我们需要将表环境的 planner 设置为 Blink。</p>
<p>下面是代码中配置 Catalog 的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">EnvironmentSettings settings = EnvironmentSettings.newInstance().useBlinkPlanner().build();</span><br><span class="line">TableEnvironment tableEnv = TableEnvironment.create(settings);</span><br><span class="line"></span><br><span class="line">String name = <span class="string">&quot;myhive&quot;</span>;</span><br><span class="line">String defaultDatabase = <span class="string">&quot;mydatabase&quot;</span>;</span><br><span class="line">String hiveConfDir = <span class="string">&quot;/opt/hive-conf&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 HiveCatalog，并在表环境中注册</span></span><br><span class="line">HiveCatalog hive = <span class="keyword">new</span> HiveCatalog(name, defaultDatabase, hiveConfDir);</span><br><span class="line">tableEnv.registerCatalog(<span class="string">&quot;myhive&quot;</span>, hive);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 HiveCatalog 作为当前会话的 catalog </span></span><br><span class="line">tableEnv.useCatalog(<span class="string">&quot;myhive&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>当然，我们也可以直接启动 SQL 客户端，用 CREATE CATALOG 语句直接创建 HiveCatalog：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Flink SQL&gt; create catalog myhive with (&#x27;type&#x27; = &#x27;hive&#x27;, &#x27;hive-conf-dir&#x27; = &#x27;/opt/hive-conf&#x27;);</span><br><span class="line">[INFO] Execute statement succeed.</span><br><span class="line"></span><br><span class="line">Flink SQL&gt; use catalog myhive;</span><br><span class="line">[INFO] Execute statement succeed.</span><br></pre></td></tr></table></figure>

<p><strong>设置 SQL 方言</strong></p>
<p>我们知道，Hive 内部提供了类 SQL 的查询语言，不过语法细节与标准 SQL 会有一些出入， 相当于是 SQL 的一种方言(dialect)。为了提高与 Hive 集成时的兼容性，Flink SQL 提供了 一个非常有趣而强大的功能：可以使用方言来编写 SQL 语句。换句话说，我们可以直接在 Flink 中写 Hive SQL 来操作 Hive 表，这无疑给我们的读写处理带来了极大的方便。</p>
<p>Flink 目前支持两种 SQL 方言的配置：default 和 hive。所谓的 default 就是 Flink SQL 默认 的SQL语法了。我们需要先切换到hive方言，然后才能使用Hive SQL的语法。具体设置可以分为 SQL 和 Table API 两种方式。</p>
<p>(1)SQL 中设置</p>
<p>我们可以通过配置 table.sql-dialect 属性来设置 SQL 方言：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set table.sql-dialect=hive;</span><br></pre></td></tr></table></figure>

<p>当然，我们可以在代码中执行上面的 SET 语句，也可以直接启动 SQL 客户端来运行。如果使用 SQL 客户端，我们还可以在配置文件 sql-cli-defaults.yaml 中通过configuration模块来设置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">execution:</span></span><br><span class="line">  <span class="attr">planner:</span> <span class="string">blink</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">batch</span></span><br><span class="line">  <span class="attr">result-mode:</span> <span class="string">table</span></span><br><span class="line"><span class="attr">configuration:</span></span><br><span class="line">  <span class="attr">table.sql-dialect:</span> <span class="string">hive</span></span><br></pre></td></tr></table></figure>

<p>(2)Table API 中设置</p>
<p>另外一种方式就是在代码中，直接使用 Table API 获取表环境的配置项来进行设置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置 hive 方言 </span></span><br><span class="line">tableEnv.getConfig().setSqlDialect(SqlDialect.HIVE); </span><br><span class="line"><span class="comment">// 配置 default 方言 </span></span><br><span class="line">tableEnv.getConfig().setSqlDialect(SqlDialect.DEFAULT);</span><br></pre></td></tr></table></figure>

<p><strong>读写 Hive 表</strong></p>
<p>有了 SQL 方言的设置，我们就可以很方便的在 Flink 中创建 Hive 表并进行读写操作了。 Flink 支持以<strong>批处理</strong>和<strong>流处理</strong>模式向 Hive 中读写数据。在批处理模式下，Flink 会在执行查询语句时对 Hive 表进行一次性读取，在作业完成时将结果数据向 Hive 表进行一次性写入；而在流处理模式下，Flink 会持续监控 Hive 表，在新数据可用时增量读取，也可以持续写入新数据并增量式地让它们见。</p>
<p>更灵活的是，我们可以随时切换 SQL 方言，从其它数据源(例如 Kafka)读取数据、经转换后再写入 Hive。下面是以纯 SQL 形式编写的一个示例，我们可以启动 SQL 客户端来运行：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置 SQL 方言为 hive，创建 Hive 表 </span></span><br><span class="line"><span class="keyword">SET</span> table.sql<span class="operator">-</span>dialect<span class="operator">=</span>hive;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> hive_table (</span><br><span class="line">  user_id STRING,</span><br><span class="line">  order_amount <span class="keyword">DOUBLE</span></span><br><span class="line">) </span><br><span class="line">PARTITIONED <span class="keyword">BY</span> (dt STRING, hr STRING) </span><br><span class="line">STORED <span class="keyword">AS</span> parquet </span><br><span class="line">TBLPROPERTIES (</span><br><span class="line">  <span class="string">&#x27;partition.time-extractor.timestamp-pattern&#x27;</span><span class="operator">=</span><span class="string">&#x27;$dt $hr:00:00&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;sink.partition-commit.trigger&#x27;</span><span class="operator">=</span><span class="string">&#x27;partition-time&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;sink.partition-commit.delay&#x27;</span><span class="operator">=</span><span class="string">&#x27;1 h&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;sink.partition-commit.policy.kind&#x27;</span><span class="operator">=</span><span class="string">&#x27;metastore,success-file&#x27;</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 设置 SQL 方言为 default，创建 Kafka 表 </span></span><br><span class="line"><span class="keyword">SET</span> table.sql<span class="operator">-</span>dialect<span class="operator">=</span><span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> kafka_table (</span><br><span class="line">  user_id STRING,</span><br><span class="line">  order_amount <span class="keyword">DOUBLE</span>,</span><br><span class="line">  log_ts <span class="type">TIMESTAMP</span>(<span class="number">3</span>),</span><br><span class="line">  WATERMARK <span class="keyword">FOR</span> log_ts <span class="keyword">AS</span> log_ts <span class="operator">-</span> <span class="type">INTERVAL</span> <span class="string">&#x27;5&#x27;</span> <span class="keyword">SECOND</span> <span class="comment">-- 定义水位线 </span></span><br><span class="line">) <span class="keyword">WITH</span> (...);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 将 Kafka 中读取的数据经转换后写入 Hive</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> hive_table</span><br><span class="line"><span class="keyword">SELECT</span> user_id, order_amount, DATE_FORMAT(log_ts, <span class="string">&#x27;yyyy-MM-dd&#x27;</span>), DATE_FORMAT(log_ts, <span class="string">&#x27;HH&#x27;</span>)</span><br><span class="line"><span class="keyword">FROM</span> kafka_table;</span><br></pre></td></tr></table></figure>

<p>这里我们创建 Hive 表时设置了通过分区时间来触发提交的策略。将 Kafka 中读取的数据经转换后写入 Hive，这是一个流处理的 Flink SQL 程序。</p>
<h2 id="Flink-CEP"><a href="#Flink-CEP" class="headerlink" title="Flink CEP"></a>Flink CEP</h2><p>在 Flink 的学习过程中，从基本原理和核心层 DataStream API 到底层的处理函数、再到应用层的Table API和SQL，我们已经掌握了Flink编程的各种手段，可以应对实际应用开发的各种需求了。</p>
<p>在大数据分析领域，一大类需求就是诸如 PV、UV 这样的统计指标，我们往往可以直接写 SQL 搞定；对于比较复杂的业务逻辑，SQL 中可能没有对应功能的内置函数，那么我们也可以使用 DataStream API，利用状态编程来进行实现。不过在实际应用中，还有一类需求是要检测以特定顺序先后发生的一组事件，进行统计或做报警提示，这就比较麻烦了。例如，网站做用户管理，可能需要检测连续登录失败事件的发生，这是个组合事件，其实就是登录失败和登录失败的组合；电商网站可能需要检测用户下单支付行为，这也是组合事件，下单事件之后一段时间内又会有支付事件到来，还包括了时间上的限制。</p>
<p>类似的多个事件的组合，我们把它叫作复杂事件。对于复杂时间的处理，由于涉及到事件的严格顺序，有时还有时间约束，我们很难直接用 SQL 或者 DataStream API 来完成。于是只好放大招——派底层的处理函数(process function)上阵了。处理函数确实可以搞定这些需求，不过对于非常复杂的组合事件，我们可能需要设置很多状态、定时器，并在代码中定义各种条件分支(if-else)逻辑来处理，复杂度会非常高，很可能会使代码失去可读性。怎样处理这类复杂事件呢？Flink 为我们提供了专门用于处理复杂事件的库——CEP，可以让我们更加轻松地解决这类棘手的问题。这在企业的实时风险控制中有非常重要的作用。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>所谓 CEP，其实就是复杂事件处理(Complex Event Processing)的缩写；而 Flink CEP，就是 Flink 实现的一个用于复杂事件处理的库(library)。</p>
<p>那到底什么是复杂事件处理呢？就是可以在事件流里，检测到特定的事件组合并进行处理，比如说连续登录失败，或者订单支付超时等等。</p>
<p>具体的处理过程是，把事件流中的一个个简单事件，通过一定的规则匹配组合起来，这就是复杂事件；然后基于这些满足规则的一组组复杂事件进行转换处理，得到想要的结果进行输出。</p>
<p>总结起来，复杂事件处理(CEP)的流程可以分成三个步骤：</p>
<p>(1)定义一个匹配规则</p>
<p>(2)将匹配规则应用到事件流上，检测满足规则的复杂事件</p>
<p>(3)对检测到的复杂事件进行处理，得到结果进行输出</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-07-22%20%E4%B8%8B%E5%8D%885.44.19.png" alt="截屏2022-07-22 下午5.44.19"></p>
<p>如图 12-1 所示，输入是不同形状的事件流，我们可以定义一个匹配规则：在圆形后面紧跟着三角形。那么将这个规则应用到输入流上，就可以检测到三组匹配的复杂事件。它们构成了一个新的复杂事件流，流中的数据就变成了一组一组的复杂事件，每个数据都包含了一 个圆形和一个三角形。接下来，我们就可以针对检测到的复杂事件，处理之后输出一个提示或报警信息了。</p>
<p>所以，CEP 是针对流处理而言的，分析的是低延迟、频繁产生的事件流。它的主要目的，就是在无界流中检测出特定的数据组合，让我们有机会掌握数据中重要的高阶特征。</p>
<h4 id="模式-Pattern"><a href="#模式-Pattern" class="headerlink" title="模式(Pattern)"></a>模式(Pattern)</h4><p>CEP 的第一步所定义的匹配规则，我们可以把它叫作模式(Pattern)。模式的定义主要就是两部分内容：</p>
<p><strong>每个简单事件的特征</strong></p>
<p><strong>简单事件之间的组合关系</strong> </p>
<p>当然，我们也可以进一步扩展模式的功能。比如，匹配检测的时间限制；每个简单事件是否可以重复出现；对于事件可重复出现的模式，遇到一个匹配后是否跳过后面的匹配；等等。 所谓事件之间的组合关系，一般就是定义谁后面接着是谁，也就是事件发生的顺序。 我们把它叫作近邻关系。可以定义严格的近邻关系，也就是两个事件之前不能有任何其他事件；也可以定义宽松的近邻关系，即只要前后顺序正确即可，中间可以有其他事件。另外，还可以反向定义，也就是谁后面不能跟着谁。</p>
<p>CEP 做的事其实就是在流上进行模式匹配。根据模式的近邻关系条件不同，可以检测连续的事件或不连续但先后发生的事件；模式还可能有时间的限制，如果在设定时间范围内没有满足匹配条件，就会导致模式匹配超时(timeout)。</p>
<p>Flink CEP 为我们提供了丰富的 API，可以实现上面关于模式的所有功能，这套 API 就叫作模式API(Pattern API)。</p>
<h3 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h3><p><strong>引入依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-cep_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>为了精简和避免依赖冲突，Flink 会保持尽量少的核心依赖。所以核心依赖中并不包括任何的连接器(conncetor)和库，这里的库就包括了 SQL、CEP 以及 ML 等等。所以如果想要在 Flink 集群中提交运行 CEP 作业，应该向 Flink SQL 那样将依赖的 jar 包放在/lib 目录下。从这个角度来看，Flink CEP 和 Flink SQL 一样，都是最顶层的应用级 API。</p>
<p><strong>简单案例</strong></p>
<p>接下来我们考虑一个具体的需求：检测用户行为，如果连续三次登录失败，就输出报警信息。很显然，这是一个复杂事件的检测处理，我们可以使用 Flink CEP 来实现。</p>
<p>我们首先定义数据的类型。这里的用户行为不再是之前的访问事件 Event 了，所以应该单独定义一个登录事件 POJO 类。具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginEvent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String userId;</span><br><span class="line">    <span class="keyword">public</span> String ipAddress;</span><br><span class="line">    <span class="keyword">public</span> String eventType;</span><br><span class="line">    <span class="keyword">public</span> Long timestamp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoginEvent</span><span class="params">(String userId, String ipAddress, String eventType, Long timestamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userId = userId;</span><br><span class="line">        <span class="keyword">this</span>.ipAddress = ipAddress;</span><br><span class="line">        <span class="keyword">this</span>.eventType = eventType;</span><br><span class="line">        <span class="keyword">this</span>.timestamp = timestamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoginEvent</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;LoginEvent&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;userId=&#x27;&quot;</span> + userId + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, ipAddress=&#x27;&quot;</span> + ipAddress + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, eventType=&#x27;&quot;</span> + eventType + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, timestamp=&quot;</span> + timestamp +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginFailDetectExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 获取登录事件流，并提取时间戳、生成水位线</span></span><br><span class="line">        KeyedStream&lt;LoginEvent, String&gt; stream = env</span><br><span class="line">                .fromElements(</span><br><span class="line">                        <span class="keyword">new</span> LoginEvent(<span class="string">&quot;user_1&quot;</span>, <span class="string">&quot;192.168.0.1&quot;</span>, <span class="string">&quot;fail&quot;</span>, <span class="number">2000L</span>),</span><br><span class="line">                        <span class="keyword">new</span> LoginEvent(<span class="string">&quot;user_1&quot;</span>, <span class="string">&quot;192.168.0.2&quot;</span>, <span class="string">&quot;fail&quot;</span>, <span class="number">3000L</span>),</span><br><span class="line">                        <span class="keyword">new</span> LoginEvent(<span class="string">&quot;user_2&quot;</span>, <span class="string">&quot;192.168.1.29&quot;</span>, <span class="string">&quot;fail&quot;</span>, <span class="number">4000L</span>),</span><br><span class="line">                        <span class="keyword">new</span> LoginEvent(<span class="string">&quot;user_1&quot;</span>, <span class="string">&quot;171.56.23.10&quot;</span>, <span class="string">&quot;fail&quot;</span>, <span class="number">5000L</span>),</span><br><span class="line">                        <span class="keyword">new</span> LoginEvent(<span class="string">&quot;user_2&quot;</span>, <span class="string">&quot;192.168.1.29&quot;</span>, <span class="string">&quot;fail&quot;</span>, <span class="number">7000L</span>),</span><br><span class="line">                        <span class="keyword">new</span> LoginEvent(<span class="string">&quot;user_2&quot;</span>, <span class="string">&quot;192.168.1.29&quot;</span>, <span class="string">&quot;fail&quot;</span>, <span class="number">8000L</span>),</span><br><span class="line">                        <span class="keyword">new</span> LoginEvent(<span class="string">&quot;user_2&quot;</span>, <span class="string">&quot;192.168.1.29&quot;</span>, <span class="string">&quot;success&quot;</span>, <span class="number">6000L</span>)</span><br><span class="line">                )</span><br><span class="line">                .assignTimestampsAndWatermarks(</span><br><span class="line">                        WatermarkStrategy.&lt;LoginEvent&gt;forBoundedOutOfOrderness(Duration.ofSeconds(<span class="number">3</span>))</span><br><span class="line">                                .withTimestampAssigner(</span><br><span class="line">                                        <span class="keyword">new</span> SerializableTimestampAssigner&lt;LoginEvent&gt;() &#123;</span><br><span class="line">                                            <span class="meta">@Override</span></span><br><span class="line">                                            <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(LoginEvent loginEvent, <span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">                                                <span class="keyword">return</span> loginEvent.timestamp;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                )</span><br><span class="line">                )</span><br><span class="line">                .keyBy(r -&gt; r.userId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 定义Pattern，连续的三个登录失败事件</span></span><br><span class="line">        Pattern&lt;LoginEvent, LoginEvent&gt; pattern = Pattern.&lt;LoginEvent&gt;begin(<span class="string">&quot;first&quot;</span>)    <span class="comment">// 以第一个登录失败事件开始</span></span><br><span class="line">                .where(<span class="keyword">new</span> SimpleCondition&lt;LoginEvent&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(LoginEvent loginEvent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> loginEvent.eventType.equals(<span class="string">&quot;fail&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .next(<span class="string">&quot;second&quot;</span>)    <span class="comment">// 接着是第二个登录失败事件</span></span><br><span class="line">                .where(<span class="keyword">new</span> SimpleCondition&lt;LoginEvent&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(LoginEvent loginEvent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> loginEvent.eventType.equals(<span class="string">&quot;fail&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .next(<span class="string">&quot;third&quot;</span>)     <span class="comment">// 接着是第三个登录失败事件</span></span><br><span class="line">                .where(<span class="keyword">new</span> SimpleCondition&lt;LoginEvent&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(LoginEvent loginEvent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> loginEvent.eventType.equals(<span class="string">&quot;fail&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 将Pattern应用到流上，检测匹配的复杂事件，得到一个PatternStream</span></span><br><span class="line">        PatternStream&lt;LoginEvent&gt; patternStream = CEP.pattern(stream, pattern);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 将匹配到的复杂事件选择出来，然后包装成字符串报警信息输出</span></span><br><span class="line">        patternStream</span><br><span class="line">                .select(<span class="keyword">new</span> PatternSelectFunction&lt;LoginEvent, String&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> String <span class="title">select</span><span class="params">(Map&lt;String, List&lt;LoginEvent&gt;&gt; map)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        LoginEvent first = map.get(<span class="string">&quot;first&quot;</span>).get(<span class="number">0</span>);</span><br><span class="line">                        LoginEvent second = map.get(<span class="string">&quot;second&quot;</span>).get(<span class="number">0</span>);</span><br><span class="line">                        LoginEvent third = map.get(<span class="string">&quot;third&quot;</span>).get(<span class="number">0</span>);</span><br><span class="line">                        <span class="keyword">return</span> first.userId + <span class="string">&quot; 连续三次登录失败！登录时间：&quot;</span> + first.timestamp + <span class="string">&quot;, &quot;</span> + second.timestamp + <span class="string">&quot;, &quot;</span> + third.timestamp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .print(<span class="string">&quot;warning&quot;</span>);</span><br><span class="line"></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的程序中，模式中的每个简单事件，会用一个.where()方法来指定一个约束条件，指明每个事件的特征，这里就是eventType 为fail。</p>
<p>而模式里表示事件之间的关系时，使用了 .next() 方法。next 是下一个的意思，表示紧挨着、中间不能有其他事件(比如登录成功)，这是一个严格近邻关系。第一个事件用 .begin() 方法表示开始。所有这些连接词都可以有一个字符串作为参数，这个字符串就可以认为是当前简单事件的名称。所以我们如果检测到一组匹配的复杂事件，里面就会有连续的三个登录失败事件，它们的名称分别叫作 first second 和 third。</p>
<p>在第三步处理复杂事件时，调用了 PatternStream 的 .select() 方法，传入一个 PatternSelectFunction 对检测到的复杂事件进行处理。而检测到的复杂事件，会放在一个 Map 中；PatternSelectFunction 内 .select() 方法有一个类型为 Map&lt;String, List<LoginEvent>&gt;的参数 map，里面就保存了检测到的匹配事件。这里的 key 是一个字符串，对应着事件的名称，而 value 是 LoginEvent 的一个列表，匹配到的登录失败事件就保存在这个列表里。最终我们提取 userId 和三次登录的时间戳，包装成字符串输出一个报警信息。</LoginEvent></p>
<p>上述代码可以进一步优化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginFailDetectProExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 获取登录事件流，并提取时间戳、生成水位线</span></span><br><span class="line">        KeyedStream&lt;LoginEvent, String&gt; stream = env</span><br><span class="line">                .fromElements(</span><br><span class="line">                        <span class="keyword">new</span> LoginEvent(<span class="string">&quot;user_1&quot;</span>, <span class="string">&quot;192.168.0.1&quot;</span>, <span class="string">&quot;fail&quot;</span>, <span class="number">2000L</span>),</span><br><span class="line">                        <span class="keyword">new</span> LoginEvent(<span class="string">&quot;user_1&quot;</span>, <span class="string">&quot;192.168.0.2&quot;</span>, <span class="string">&quot;fail&quot;</span>, <span class="number">3000L</span>),</span><br><span class="line">                        <span class="keyword">new</span> LoginEvent(<span class="string">&quot;user_2&quot;</span>, <span class="string">&quot;192.168.1.29&quot;</span>, <span class="string">&quot;fail&quot;</span>, <span class="number">4000L</span>),</span><br><span class="line">                        <span class="keyword">new</span> LoginEvent(<span class="string">&quot;user_1&quot;</span>, <span class="string">&quot;171.56.23.10&quot;</span>, <span class="string">&quot;fail&quot;</span>, <span class="number">5000L</span>),</span><br><span class="line">                        <span class="keyword">new</span> LoginEvent(<span class="string">&quot;user_2&quot;</span>, <span class="string">&quot;192.168.1.29&quot;</span>, <span class="string">&quot;fail&quot;</span>, <span class="number">7000L</span>),</span><br><span class="line">                        <span class="keyword">new</span> LoginEvent(<span class="string">&quot;user_2&quot;</span>, <span class="string">&quot;192.168.1.29&quot;</span>, <span class="string">&quot;fail&quot;</span>, <span class="number">8000L</span>),</span><br><span class="line">                        <span class="keyword">new</span> LoginEvent(<span class="string">&quot;user_2&quot;</span>, <span class="string">&quot;192.168.1.29&quot;</span>, <span class="string">&quot;success&quot;</span>, <span class="number">6000L</span>)</span><br><span class="line">                )</span><br><span class="line">                .assignTimestampsAndWatermarks(</span><br><span class="line">                        WatermarkStrategy.&lt;LoginEvent&gt;forBoundedOutOfOrderness(Duration.ofSeconds(<span class="number">3</span>))</span><br><span class="line">                                .withTimestampAssigner(</span><br><span class="line">                                        <span class="keyword">new</span> SerializableTimestampAssigner&lt;LoginEvent&gt;() &#123;</span><br><span class="line">                                            <span class="meta">@Override</span></span><br><span class="line">                                            <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(LoginEvent loginEvent, <span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">                                                <span class="keyword">return</span> loginEvent.timestamp;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                )</span><br><span class="line">                )</span><br><span class="line">                .keyBy(r -&gt; r.userId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 定义Pattern，连续的三个登录失败事件</span></span><br><span class="line">        Pattern&lt;LoginEvent, LoginEvent&gt; pattern = Pattern.&lt;LoginEvent&gt;begin(<span class="string">&quot;fail&quot;</span>)    <span class="comment">// 第一个登录失败事件</span></span><br><span class="line">                .where(<span class="keyword">new</span> SimpleCondition&lt;LoginEvent&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(LoginEvent loginEvent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> loginEvent.eventType.equals(<span class="string">&quot;fail&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).times(<span class="number">3</span>).consecutive();    <span class="comment">// 指定是严格紧邻的三次登录失败</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 将Pattern应用到流上，检测匹配的复杂事件，得到一个PatternStream</span></span><br><span class="line">        PatternStream&lt;LoginEvent&gt; patternStream = CEP.pattern(stream, pattern);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 将匹配到的复杂事件选择出来，然后包装成字符串报警信息输出</span></span><br><span class="line">        SingleOutputStreamOperator&lt;String&gt; warningStream = patternStream</span><br><span class="line">                .process(<span class="keyword">new</span> PatternProcessFunction&lt;LoginEvent, String&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMatch</span><span class="params">(Map&lt;String, List&lt;LoginEvent&gt;&gt; match, Context ctx, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="comment">// 提取三次登录失败事件</span></span><br><span class="line">                        LoginEvent firstFailEvent = match.get(<span class="string">&quot;fail&quot;</span>).get(<span class="number">0</span>);</span><br><span class="line">                        LoginEvent secondFailEvent = match.get(<span class="string">&quot;fail&quot;</span>).get(<span class="number">1</span>);</span><br><span class="line">                        LoginEvent thirdFailEvent = match.get(<span class="string">&quot;fail&quot;</span>).get(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">                        out.collect(firstFailEvent.userId + <span class="string">&quot; 连续三次登录失败！登录时间：&quot;</span> +</span><br><span class="line">                                firstFailEvent.timestamp + <span class="string">&quot;, &quot;</span> +</span><br><span class="line">                                secondFailEvent.timestamp + <span class="string">&quot;, &quot;</span> +</span><br><span class="line">                                thirdFailEvent.timestamp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印输出</span></span><br><span class="line">        warningStream.print(<span class="string">&quot;warning&quot;</span>);</span><br><span class="line"></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模式API-Pattern-API"><a href="#模式API-Pattern-API" class="headerlink" title="模式API(Pattern API)"></a>模式API(Pattern API)</h3><h4 id="个体模式"><a href="#个体模式" class="headerlink" title="个体模式"></a>个体模式</h4><p>我们就把每个简单事件的匹配规则，叫作个体模式(Individual Pattern)。</p>
<p>每一个登录失败事件的选取规则，就都是一个个体模式。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.&lt;LoginEvent&gt;begin(<span class="string">&quot;first&quot;</span>) <span class="comment">// 以第一个登录失败事件开始 </span></span><br><span class="line">.where(<span class="keyword">new</span> SimpleCondition&lt;LoginEvent&gt;() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(LoginEvent loginEvent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> loginEvent.eventType.equals(<span class="string">&quot;fail&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>个体模式一般都会匹配接收一个事件。</p>
<p>每个个体模式都以一个连接词开始定义的，比如 begin、next 等等，这是 Pattern 对象的一个方法(begin 是 Pattern 类的静态方法)，返回的还是一个 Pattern。这些连接词方法有一个 String 类型参数，这就是当前个体模式唯一的名字，比如这里的 first、second。在之后检测到匹配事件时，就会以这个名字来指代匹配事件。</p>
<p>个体模式需要一个过滤条件，用来指定具体的匹配规则。这个条件一般是通过调用.where()方法来实现的，具体的过滤逻辑则通过传入的 SimpleCondition 内的 .filter() 方法来定义。</p>
<p>另外，个体模式可以匹配接收一个事件，也可以接收多个事件。这听起来有点奇怪，一个单独的匹配规则可能匹配到多个事件吗？这是可能的，我们可以给个体模式增加一个量词 (quantifier)，就能够让它进行循环匹配，接收多个事件。</p>
<h5 id="量词-Quantifiers"><a href="#量词-Quantifiers" class="headerlink" title="量词(Quantifiers )"></a>量词(Quantifiers )</h5><p>个体模式后面可以跟一个量词，用来指定循环的次数。从这个角度分类，个体模式可以包括<strong>单例(singleton)模式</strong>和<strong>循环(looping)模式</strong>。默认情况下，个体模式是单例模式，匹配接收一个事件；当定义了量词之后，就变成了循环模式，可以匹配接收多个事件。</p>
<p>在循环模式中，对同样特征的事件可以匹配多次。比如我们定义个体模式为匹配形状为三角形的事件，再让它循环多次，就变成了匹配连续多个三角形的事件。注意这里的连续，只要保证前后顺序即可，中间可以有其他事件，所以是宽松近邻关系。</p>
<p>在 Flink CEP 中，可以使用不同的方法指定循环模式，主要有：</p>
<p><strong>.oneOrMore()</strong></p>
<p>匹配事件出现一次或多次，假设 a 是一个个体模式，a.oneOrMore() 表示可以匹配 1 个或多个 a 的事件组合。我们有时会用 a+ 来简单表示。</p>
<p><strong>.times(times)</strong></p>
<p>匹配事件发生特定次数(times)，例如 a.times(3) 表示 aaa。</p>
<p><strong>.times(fromTimes，toTimes)</strong></p>
<p>指定匹配事件出现的次数范围，最小次数为 fromTimes，最大次数为 toTimes。例如 a.times(2,4) 可以匹配 aa，aaa 和 aaaa。</p>
<p><strong>.greedy()</strong></p>
<p>只能用在循环模式后，使当前循环模式变得贪心(greedy)，也就是总是尽可能多地去匹配。例如 a.times(2, 4).greedy()，如果出现了连续 4 个 a，那么会直接把 aaaa 检测出来进行处理，其他任意 2 个 a 是不算匹配事件的。</p>
<p><strong>.optional()</strong></p>
<p>使当前模式成为可选的，也就是说可以满足这个匹配条件，也可以不满足。 </p>
<p>对于一个个体模式 pattern 来说，后面所有可以添加的量词如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配事件出现 4 次 </span></span><br><span class="line">pattern.times(<span class="number">4</span>);</span><br><span class="line"><span class="comment">// 匹配事件出现 4 次，或者不出现</span></span><br><span class="line">pattern.times(<span class="number">4</span>).optional();</span><br><span class="line"><span class="comment">// 匹配事件出现2, 3 或者4次 </span></span><br><span class="line">pattern.times(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// 匹配事件出现 2, 3 或者 4 次，并且尽可能多地匹配 </span></span><br><span class="line">pattern.times(<span class="number">2</span>, <span class="number">4</span>).greedy();</span><br><span class="line"><span class="comment">// 匹配事件出现 2, 3, 4 次，或者不出现 </span></span><br><span class="line">pattern.times(<span class="number">2</span>, <span class="number">4</span>).optional();</span><br><span class="line"><span class="comment">// 匹配事件出现 2, 3, 4 次，或者不出现；并且尽可能多地匹配 </span></span><br><span class="line">pattern.times(<span class="number">2</span>, <span class="number">4</span>).optional().greedy();</span><br><span class="line"><span class="comment">// 匹配事件出现 1 次或多次 </span></span><br><span class="line">pattern.oneOrMore();</span><br><span class="line"><span class="comment">// 匹配事件出现 1 次或多次，并且尽可能多地匹配 </span></span><br><span class="line">pattern.oneOrMore().greedy();</span><br><span class="line"><span class="comment">// 匹配事件出现 1 次或多次，或者不出现 </span></span><br><span class="line">pattern.oneOrMore().optional();</span><br><span class="line"><span class="comment">// 匹配事件出现 1 次或多次，或者不出现；并且尽可能多地匹配</span></span><br><span class="line">pattern.oneOrMore().optional().greedy();</span><br><span class="line"><span class="comment">// 匹配事件出现 2 次或多次 </span></span><br><span class="line">pattern.timesOrMore(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 匹配事件出现 2 次或多次，并且尽可能多地匹配 </span></span><br><span class="line">pattern.timesOrMore(<span class="number">2</span>).greedy();</span><br><span class="line"><span class="comment">// 匹配事件出现 2 次或多次，或者不出现 </span></span><br><span class="line">pattern.timesOrMore(<span class="number">2</span>).optional()</span><br><span class="line"><span class="comment">// 匹配事件出现 2 次或多次，或者不出现；并且尽可能多地匹配 </span></span><br><span class="line">pattern.timesOrMore(<span class="number">2</span>).optional().greedy();</span><br></pre></td></tr></table></figure>

<p>正是因为个体模式可以通过量词定义为循环模式，一个模式能够匹配到多个事件，所以之前代码中事件的检测接收才会用 Map 中的一个列表(List)来保存。而之前代码中没有定义量词，都是单例模式，所以只会匹配一个事件，每个 List 中也只有一个元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LoginEvent first = map.get(<span class="string">&quot;first&quot;</span>).get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h5 id="条件-Conditions"><a href="#条件-Conditions" class="headerlink" title="条件(Conditions)"></a>条件(Conditions)</h5><p>对于每个个体模式，匹配事件的核心在于定义匹配条件，也就是选取事件的规则。Flink CEP 会按照这个规则对流中的事件进行筛选，判断是否接受当前的事件。</p>
<p>对于条件的定义，主要是通过调用 Pattern 对象的 .where() 方法来实现的，主要可以分为简单条件、迭代条件、复合条件、终止条件几种类型。此外，也可以调用 Pattern 对象的 .subtype() 方法来限定匹配事件的子类型。</p>
<p><strong>限定子类型</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pattern.subtype(SubEvent.class);</span><br></pre></td></tr></table></figure>

<p>这里 SubEvent 是流中数据类型 Event 的子类型。这时，只有当事件是 SubEvent 类型时， 才可以满足当前模式 pattern 的匹配条件。</p>
<p><strong>简单条件(Simple Conditions)</strong></p>
<p>简单条件是最简单的匹配规则，只根据当前事件的特征来决定是否接受它。这在本质上其实就是一个 filter 操作。</p>
<p>代码中我们为 .where() 方法传入一个 SimpleCondition 的实例作为参数。SimpleCondition 是表示简单条件的抽象类，内部有一个 .filter() 方法，唯一的参数就是当前事件。所以它可以当作 FilterFunction 来使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pattern.where(<span class="keyword">new</span> SimpleCondition&lt;Event&gt;() &#123; </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(Event value)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> value.user.startsWith(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>迭代条件(Iterative Conditions)</strong></p>
<p>简单条件只能基于当前事件做判断，能够处理的逻辑比较有限。在实际应用中，我们可能需要将当前事件跟之前的事件做对比，才能判断出要不要接受当前事件。这种需要依靠之前事件来做判断的条件，就叫作迭代条件(Iterative Condition)。</p>
<p>在 Flink CEP 中，提供了 IterativeCondition 抽象类。这其实是更加通用的条件表达，查看源码可以发现，.where() 方法本身要求的参数类型就是 IterativeCondition；而之前的 SimpleCondition 是它的一个子类。</p>
<p>在 IterativeCondition 中同样需要实现一个 filter() 方法，不过与 SimpleCondition 中不同的是，这个方法有两个参数：除了当前事件之外，还有一个上下文 Context。调用这个上下文的 .getEventsForPattern() 方法，传入一个模式名称，就可以拿到这个模式中已匹配到的所有数据了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">middle.oneOrMore()</span><br><span class="line">      .where(<span class="keyword">new</span> IterativeCondition&lt;Event&gt;() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(Event value, Context&lt;Event&gt; ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// 事件中的 user 必须以 A 开头</span></span><br><span class="line">            <span class="keyword">if</span> (!value.user.startsWith(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> sum = value.amount;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 获取当前模式之前已经匹配的事件，求所有事件 amount 之和</span></span><br><span class="line">            <span class="keyword">for</span> (Event event : ctx.getEventsForPattern(<span class="string">&quot;middle&quot;</span>)) &#123;</span><br><span class="line">              sum += event.amount;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 在总数量小于 100 时，当前事件满足匹配规则，可以匹配成功</span></span><br><span class="line">            <span class="keyword">return</span> sum &lt; <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中当前模式名称就叫作middle，这是一个循环模式，可以接受事件发生一次或多次。于是下面的迭代条件中，我们通过 ctx.getEventsForPattern(“middle”) 获取当前模式已经接受的事件，计算它们的数量(amount)之和；再加上当前事件中的数量，如果总和小于 100，就接受当前事件，否则就不匹配。当然，在迭代条件中我们也可以基于当前事件做出判断，比如代码中要求 user 必须以 A 开头。最终我们的匹配规则就是：事件的 user 必须以 A 开头；并且循环匹配的所有事件 amount 之和必须小于 100。这里的 Event 与之前定义的 POJO 不同，增加了 amount 属性。</p>
<p>可以看到，迭代条件能够获取已经匹配的事件，如果自身又是循环模式(比如量词 oneOrMore)，那么两者结合就可以捕获自身之前接收的数据，据此来判断是否接受当前事件。 这个功能非常强大，我们可以由此实现更加复杂的需求，比如可以要求只有大于之前数据的平均值，才接受当前事件。</p>
<p>另外迭代条件中的上下文 Context 也可以获取到时间相关的信息，比如事件的时间戳和当前的处理时间(processing time)。</p>
<p><strong>组合条件(Combining Conditions)</strong></p>
<p>最直接的想法是，可以在简单条件或者迭代条件的 .filter() 方法中，增加多个判断逻辑。可以通过 if-else 的条件分支分别定义多个条件，也可以直接在 return 返回时给一个多条件的逻辑组合(与、或、非)。不过这样会让代码变得臃肿，可读性降低。更好的方式是独立定义多个条件，然后在外部把它们连接起来，构成一个组合条件(Combining Condition)。</p>
<p>最简单的组合条件，就是 .where() 后面再接一个 .where() 。因为前面提到过，一个条件就像是一个 filter 操作，所以每次调用 .where() 方法都相当于做了一次过滤，连续多次调用就表示多重过滤，最终匹配的事件自然就会同时满足所有条件。这相当于就是多个条件的逻辑与(AND)。</p>
<p>而多个条件的逻辑或(OR)，则可以通过 .where() 后加一个 .or() 来实现。这里的 .or() 方法与 .where() 一样，传入一个 IterativeCondition 作为参数，定义一个独立的条件；它和之前 .where() 定义的条件只要满足一个，当前事件就可以成功匹配。</p>
<p>当然，子类型限定条件(subtype)也可以和其他条件结合起来，成为组合条件，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pattern.subtype(SubEvent.class)</span><br><span class="line">   .where(<span class="keyword">new</span> SimpleCondition&lt;SubEvent&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(SubEvent value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ... <span class="comment">// some condition</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这里可以看到，SimpleCondition 的泛型参数也变成了 SubEvent，所以匹配出的事件就既满足子类型限制，又符合过滤筛选的简单条件；这也是一个逻辑与的关系。</p>
<p><strong>终止条件(Stop Conditions)</strong></p>
<p>对于循环模式而言，还可以指定一个终止条件(Stop Condition)，表示遇到某个特定事件时当前模式就不再继续循环匹配了。 </p>
<p>终止条件的定义是通过调用模式对象的 .until() 方法来实现的，同样传入一个 IterativeCondition 作为参数。需要注意的是，终止条件只与 oneOrMore() 或者 oneOrMore().optional() 结合使用。因为在这种循环模式下，我们不知道后面还有没有事件可以匹配，只好把之前匹配的事件作为状态缓存起来继续等待，这等待无穷无尽；如果一直等下去，缓存的状态越来越多，最终会耗尽内存。所以这种循环模式必须有个终点，当 .until() 指定的条件满足时，循环终止，这样就可以清空状态释放内存了。</p>
<h4 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h4><p>有了定义好的个体模式，就可以尝试按一定的顺序把它们连接起来，定义一个完整的复杂事件匹配规则了。这种将多个个体模式组合起来的完整模式，就叫作组合模式(Combining Pattern)，为了跟个体模式区分有时也叫作模式序列(Pattern Sequence)。</p>
<p>一个组合模式有以下形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Pattern&lt;Event, ?&gt; pattern = Pattern</span><br><span class="line">       .&lt;Event&gt;begin(<span class="string">&quot;start&quot;</span>).where(...)</span><br><span class="line">       .next(<span class="string">&quot;next&quot;</span>).where(...)</span><br><span class="line">       .followedBy(<span class="string">&quot;follow&quot;</span>).where(...)</span><br><span class="line">       ...</span><br></pre></td></tr></table></figure>

<p>可以看到，组合模式确实就是一个模式序列，是用诸如 begin、next、followedBy 等表 示先后顺序的连接词将个体模式串连起来得到的。在这样的语法调用中，每个事件匹配的条件是什么、各个事件之间谁先谁后、近邻关系如何都定义得一目了然。每一个连接词方法调用之后，得到的都仍然是一个 Pattern 的对象；所以从 Java 对象的角度看，组合模式与个体模式是一样的，都是Pattern。</p>
<p><strong>初始模式(Initial Pattern)</strong></p>
<p>所有的组合模式，都必须以一个初始模式开头；而初始模式必须通过调用 Pattern 的静态方法 .begin() 来创建。如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pattern&lt;Event, ?&gt; start = Pattern.&lt;Event&gt;begin(<span class="string">&quot;start&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这里我们调用 Pattern 的 .begin() 方法创建了一个初始模式。传入的 String 类型的参数就是模式的名称；而 begin 方法需要传入一个类型参数，这就是模式要检测流中事件的基本类型，这里我们定义为 Event。调用的结果返回一个 Pattern 的对象实例。Pattern 有两个泛型参数，第一个就是检测事件的基本类型 Event，跟 begin 指定的类型一致；第二个则是当前模式里事件的子类型，由子类型限制条件指定。我们这里用类型通配符(?)代替，就可以从上下文直接推断了。</p>
<p><strong>近邻条件(Contiguity Conditions)</strong></p>
<p>在初始模式之后，我们就可以按照复杂事件的顺序追加模式，组合成模式序列了。模式之间的组合是通过一些连接词方法实现的，这些连接词指明了先后事件之间有着怎样的近邻关系，这就是所谓的近邻条件(Contiguity Conditions，也叫连续性条件)。</p>
<p>Flink CEP 中提供了三种近邻关系：</p>
<p>严格近邻(Strict Contiguity)</p>
<p>匹配的事件严格地按顺序一个接一个出现，中间不会有任何其他事件。代码中对应的就是 Pattern 的 .next() 方法，名称上就能看出来，下一个自然就是紧挨着的。</p>
<p>宽松近邻(Relaxed Contiguity)</p>
<p>松近邻只关心事件发生的顺序，而放宽了对匹配事件的距离要求，也就是说两个匹配的事件之间可以有其他不匹配的事件出现。代码中对应 .followedBy() 方法，很明显这表示跟在后面就可以，不需要紧紧相邻。</p>
<p>非确定性宽松近邻(Non-Deterministic Relaxed Contiguity)</p>
<p>这种近邻关系更加宽松。所谓非确定性是指可以重复使用之前已经匹配过的事件；这种近邻条件下匹配到的不同复杂事件，可以以同一个事件作为开始，所以匹配结果一般会比宽松近邻更多。</p>
<p><strong>其他限制条件</strong></p>
<p>除了上面提到的 next()、followedBy()、followedByAny() 可以分别表示三种近邻条件，我们还可以用否定的连接词来组合个体模式。主要包括：</p>
<p>.notNext()</p>
<p>表示前一个模式匹配到的事件后面，不能紧跟着某种事件。</p>
<p>.notFollowedBy()</p>
<p>表示前一个模式匹配到的事件后面，不会出现某种事件。这里需要注意，由于 notFollowedBy() 是没有严格限定的；流数据不停地到来，我们永远不能保证之后不会出现某种事件。所以一个模式序列不能以 notFollowedBy() 结尾，这个限定条件主要用来表示两个事件中间不会出现某种事件。</p>
<p>另外，Flink CEP 中还可以为模式指定一个时间限制，这是通过调用 .within() 方法实现的。 方法传入一个时间参数，这是模式序列中第一个事件到最后一个事件之间的最大时间间隔，只有在这期间成功匹配的复杂事件才是有效的。一个模式序列中只能有一个时间限制，调用 .within() 的位置不限；如果多次调用则会以最小的那个时间间隔为准。</p>
<p>下面是模式序列中所有限制条件在代码中的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 严格近邻条件</span></span><br><span class="line">Pattern&lt;Event, ?&gt; strict = start.next(<span class="string">&quot;middle&quot;</span>).where(...);</span><br><span class="line"><span class="comment">// 宽松近邻条件</span></span><br><span class="line">Pattern&lt;Event, ?&gt; relaxed = start.followedBy(<span class="string">&quot;middle&quot;</span>).where(...);</span><br><span class="line"><span class="comment">// 非确定性宽松近邻条件</span></span><br><span class="line">Pattern&lt;Event, ?&gt; nonDetermin = start.followedByAny(<span class="string">&quot;middle&quot;</span>).where(...);</span><br><span class="line"><span class="comment">// 不能严格近邻条件</span></span><br><span class="line">Pattern&lt;Event, ?&gt; strictNot = start.notNext(<span class="string">&quot;not&quot;</span>).where(...);</span><br><span class="line"><span class="comment">// 不能宽松近邻条件</span></span><br><span class="line">Pattern&lt;Event, ?&gt; relaxedNot = start.notFollowedBy(<span class="string">&quot;not&quot;</span>).where(...);</span><br><span class="line"><span class="comment">// 时间限制条件 </span></span><br><span class="line">middle.within(Time.seconds(<span class="number">10</span>));</span><br></pre></td></tr></table></figure>

<p><strong>循环模式中的近邻条件</strong></p>
<p>.consecutive()</p>
<p>为循环模式中的匹配事件增加严格的近邻条件，保证所有匹配事件是严格连续的。也就是说，一旦中间出现了不匹配的事件，当前循环检测就会终止。这起到的效果跟模式序列中的 next() 一样，需要与循环量词 times()、oneOrMore()配合使用。</p>
<p>.allowCombinations()</p>
<p>除严格近邻外，也可以为循环模式中的事件指定非确定性宽松近邻条件，表示可以重复使用已经匹配的事件。这需要调用 .allowCombinations() 方法来实现，实现的效果与 .followedByAny() 相同。</p>
<h4 id="模式组"><a href="#模式组" class="headerlink" title="模式组"></a>模式组</h4><p>一般来说，代码中定义的模式序列，就是我们在业务逻辑中匹配复杂事件的规则。不过在有些非常复杂的场景中，可能需要划分多个阶段，每个阶段又有一连串的匹配规则。为了应对这样的需求，Flink CEP 允许我们以嵌套的方式来定义模式。</p>
<p>之前在模式序列中，我们用 begin()、next()、followedBy()、followedByAny()这样的连接词来组合个体模式，这些方法的参数就是一个个体模式的名称；而现在它们可以直接以一个模式序列作为参数，就将模式序列又一次连接组合起来了。这样得到的就是一个模式组(Groups of Patterns)。</p>
<p>在模式组中，每一个模式序列就被当作了某一阶段的匹配条件，返回的类型是一个 GroupPattern。而 GroupPattern 本身是 Pattern 的子类；所以个体模式和组合模式能调用的方法，比如 times()、oneOrMore()、optional()之类的量词，模式组一般也是可以用的。</p>
<p>具体在代码中的应用如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以模式序列作为初始模式</span></span><br><span class="line">Pattern&lt;Event, ?&gt; start = Pattern.begin(</span><br><span class="line">       Pattern.&lt;Event&gt;begin(<span class="string">&quot;start_start&quot;</span>).where(...)</span><br><span class="line">             .followedBy(<span class="string">&quot;start_middle&quot;</span>).where(...)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 start 后定义严格近邻的模式序列，并重复匹配两次 </span></span><br><span class="line">Pattern&lt;Event, ?&gt; strict = start.next(</span><br><span class="line">       Pattern.&lt;Event&gt;begin(<span class="string">&quot;next_start&quot;</span>).where(...)</span><br><span class="line">             .followedBy(<span class="string">&quot;next_middle&quot;</span>).where(...)</span><br><span class="line">).times(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 start 后定义宽松近邻的模式序列，并重复匹配一次或多次 </span></span><br><span class="line">Pattern&lt;Event, ?&gt; relaxed = start.followedBy(</span><br><span class="line">       Pattern.&lt;Event&gt;begin(<span class="string">&quot;followedby_start&quot;</span>).where(...)</span><br><span class="line">             .followedBy(<span class="string">&quot;followedby_middle&quot;</span>).where(...)</span><br><span class="line">).oneOrMore();</span><br><span class="line"></span><br><span class="line"><span class="comment">//在 start 后定义非确定性宽松近邻的模式序列，可以匹配一次，也可以不匹配 </span></span><br><span class="line">Pattern&lt;Event, ?&gt; nonDeterminRelaxed = start.followedByAny(</span><br><span class="line">       Pattern.&lt;Event&gt;begin(<span class="string">&quot;followedbyany_start&quot;</span>).where(...)</span><br><span class="line">             .followedBy(<span class="string">&quot;followedbyany_middle&quot;</span>).where(...)</span><br><span class="line">).optional();</span><br></pre></td></tr></table></figure>

<h4 id="匹配后跳过策略"><a href="#匹配后跳过策略" class="headerlink" title="匹配后跳过策略"></a>匹配后跳过策略</h4><p>在 Flink CEP 中，由于有循环模式和非确定性宽松近邻的存在，同一个事件有可能会重复利用，被分配到不同的匹配结果中。这样会导致匹配结果规模增大，有时会显得非常冗余。当然，非确定性宽松近邻条件，本来就是为了放宽限制、扩充匹配结果而设计的；我们主要是针对循环模式来考虑匹配结果的精简。</p>
<p>如果对循环模式增加了.greedy()的限制，那么就会尽可能多地匹配事件，这样就可以砍掉那些子集上的匹配了。不过这种方式还是略显简单粗暴，如果我们想要精确控制事件的匹配应该跳过哪些情况，那就需要制定另外的策略了。</p>
<p>在 Flink CEP 中，提供了模式的匹配后跳过策略(After Match Skip Strategy)，专门用来精准控制循环模式的匹配结果。这个策略可以在 Pattern 的初始模式定义中，作为 begin() 的第二个参数传入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pattern.begin(<span class="string">&quot;start&quot;</span>, AfterMatchSkipStrategy.noSkip())</span><br><span class="line">       .where(...)</span><br><span class="line">			 ...</span><br></pre></td></tr></table></figure>

<p>匹配后跳过策略 AfterMatchSkipStrategy 是一个抽象类，它有多个具体的实现，可以通过调用对应的静态方法来返回对应的策略实例。这里我们配置的是不做跳过处理，这也是默认策略。</p>
<p>下面我们举例来说明不同的跳过策略。例如我们要检测的复杂事件模式为：开始是用户名为 a 的事件(简写为事件 a，下同)，可以重复一次或多次；然后跟着一个用户名为 b 的事件，a 事件和 b 事件之间可以有其他事件(宽松近邻)。用简写形式可以直接写作：a+ followedBy b。在代码中定义 Pattern 如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Pattern.&lt;Event&gt;begin(<span class="string">&quot;a&quot;</span>).where(<span class="keyword">new</span> SimpleCondition&lt;Event&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(Event value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> value.user.equals(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).oneOrMore()</span><br><span class="line">  .followedBy(<span class="string">&quot;b&quot;</span>).where(<span class="keyword">new</span> SimpleCondition&lt;Event&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(Event value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> value.user.equals(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>

<p>我们如果输入事件序列 “a a a b” ——这里为了区分前后不同的 a 事件，可以记作 “a1 a2 a3 b” ——那么应该检测到 6 个匹配结果：(a1 a2 a3 b)，(a1 a2 b)，(a1 b)，(a2 a3 b)，(a2 b)， (a3 b)。如果在初始模式的量词 .oneOrMore() 后加上 .greedy() 定义为贪心匹配，那么结果就是: (a1 a2 a3 b)，(a2 a3 b)，(a3 b)，每个事件作为开头只会出现一次。</p>
<p>接下来我们讨论不同跳过策略对匹配结果的影响：</p>
<p><strong>不跳过(NO_SKIP)</strong></p>
<p>代码调用 AfterMatchSkipStrategy.noSkip()。这是默认策略，所有可能的匹配都会输出。所以这里会输出完整的 6 个匹配。</p>
<p><strong>跳至下一个(SKIP_TO_NEXT)</strong></p>
<p>代码调用 AfterMatchSkipStrategy.skipToNext()。找到一个 a1 开始的最大匹配之后，跳过 a1 开始的所有其他匹配，直接从下一个 a2 开始匹配起。当然 a2 也是如此跳过其他匹配。最终得到(a1 a2 a3 b)，(a2 a3 b)，(a3 b)。可以看到，这种跳过策略跟使用 .greedy() 效果是相同的。</p>
<p><strong>跳过所有子匹配(SKIP_PAST_LAST_EVENT)</strong></p>
<p>代码调用 AfterMatchSkipStrategy.skipPastLastEvent()。找到 a1 开始的匹配(a1 a2 a3 b)之后，直接跳过所有 a1 直到 a3 开头的匹配，相当于把这些子匹配都跳过了。最终得到(a1 a2 a3 b)，这是最为精简的跳过策略。</p>
<p><strong>跳至第一个(SKIP_TO_FIRST[a])</strong></p>
<p>代码调用 AfterMatchSkipStrategy.skipToFirst(“a”)，这里传入一个参数，指明跳至哪个模式的第一个匹配事件。找到 a1 开始的匹配(a1 a2 a3 b)后，跳到以最开始一个 a(也就是 a1) 为开始的匹配，相当于只留下 a1 开始的匹配。最终得到(a1 a2 a3 b)，(a1 a2 b)，(a1 b)。</p>
<p><strong>跳至最后一个(SKIP_TO_LAST[a])</strong></p>
<p>代码调用 AfterMatchSkipStrategy.skipToLast(“a”)，同样传入一个参数，指明跳至哪个模式的最后一个匹配事件。找到 a1 开始的匹配(a1 a2 a3 b)后，跳过所有 a1、a2 开始的匹配，跳到以最后一个 a(也就是 a3)为开始的匹配。最终得到(a1 a2 a3 b)，(a3 b)。</p>
<h3 id="模式的检测处理"><a href="#模式的检测处理" class="headerlink" title="模式的检测处理"></a>模式的检测处理</h3><p>Pattern API 是 Flink CEP 的核心，也是最复杂的一部分。不过利用 Pattern API 定义好模式还只是整个复杂事件处理的第一步，接下来还需要将模式应用到事件流上、检测提取匹配的复杂事件并定义处理转换的方法，最终得到想要的输出信息。</p>
<h4 id="将模式应用到流上"><a href="#将模式应用到流上" class="headerlink" title="将模式应用到流上"></a>将模式应用到流上</h4><p>将模式应用到事件流上的代码非常简单，只要调用 CEP 类的静态方法 .pattern()，将数据流(DataStream)和模式(Pattern)作为两个参数传入就可以了。最终得到的是一个 PatternStream：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;Event&gt; inputStream = ...</span><br><span class="line">Pattern&lt;Event, ?&gt; pattern = ...</span><br><span class="line">PatternStream&lt;Event&gt; patternStream = CEP.pattern(inputStream, pattern);</span><br></pre></td></tr></table></figure>

<p>这里的 DataStream，也可以通过 keyBy 进行按键分区得到 KeyedStream，接下来对复杂事件的检测就会针对不同的 key 单独进行了。</p>
<p>模式中定义的复杂事件，发生是有先后顺序的，这里先后的判断标准取决于具体的时间语义。默认情况下采用事件时间语义，那么事件会以各自的时间戳进行排序；如果是处理时间语义，那么所谓先后就是数据到达的顺序。对于时间戳相同或是同时到达的事件，我们还可以在 CEP.pattern() 中传入一个比较器作为第三个参数，用来进行更精确的排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可选的事件比较器</span></span><br><span class="line">EventComparator&lt;Event&gt; comparator = ...</span><br><span class="line">PatternStream&lt;Event&gt; patternStream = CEP.pattern(input, pattern, comparator);</span><br></pre></td></tr></table></figure>

<p>得到 PatternStream 后，接下来要做的就是对匹配事件的检测处理了。</p>
<h4 id="处理匹配事件"><a href="#处理匹配事件" class="headerlink" title="处理匹配事件"></a>处理匹配事件</h4><p>基于 PatternStream 可以调用一些转换方法，对匹配的复杂事件进行检测和处理，并最终得到一个正常的 DataStream。这个转换的过程与窗口的处理类似：将模式应用到流上得到 PatternStream，就像在流上添加窗口分配器得到 WindowedStream；而之后的转换操作，就像定义具体处理操作的窗口函数，对收集到的数据进行分析计算，得到结果进行输出，最后回到 DataStream 的类型来。</p>
<p>PatternStream 的转换操作主要可以分成两种：简单便捷的选择提取(select)操作，和更加通用、更加强大的处理(process)操作。与 DataStream 的转换类似，具体实现也是在调用 API 时传入一个函数类：选择操作传入的是一个 PatternSelectFunction，处理操作传入的则是一个 PatternProcessFunction。</p>
<h5 id="匹配事件的选择提取-select"><a href="#匹配事件的选择提取-select" class="headerlink" title="匹配事件的选择提取(select)"></a>匹配事件的选择提取(select)</h5><p>处理匹配事件最简单的方式，就是从 PatternStream 中直接把匹配的复杂事件提取出来，包装成想要的信息输出，这个操作就是选择(select)。</p>
<p><strong>PatternSelectFunction</strong></p>
<p>代码中基于 PatternStream 直接调用 .select() 方法，传入一个 PatternSelectFunction 作为参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PatternStream&lt;Event&gt; patternStream = CEP.pattern(inputStream, pattern); </span><br><span class="line">DataStream&lt;String&gt; result = patternStream.select(<span class="keyword">new</span> MyPatternSelectFunction());</span><br></pre></td></tr></table></figure>

<p>这里的 MyPatternSelectFunction 是 PatternSelectFunction 的一个具体实现。 PatternSelectFunction 是 Flink CEP 提供的一个函数类接口，它会将检测到的匹配事件保存在一个 Map 里，对应的 key 就是这些事件的名称。这里的事件名称就对应着在模式中定义的每个个体模式的名称；而个体模式可以是循环模式，一个名称会对应多个事件，所以最终保存在 Map 里的 value 就是一个事件的列表(List)。</p>
<p>下面是 MyPatternSelectFunction 的一个具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPatternSelectFunction</span> <span class="keyword">implements</span> <span class="title">PatternSelectFunction</span>&lt;<span class="title">Event</span>, <span class="title">String</span>&gt;</span>&#123; </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">select</span><span class="params">(Map&lt;String, List&lt;Event&gt;&gt; pattern)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      Event startEvent = pattern.get(<span class="string">&quot;start&quot;</span>).get(<span class="number">0</span>);</span><br><span class="line">      Event middleEvent = pattern.get(<span class="string">&quot;middle&quot;</span>).get(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">return</span> startEvent.toString() + <span class="string">&quot; &quot;</span> + middleEvent.toString();</span><br><span class="line">		&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PatternSelectFunction 里需要实现一个 select() 方法，这个方法每当检测到一组匹配的复杂事件时都会调用一次。它以保存了匹配复杂事件的 Map 作为输入，经自定义转换后得到输出信息返回。这里我们假设之前定义的模式序列中，有名为start和middle的两个个体模式，于是可以通过这个名称从 Map 中选择提取出对应的事件。注意调用 Map 的.get(key)方法后得到的是一个事件的 List；如果个体模式是单例的，那么 List 中只有一个元素，直接调用.get(0) 就可以把它取出。当然，如果个体模式是循环的，List 中就有可能有多个元素了。</p>
<p>连续登录失败检测的改进，我们可以将匹配到的事件包装成 String 类型的报警信息输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 定义 Pattern，登录失败事件，循环检测 3 次 </span></span><br><span class="line">Pattern&lt;LoginEvent, LoginEvent&gt; pattern = Pattern</span><br><span class="line">       .&lt;LoginEvent&gt;begin(<span class="string">&quot;fails&quot;</span>)</span><br><span class="line">       .where(<span class="keyword">new</span> SimpleCondition&lt;LoginEvent&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(LoginEvent loginEvent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> loginEvent.eventType.equals(<span class="string">&quot;fail&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;).times(<span class="number">3</span>).consecutive();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 将 Pattern 应用到流上，检测匹配的复杂事件，得到一个 PatternStream </span></span><br><span class="line">PatternStream&lt;LoginEvent&gt; patternStream = CEP.pattern(stream, pattern);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 将匹配到的复杂事件选择出来，然后包装成报警信息输出 </span></span><br><span class="line">patternStream.select(<span class="keyword">new</span> PatternSelectFunction&lt;LoginEvent, String&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> String <span class="title">select</span><span class="params">(Map&lt;String, List&lt;LoginEvent&gt;&gt; map)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">          <span class="comment">// 只有一个模式，匹配到了 3 个事件，放在 List 中</span></span><br><span class="line">            LoginEvent first = map.get(<span class="string">&quot;fails&quot;</span>).get(<span class="number">0</span>);</span><br><span class="line">            LoginEvent second = map.get(<span class="string">&quot;fails&quot;</span>).get(<span class="number">1</span>);</span><br><span class="line">            LoginEvent third = map.get(<span class="string">&quot;fails&quot;</span>).get(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">return</span> first.userId + <span class="string">&quot; 连续三次登录失败!登录时间:&quot;</span> + first.timestamp</span><br><span class="line">            + <span class="string">&quot;, &quot;</span> + second.timestamp + <span class="string">&quot;, &quot;</span> + third.timestamp;</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;)</span><br><span class="line">       .print(<span class="string">&quot;warning&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>PatternFlatSelectFunction</strong></p>
<p>除此之外，PatternStream 还有一个类似的方法是.flatSelect()，传入的参数是一个PatternFlatSelectFunction。从名字上就能看出，这是 PatternSelectFunction 的扁平化版本；内部需要实现一个 flatSelect() 方法，它与之前 select() 的不同就在于没有返回值，而是多了一个收集器(Collector)参数 out，通过调用 out.collet() 方法就可以实现多次发送输出数据了。</p>
<p>例如上面的代码可以写成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3. 将匹配到的复杂事件选择出来，然后包装成报警信息输出</span></span><br><span class="line">patternStream.flatSelect(<span class="keyword">new</span> PatternFlatSelectFunction&lt;LoginEvent, String&gt;() &#123; </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatSelect</span><span class="params">(Map&lt;String, List&lt;LoginEvent&gt;&gt; map, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    LoginEvent first = map.get(<span class="string">&quot;fails&quot;</span>).get(<span class="number">0</span>);</span><br><span class="line">    LoginEvent second = map.get(<span class="string">&quot;fails&quot;</span>).get(<span class="number">1</span>);</span><br><span class="line">    LoginEvent third = map.get(<span class="string">&quot;fails&quot;</span>).get(<span class="number">2</span>);</span><br><span class="line">    out.collect(first.userId + <span class="string">&quot; 连续三次登录失败!登录时间:&quot;</span> + first.timestamp +</span><br><span class="line">    <span class="string">&quot;, &quot;</span> + second.timestamp + <span class="string">&quot;, &quot;</span> + third.timestamp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).print(<span class="string">&quot;warning&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>可见 PatternFlatSelectFunction 使用更加灵活，完全能够覆盖 PatternSelectFunction 的功能。 这跟 FlatMapFunction 与 MapFunction 的区别是一样的。</p>
<h5 id="匹配事件的通用处理-process"><a href="#匹配事件的通用处理-process" class="headerlink" title="匹配事件的通用处理(process)"></a>匹配事件的通用处理(process)</h5><p>自1.8版本之后，Flink CEP引入了对于匹配事件的通用检测处理方式，那就是直接调用 PatternStream 的 .process() 方法，传入一个 PatternProcessFunction。这看起来就像是我们熟悉的处理函数(process function)，它也可以访问一个上下文(Context)，进行更多的操作。</p>
<p>所以 PatternProcessFunction 功能更加丰富、调用更加灵活，可以完全覆盖其他接口，也就成为了目前官方推荐的处理方式。事实上，PatternSelectFunction 和 PatternFlatSelectFunction 在 CEP 内部执行时也会被转换成 PatternProcessFunction。</p>
<p>我们可以使用 PatternProcessFunction 将之前的代码重写如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3. 将匹配到的复杂事件选择出来，然后包装成报警信息输出 </span></span><br><span class="line">patternStream.process(<span class="keyword">new</span> PatternProcessFunction&lt;LoginEvent, String&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMatch</span><span class="params">(Map&lt;String, List&lt;LoginEvent&gt;&gt; map, Context ctx, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    LoginEvent first = map.get(<span class="string">&quot;fails&quot;</span>).get(<span class="number">0</span>);</span><br><span class="line">    LoginEvent second = map.get(<span class="string">&quot;fails&quot;</span>).get(<span class="number">1</span>);</span><br><span class="line">    LoginEvent third = map.get(<span class="string">&quot;fails&quot;</span>).get(<span class="number">2</span>);</span><br><span class="line">    out.collect(first.userId + <span class="string">&quot; 连续三次登录失败!登录时间:&quot;</span> + first.timestamp +</span><br><span class="line">    <span class="string">&quot;, &quot;</span> + second.timestamp + <span class="string">&quot;, &quot;</span> + third.timestamp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).print(<span class="string">&quot;warning&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>可以看到，PatternProcessFunction 中必须实现一个 processMatch()方法；这个方法与之前的 flatSelect() 类似，只是多了一个上下文 Context 参数。利用这个上下文可以获取当前的时间信息，比如事件的时间戳(timestamp)或者处理时间(processing time)；还可以调用 .output() 方法将数据输出到侧输出流。侧输出流的功能是处理函数的一大特性，我们已经非常熟悉；而在 CEP 中，侧输出流一般被用来处理超时事件。</p>
<h4 id="处理超时事件"><a href="#处理超时事件" class="headerlink" title="处理超时事件"></a>处理超时事件</h4><p>复杂事件的检测结果一般只有两种：要么匹配，要么不匹配。检测处理的过程具体如下：</p>
<p>(1)如果当前事件符合模式匹配的条件，就接受该事件，保存到对应的 Map 中；</p>
<p>(2)如果在模式序列定义中，当前事件后面还应该有其他事件，就继续读取事件流进行检测；如果模式序列的定义已经全部满足，那么就成功检测到了一组匹配的复杂事件，调用 PatternProcessFunction 的 processMatch() 方法进行处理；</p>
<p>(3)如果当前事件不符合模式匹配的条件，就丢弃该事件；</p>
<p>(4)如果当前事件破坏了模式序列中定义的限制条件，比如不满足严格近邻要求，那么当前已检测的一组部分匹配事件都被丢弃，重新开始检测。</p>
<p>不过在有时间限制的情况下，需要考虑的问题会有一点特别。比如我们用 .within() 指定了模式检测的时间间隔，超出这个时间当前这组检测就应该失败了。然而这种超时失败跟真正的匹配失败不同，它其实是一种部分成功匹配；因为只有在开头能够正常匹配的前提下，没有等到后续的匹配事件才会超时。所以往往不应该直接丢弃，而是要输出一个提示或报警信息。这就要求我们有能力捕获并处理超时事件。</p>
<h5 id="使用-PatternProcessFunction"><a href="#使用-PatternProcessFunction" class="headerlink" title="使用 PatternProcessFunction"></a>使用 PatternProcessFunction</h5><p>在 Flink CEP 中，提供了一个专门捕捉超时的部分匹配事件的接口，叫作 TimedOutPartialMatchHandler。这个接口需要实现一个 processTimedOutMatch()方法，可以将超时的、已检测到的部分匹配事件放在一个 Map 中，作为方法的第一个参数；方法的第二个 参数则是 PatternProcessFunction 的上下文 Context。所以这个接口必须与 PatternProcessFunction 结合使用，对处理结果的输出则需要利用侧输出流来进行。</p>
<p>代码中的调用方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPatternProcessFunction</span> <span class="keyword">extends</span> <span class="title">PatternProcessFunction</span>&lt;<span class="title">Event</span>, <span class="title">String</span>&gt; <span class="keyword">implements</span> <span class="title">TimedOutPartialMatchHandler</span>&lt;<span class="title">Event</span>&gt; </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 正常匹配事件的处理</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMatch</span><span class="params">(Map&lt;String, List&lt;Event&gt;&gt; match, Context ctx, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">         ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 超时部分匹配事件的处理</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processTimedOutMatch</span><span class="params">(Map&lt;String, List&lt;Event&gt;&gt; match, Context ctx)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    Event startEvent = match.get(<span class="string">&quot;start&quot;</span>).get(<span class="number">0</span>);</span><br><span class="line">    OutputTag&lt;Event&gt; outputTag = <span class="keyword">new</span> OutputTag&lt;Event&gt;(<span class="string">&quot;time-out&quot;</span>)&#123;&#125;;</span><br><span class="line">    ctx.output(outputTag, startEvent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在 processTimedOutMatch() 方法中定义了一个输出标签(OutputTag)。调用 ctx.output() 方法，就可以将超时的部分匹配事件输出到标签所标识的侧输出流了。</p>
<h5 id="使用-PatternTimeoutFunction"><a href="#使用-PatternTimeoutFunction" class="headerlink" title="使用 PatternTimeoutFunction"></a>使用 PatternTimeoutFunction</h5><p>上文提到的 PatternProcessFunction 通过实现 TimedOutPartialMatchHandler 接口扩展出了处理超时事件的能力，这是官方推荐的做法。此外，Flink CEP 中也保留了简化版的 PatternSelectFunction，它无法直接处理超时事件，不过我们可以通过调用 PatternStream 的 .select() 方法时多传入一个 PatternTimeoutFunction 参数来实现这一点。</p>
<p>PatternTimeoutFunction 是早期版本中用于捕获超时事件的接口。它需要实现一个 timeout() 方法，同样会将部分匹配的事件放在一个 Map 中作为参数传入，此外还有一个参数是当前的时间戳。提取部分匹配事件进行处理转换后，可以将通知或报警信息输出。</p>
<p>由于调用 .select() 方法后会得到唯一的 DataStream，所以正常匹配事件和超时事件的处理结果不应该放在同一条流中。正常匹配事件的处理结果会进入转换后得到的 DataStream，而超时事件的处理结果则会进入侧输出流;这个侧输出流需要另外传入一个侧输出标签(OutputTag) 来指定。</p>
<p>所以最终我们在调用 PatternStream 的 .select() 方法时需要传入三个参数：侧输出流标签 (OutputTag)，超时事件处理函数 PatternTimeoutFunction，匹配事件提取函数 PatternSelectFunction。下面是一个代码中的调用方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个侧输出流标签，用于标识超时侧输出流</span></span><br><span class="line">OutputTag&lt;String&gt; timeoutTag = <span class="keyword">new</span> OutputTag&lt;String&gt;(<span class="string">&quot;timeout&quot;</span>)&#123;&#125;;</span><br><span class="line"><span class="comment">// 将匹配到的，和超时部分匹配的复杂事件提取出来，然后包装成提示信息输出</span></span><br><span class="line">SingleOutputStreamOperator&lt;String&gt; resultStream = patternStream.select(timeoutTag,</span><br><span class="line">      <span class="comment">// 超时部分匹配事件的处理</span></span><br><span class="line">      <span class="keyword">new</span> PatternTimeoutFunction&lt;Event, String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">timeout</span><span class="params">(Map&lt;String, List&lt;Event&gt;&gt; pattern, <span class="keyword">long</span> timeoutTimestamp)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">          Event event = pattern.get(<span class="string">&quot;start&quot;</span>).get(<span class="number">0</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&quot;超时:&quot;</span> + event.toString(); </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 正常匹配事件的处理</span></span><br><span class="line">      <span class="keyword">new</span> PatternSelectFunction&lt;Event, String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">select</span><span class="params">(Map&lt;String, List&lt;Event&gt;&gt; pattern)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">          ... </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将正常匹配和超时部分匹配的处理结果流打印输出 </span></span><br><span class="line">resultStream.print(<span class="string">&quot;matched&quot;</span>);</span><br><span class="line">resultStream.getSideOutput(timeoutTag).print(<span class="string">&quot;timeout&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是，在超时事件处理的过程中，从 Map 里只能取到已经检测到匹配的那些事件；如果取可能未匹配的事件并调用它的对象方法，则可能会报空指针异常 (NullPointerException)。另外，超时事件处理的结果进入侧输出流，正常匹配事件的处理结 果进入主流，两者的数据类型可以不同。</p>
<h5 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h5><p>在电商平台中，最终创造收入和利润的是用户下单购买的环节。用户下单的行为可以表明用户对商品的需求，但在现实中，并不是每次下单都会被用户立刻支付。当拖延一段时间后，用户支付的意愿会降低。所以为了让用户更有紧迫感从而提高支付转化率，同时也为了防范订单支付环节的安全风险，电商网站往往会对订单状态进行监控，设置一个失效时间(比如 15 分钟)，如果下单后一段时间仍未支付，订单就会被取消。</p>
<p>首先定义出要处理的数据类型。我们面对的是订单事件，主要包括用户对订单的创建(下单)和支付两种行为。因此可以定义 POJO 类 OrderEvent 如下，其中属性字段包括用户 ID、 订单 ID、事件类型(操作类型)以及时间戳。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderEvent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String userId;</span><br><span class="line">    <span class="keyword">public</span> String orderId;</span><br><span class="line">    <span class="keyword">public</span> String eventType;</span><br><span class="line">    <span class="keyword">public</span> Long timestamp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderEvent</span><span class="params">(String userId, String orderId, String eventType, Long timestamp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userId = userId;</span><br><span class="line">        <span class="keyword">this</span>.orderId = orderId;</span><br><span class="line">        <span class="keyword">this</span>.eventType = eventType;</span><br><span class="line">        <span class="keyword">this</span>.timestamp = timestamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OrderEvent&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;userId=&#x27;&quot;</span> + userId + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;orderId=&#x27;&quot;</span> + orderId + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, eventType=&#x27;&quot;</span> + eventType + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, timestamp=&quot;</span> + timestamp +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当前需求的重点在于对超时未支付的用户进行监控提醒，也就是需要检测有下单行为、但 15 分钟内没有支付行为的复杂事件。在下单和支付之间，可以有其他操作(比如对订单的修改)，所以两者之间是宽松近邻关系。</p>
<p>很明显，我们重点要处理的是超时的部分匹配事件。对原始的订单事件流按照订单 ID 进行分组，然后检测每个订单的下单-支付复杂事件，如果出现超时事件需要输出报警提示信息。</p>
<p>整体代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderTimeoutDetectExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取订单事件流，并提取时间戳、生成水位线</span></span><br><span class="line">        KeyedStream&lt;OrderEvent, String&gt; stream = env</span><br><span class="line">                .fromElements(</span><br><span class="line">                        <span class="keyword">new</span> OrderEvent(<span class="string">&quot;user_1&quot;</span>, <span class="string">&quot;order_1&quot;</span>, <span class="string">&quot;create&quot;</span>, <span class="number">1000L</span>),</span><br><span class="line">                        <span class="keyword">new</span> OrderEvent(<span class="string">&quot;user_2&quot;</span>, <span class="string">&quot;order_2&quot;</span>, <span class="string">&quot;create&quot;</span>, <span class="number">2000L</span>),</span><br><span class="line">                        <span class="keyword">new</span> OrderEvent(<span class="string">&quot;user_1&quot;</span>, <span class="string">&quot;order_1&quot;</span>, <span class="string">&quot;modify&quot;</span>, <span class="number">10</span> * <span class="number">1000L</span>),</span><br><span class="line">                        <span class="keyword">new</span> OrderEvent(<span class="string">&quot;user_1&quot;</span>, <span class="string">&quot;order_1&quot;</span>, <span class="string">&quot;pay&quot;</span>, <span class="number">60</span> * <span class="number">1000L</span>),</span><br><span class="line">                        <span class="keyword">new</span> OrderEvent(<span class="string">&quot;user_2&quot;</span>, <span class="string">&quot;order_3&quot;</span>, <span class="string">&quot;create&quot;</span>, <span class="number">10</span> * <span class="number">60</span> * <span class="number">1000L</span>),</span><br><span class="line">                        <span class="keyword">new</span> OrderEvent(<span class="string">&quot;user_2&quot;</span>, <span class="string">&quot;order_3&quot;</span>, <span class="string">&quot;pay&quot;</span>, <span class="number">20</span> * <span class="number">60</span> * <span class="number">1000L</span>)</span><br><span class="line">                )</span><br><span class="line">                .assignTimestampsAndWatermarks(</span><br><span class="line">                        WatermarkStrategy.&lt;OrderEvent&gt;forMonotonousTimestamps()</span><br><span class="line">                                .withTimestampAssigner(</span><br><span class="line">                                        <span class="keyword">new</span> SerializableTimestampAssigner&lt;OrderEvent&gt;() &#123;</span><br><span class="line">                                            <span class="meta">@Override</span></span><br><span class="line">                                            <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(OrderEvent event, <span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">                                                <span class="keyword">return</span> event.timestamp;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                )</span><br><span class="line">                )</span><br><span class="line">                .keyBy(order -&gt; order.orderId);    <span class="comment">// 按照订单ID分组</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 定义Pattern</span></span><br><span class="line">        Pattern&lt;OrderEvent, ?&gt; pattern = Pattern</span><br><span class="line">                .&lt;OrderEvent&gt;begin(<span class="string">&quot;create&quot;</span>)    <span class="comment">// 首先是下单事件</span></span><br><span class="line">                .where(<span class="keyword">new</span> SimpleCondition&lt;OrderEvent&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(OrderEvent value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> value.eventType.equals(<span class="string">&quot;create&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .followedBy(<span class="string">&quot;pay&quot;</span>)    <span class="comment">// 之后是支付事件；中间可以修改订单，宽松近邻</span></span><br><span class="line">                .where(<span class="keyword">new</span> SimpleCondition&lt;OrderEvent&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(OrderEvent value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> value.eventType.equals(<span class="string">&quot;pay&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .within(Time.minutes(<span class="number">15</span>));    <span class="comment">// 限制在15分钟之内</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 将Pattern应用到流上，检测匹配的复杂事件，得到一个PatternStream</span></span><br><span class="line">        PatternStream&lt;OrderEvent&gt; patternStream = CEP.pattern(stream, pattern);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 将匹配到的，和超时部分匹配的复杂事件提取出来，然后包装成提示信息输出</span></span><br><span class="line">        SingleOutputStreamOperator&lt;String&gt; payedOrderStream = patternStream.process(<span class="keyword">new</span> OrderPayPatternProcessFunction());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 定义一个测输出流标签，用于标识超时测输出流</span></span><br><span class="line">        OutputTag&lt;String&gt; timeoutTag = <span class="keyword">new</span> OutputTag&lt;String&gt;(<span class="string">&quot;timeout&quot;</span>) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 将正常匹配和超时部分匹配的处理结果流打印输出</span></span><br><span class="line">        payedOrderStream.print(<span class="string">&quot;payed&quot;</span>);</span><br><span class="line">        payedOrderStream.getSideOutput(timeoutTag).print(<span class="string">&quot;timeout&quot;</span>);</span><br><span class="line"></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现自定义的PatternProcessFunction，需实现TimedOutPartialMatchHandler接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderPayPatternProcessFunction</span> <span class="keyword">extends</span> <span class="title">PatternProcessFunction</span>&lt;<span class="title">OrderEvent</span>, <span class="title">String</span>&gt; <span class="keyword">implements</span> <span class="title">TimedOutPartialMatchHandler</span>&lt;<span class="title">OrderEvent</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 处理正常匹配事件</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMatch</span><span class="params">(Map&lt;String, List&lt;OrderEvent&gt;&gt; match, Context ctx, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            OrderEvent payEvent = match.get(<span class="string">&quot;pay&quot;</span>).get(<span class="number">0</span>);</span><br><span class="line">            out.collect(<span class="string">&quot;订单 &quot;</span> + payEvent.orderId + <span class="string">&quot; 已支付！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理超时未支付事件</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processTimedOutMatch</span><span class="params">(Map&lt;String, List&lt;OrderEvent&gt;&gt; match, Context ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            OrderEvent createEvent = match.get(<span class="string">&quot;create&quot;</span>).get(<span class="number">0</span>);</span><br><span class="line">            ctx.output(<span class="keyword">new</span> OutputTag&lt;String&gt;(<span class="string">&quot;timeout&quot;</span>)&#123;&#125;, <span class="string">&quot;订单 &quot;</span> + createEvent.orderId + <span class="string">&quot; 超时未支付！用户为：&quot;</span> + createEvent.userId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用处理函数进行状态编程，结合定时器也可以实现同样的功能，但明显 CEP 的实现更加方便， 也更容易迁移和扩展。</p>
<h4 id="处理迟到数据"><a href="#处理迟到数据" class="headerlink" title="处理迟到数据"></a>处理迟到数据</h4><p>CEP 主要处理的是先后发生的一组复杂事件，所以事件的顺序非常关键。前面已经说过，事件先后顺序的具体定义与时间语义有关。如果是处理时间语义，那比较简单，只要按照数据处理的系统时间算就可以了；而如果是事件时间语义，需要按照事件自身的时间戳来排序。这就有可能出现时间戳大的事件先到、时间戳小的事件后到的现象，也就是所谓的乱序数据或迟到数据。</p>
<p>在 Flink CEP 中沿用了通过设置水位线(watermark)延迟来处理乱序数据的做法。当一个事件到来时，并不会立即做检测匹配处理，而是先放入一个缓冲区(buffer)。缓冲区内的数据，会按照时间戳由小到大排序；当一个水位线到来时，就会将缓冲区中所有时间戳小于水位线的事件依次取出，进行检测匹配。这样就保证了匹配事件的顺序和事件时间的进展一致，处理的顺序就一定是正确的。这里水位线的延迟时间，也就是事件在缓冲区等待的最大时间。</p>
<p>这样又会带来另一个问题：水位线延迟时间不可能保证将所有乱序数据完美包括进来，总会有一些事件延迟比较大，以至于等它到来的时候水位线早已超过了它的时间戳。这时之前的数据都已处理完毕，这样的迟到数据就只能被直接丢弃了——这与窗口对迟到数据的默认处理一致。</p>
<p>我们自然想到，如果不希望迟到数据丢掉，应该也可以借鉴窗口的做法。Flink CEP 同样提供了将迟到事件输出到侧输出流的方式：我们可以基于 PatternStream 直接调用 .sideOutputLateData() 方法，传入一个 OutputTag，将迟到数据放入侧输出流另行处理。代码中调用方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PatternStream&lt;Event&gt; patternStream = CEP.pattern(input, pattern);</span><br><span class="line"><span class="comment">// 定义一个侧输出流的标签</span></span><br><span class="line">OutputTag&lt;String&gt; lateDataOutputTag = <span class="keyword">new</span> OutputTag&lt;String&gt;(<span class="string">&quot;late-data&quot;</span>)&#123;&#125;;</span><br><span class="line">SingleOutputStreamOperator&lt;ComplexEvent&gt; result = patternStream .sideOutputLateData(lateDataOutputTag) <span class="comment">// 将迟到数据输出到侧输出流 </span></span><br><span class="line">  .select(</span><br><span class="line">      <span class="comment">// 处理正常匹配数据</span></span><br><span class="line">      <span class="keyword">new</span> PatternSelectFunction&lt;Event, ComplexEvent&gt;() &#123;...&#125;</span><br><span class="line">    );</span><br><span class="line"><span class="comment">// 从结果中提取侧输出流</span></span><br><span class="line">DataStream&lt;String&gt; lateData = result.getSideOutput(lateDataOutputTag);</span><br></pre></td></tr></table></figure>

<p>可以看到，整个处理流程与窗口非常相似。经处理匹配数据得到结果数据流之后，可以调用 .getSideOutput() 方法来提取侧输出流，捕获迟到数据进行额外处理。</p>
<h3 id="CEP-的状态机实现"><a href="#CEP-的状态机实现" class="headerlink" title="CEP 的状态机实现"></a>CEP 的状态机实现</h3><p>Flink CEP 中对复杂事件的检测，关键在模式的定义。我们会发现 CEP 中模式的定义方式比较复杂，而且与正则表达式非常相似：正则表达式在字符串上匹配符合模板的字符序列，而 Flink CEP 则是在事件流上匹配符合模式定义的复杂事件。</p>
<p>前面我们分析过 CEP 检测处理的流程，可以认为检测匹配事件的过程中会有初始(没有任何匹配)、检测中(部分匹配成功)、匹配成功、匹配失败等不同的状态。随着每个事件的到来，都会改变当前检测的状态；而这种改变跟当前事件的特性有关、也跟当前所处的状态有关。这样的系统，其实就是一个状态机(state machine)。这也正是正则表达式底层引擎的实现原理。</p>
<p>所以 Flink CEP 的底层工作原理其实与正则表达式是一致的，是一个非确定有限状态自动机(Nondeterministic Finite Automaton，NFA)。NFA 的原理涉及到较多数学知识，我们这里不做详细展开，而是用一个具体的例子来说明一下状态机的工作方式，以更好地理解 CEP 的原理。</p>
<p>我们回顾一下应用案例，检测用户连续三次登录失败的复杂事件。用 Flink CEP 中的 Pattern API 可以很方便地把它定义出来；如果我们现在不用 CEP，而是用 DataStream API 和处理函数来实现，应该怎么做呢？</p>
<p>这需要设置状态，并根据输入的事件不断更新状态。当然因为这个需求不是很复杂，我们也可以用嵌套的 if-else 条件判断将它实现，不过这样做的代码可读性和扩展性都会很差。更好的方式，就是实现一个状态机。</p>
<p><img src="/Flink/%E6%88%AA%E5%B1%8F2022-07-26%20%E4%B8%8B%E5%8D%885.05.03.png" alt="截屏2022-07-26 下午5.05.03"></p>
<p>如图 12-4 所示，即为状态转移的过程，从初始状态(INITIAL)出发，遇到一个类型为 fail 的登录失败事件，就开始进入部分匹配的状态；目前只有一个 fail 事件，我们把当前状态记作 S1。基于 S1 状态，如果继续遇到 fail 事件，那么就有两个 fail 事件，记作 S2。基于 S2 状态如果再次遇到 fail 事件，那么就找到了一组匹配的复杂事件，把当前状态记作 Matched，就可以输出报警信息了。需要注意的是，报警完毕，需要立即重置状态回 S2；因为如果接下来再遇到 fail 事件，就又满足了新的连续三次登录失败，需要再次报警。</p>
<p>而不论是初始状态，还是 S1、S2 状态，只要遇到类型为 success 的登录成功事件，就会跳转到结束状态，记作 Terminal。此时当前检测完毕，之前的部分匹配应该全部清空，所以需要立即重置状态到 Initial，重新开始下一轮检测。所以这里我们真正参与状态转移的，其实只有 Initial、S1、S2 三个状态，Matched 和 Terminal 是为了方便我们做其他操作(比如输出报警、清空状态)的临时标记状态，不等新事件到来马上就会跳转。</p>
<p>完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NFAExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取登录事件流，这里与时间无关，就不生成水位线了</span></span><br><span class="line">        KeyedStream&lt;LoginEvent, String&gt; stream = env.fromElements(</span><br><span class="line">                        <span class="keyword">new</span> LoginEvent(<span class="string">&quot;user_1&quot;</span>, <span class="string">&quot;192.168.0.1&quot;</span>, <span class="string">&quot;fail&quot;</span>, <span class="number">2000L</span>),</span><br><span class="line">                        <span class="keyword">new</span> LoginEvent(<span class="string">&quot;user_1&quot;</span>, <span class="string">&quot;192.168.0.2&quot;</span>, <span class="string">&quot;fail&quot;</span>, <span class="number">3000L</span>),</span><br><span class="line">                        <span class="keyword">new</span> LoginEvent(<span class="string">&quot;user_2&quot;</span>, <span class="string">&quot;192.168.1.29&quot;</span>, <span class="string">&quot;fail&quot;</span>, <span class="number">4000L</span>),</span><br><span class="line">                        <span class="keyword">new</span> LoginEvent(<span class="string">&quot;user_1&quot;</span>, <span class="string">&quot;171.56.23.10&quot;</span>, <span class="string">&quot;fail&quot;</span>, <span class="number">5000L</span>),</span><br><span class="line">                        <span class="keyword">new</span> LoginEvent(<span class="string">&quot;user_2&quot;</span>, <span class="string">&quot;192.168.1.29&quot;</span>, <span class="string">&quot;success&quot;</span>, <span class="number">6000L</span>),</span><br><span class="line">                        <span class="keyword">new</span> LoginEvent(<span class="string">&quot;user_2&quot;</span>, <span class="string">&quot;192.168.1.29&quot;</span>, <span class="string">&quot;fail&quot;</span>, <span class="number">7000L</span>),</span><br><span class="line">                        <span class="keyword">new</span> LoginEvent(<span class="string">&quot;user_2&quot;</span>, <span class="string">&quot;192.168.1.29&quot;</span>, <span class="string">&quot;fail&quot;</span>, <span class="number">8000L</span>)</span><br><span class="line">                )</span><br><span class="line">                .keyBy(r -&gt; r.userId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将数据依次输入状态机进行处理</span></span><br><span class="line">        DataStream&lt;String&gt; alertStream = stream</span><br><span class="line">                .flatMap(<span class="keyword">new</span> StateMachineMapper());</span><br><span class="line"></span><br><span class="line">        alertStream.print(<span class="string">&quot;warning&quot;</span>);</span><br><span class="line"></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;serial&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StateMachineMapper</span> <span class="keyword">extends</span> <span class="title">RichFlatMapFunction</span>&lt;<span class="title">LoginEvent</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明当前用户对应的状态</span></span><br><span class="line">        <span class="keyword">private</span> ValueState&lt;State&gt; currentState;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration conf)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 获取状态对象</span></span><br><span class="line">            currentState = getRuntimeContext().getState(<span class="keyword">new</span> ValueStateDescriptor&lt;&gt;(<span class="string">&quot;state&quot;</span>, State.class));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(LoginEvent event, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// 获取状态，如果状态为空，置为初始状态</span></span><br><span class="line">            State state = currentState.value();</span><br><span class="line">            <span class="keyword">if</span> (state == <span class="keyword">null</span>) &#123;</span><br><span class="line">                state = State.Initial;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 基于当前状态，输入当前事件时跳转到下一状态</span></span><br><span class="line">            State nextState = state.transition(event.eventType);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nextState == State.Matched) &#123;</span><br><span class="line">                <span class="comment">// 如果检测到匹配的复杂事件，输出报警信息</span></span><br><span class="line">                out.collect(event.userId + <span class="string">&quot; 连续三次登录失败&quot;</span>);</span><br><span class="line">                <span class="comment">// 需要跳转回S2状态，这里直接不更新状态就可以了</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nextState == State.Terminal) &#123;</span><br><span class="line">                <span class="comment">// 如果到了终止状态，就重置状态，准备重新开始</span></span><br><span class="line">                currentState.update(State.Initial);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果还没结束，更新状态（状态跳转），继续读取事件</span></span><br><span class="line">                currentState.update(nextState);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 状态机实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Terminal,    <span class="comment">// 匹配失败，当前匹配终止</span></span><br><span class="line"></span><br><span class="line">        Matched,    <span class="comment">// 匹配成功</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// S2状态</span></span><br><span class="line">        S2(<span class="keyword">new</span> Transition(<span class="string">&quot;fail&quot;</span>, Matched), <span class="keyword">new</span> Transition(<span class="string">&quot;success&quot;</span>, Terminal)),</span><br><span class="line"></span><br><span class="line">        <span class="comment">// S1状态</span></span><br><span class="line">        S1(<span class="keyword">new</span> Transition(<span class="string">&quot;fail&quot;</span>, S2), <span class="keyword">new</span> Transition(<span class="string">&quot;success&quot;</span>, Terminal)),</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始状态</span></span><br><span class="line">        Initial(<span class="keyword">new</span> Transition(<span class="string">&quot;fail&quot;</span>, S1), <span class="keyword">new</span> Transition(<span class="string">&quot;success&quot;</span>, Terminal));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Transition[] transitions;    <span class="comment">// 状态转移规则</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 状态的构造方法，可以传入一组状态转移规则来定义状态</span></span><br><span class="line">        State(Transition... transitions) &#123;</span><br><span class="line">            <span class="keyword">this</span>.transitions = transitions;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 状态的转移方法，根据当前输入事件类型，从定义好的转移规则中找到下一个状态</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> State <span class="title">transition</span><span class="params">(String eventType)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (Transition t : transitions) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t.getEventType().equals(eventType)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> t.getTargetState();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果没有找到转移规则，说明已经结束，回到初始状态</span></span><br><span class="line">            <span class="keyword">return</span> Initial;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义状态转移类，包括两个属性：当前事件类型和目标状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Transition</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 触发状态转移的当前事件类型</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String eventType;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 转移的目标状态</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> State targetState;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Transition</span><span class="params">(String eventType, State targetState)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.eventType = checkNotNull(eventType);</span><br><span class="line">            <span class="keyword">this</span>.targetState = checkNotNull(targetState);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getEventType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> eventType;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> State <span class="title">getTargetState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> targetState;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行代码，可以看到输出与之前 CEP 的实现是完全一样的。显然，如果所有的复杂事件处理都自己设计状态机来实现是非常繁琐的，而且中间逻辑非常容易出错；所以 Flink CEP 将底层 NFA 全部实现好并封装起来，这样我们处理复杂事件时只要调上层的 Pattern API 就可以， 无疑大大降低了代码的复杂度，提高了编程的效率。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/Flume/" rel="prev" title="Flume">
      <i class="fa fa-chevron-left"></i> Flume
    </a></div>
      <div class="post-nav-item">
    <a href="/Redis/" rel="next" title="Redis">
      Redis <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Flink%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">Flink概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%80%A7"><span class="nav-number">1.1.</span> <span class="nav-text">特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B1%82API"><span class="nav-number">1.2.</span> <span class="nav-text">分层API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%83%A8%E7%BD%B2%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.3.</span> <span class="nav-text">部署模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%9A%E8%AF%9D%E6%A8%A1%E5%BC%8F-Session-Mode"><span class="nav-number">1.3.1.</span> <span class="nav-text">会话模式(Session Mode)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E4%BD%9C%E4%B8%9A%E6%A8%A1%E5%BC%8F-Per-Job-Mode"><span class="nav-number">1.3.2.</span> <span class="nav-text">单作业模式(Per-Job Mode)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E6%A8%A1%E5%BC%8F-Application-Mode"><span class="nav-number">1.3.3.</span> <span class="nav-text">应用模式(Application Mode)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8B%AC%E7%AB%8B%E6%A8%A1%E5%BC%8F-Standalone"><span class="nav-number">1.4.</span> <span class="nav-text">独立模式(Standalone)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#YARN-%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.5.</span> <span class="nav-text">YARN 模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"><span class="nav-number">1.6.</span> <span class="nav-text">系统架构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86%E5%99%A8-JobManager"><span class="nav-number">1.6.1.</span> <span class="nav-text">作业管理器(JobManager)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#JobMaster"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">JobMaster</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ResourceManager"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">ResourceManager</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Dispatcher"><span class="nav-number">1.6.1.3.</span> <span class="nav-text">Dispatcher</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8-TaskManager"><span class="nav-number">1.6.2.</span> <span class="nav-text">任务管理器(TaskManager)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E4%B8%9A%E6%8F%90%E4%BA%A4%E6%B5%81%E7%A8%8B"><span class="nav-number">1.6.3.</span> <span class="nav-text">作业提交流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E5%9B%BE-Dataflow-Graph"><span class="nav-number">1.6.4.</span> <span class="nav-text">数据流图(Dataflow Graph)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E8%A1%8C%E5%BA%A6-Parallelism"><span class="nav-number">1.6.5.</span> <span class="nav-text">并行度(Parallelism)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%97%E5%AD%90%E9%93%BE-Operator-Chain"><span class="nav-number">1.6.6.</span> <span class="nav-text">算子链(Operator Chain)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E5%AF%B9%E4%B8%80-one-to-one"><span class="nav-number">1.6.6.1.</span> <span class="nav-text">一对一(one-to-one)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E5%88%86%E5%8C%BA-Redistributing"><span class="nav-number">1.6.6.2.</span> <span class="nav-text">重分区(Redistributing)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%88%E5%B9%B6%E7%AE%97%E5%AD%90%E9%93%BE"><span class="nav-number">1.6.6.3.</span> <span class="nav-text">合并算子链</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%9C%E4%B8%9A%E5%9B%BE-JobGraph-%E4%B8%8E%E6%89%A7%E8%A1%8C%E5%9B%BE-ExecutionGraph"><span class="nav-number">1.6.7.</span> <span class="nav-text">作业图(JobGraph)与执行图(ExecutionGraph)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1-Tasks-%E5%92%8C%E4%BB%BB%E5%8A%A1%E6%A7%BD-Task-Slots"><span class="nav-number">1.6.8.</span> <span class="nav-text">任务(Tasks)和任务槽(Task Slots)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Maven"><span class="nav-number">2.</span> <span class="nav-text">Maven</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WordCount"><span class="nav-number">3.</span> <span class="nav-text">WordCount</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#batch"><span class="nav-number">3.1.</span> <span class="nav-text">batch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bounded-stream"><span class="nav-number">3.2.</span> <span class="nav-text">bounded_stream</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unbounded-stream"><span class="nav-number">3.3.</span> <span class="nav-text">unbounded_stream</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Source"><span class="nav-number">4.</span> <span class="nav-text">Source</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#collection"><span class="nav-number">4.1.</span> <span class="nav-text">collection</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#file"><span class="nav-number">4.2.</span> <span class="nav-text">file</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#socket"><span class="nav-number">4.3.</span> <span class="nav-text">socket</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#kafka"><span class="nav-number">4.4.</span> <span class="nav-text">kafka</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#custom-parallel"><span class="nav-number">4.5.</span> <span class="nav-text">custom_parallel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#custom-source"><span class="nav-number">4.6.</span> <span class="nav-text">custom_source</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Transform"><span class="nav-number">5.</span> <span class="nav-text">Transform</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#map"><span class="nav-number">5.1.</span> <span class="nav-text">map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#richFunction"><span class="nav-number">5.2.</span> <span class="nav-text">richFunction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#flatMap"><span class="nav-number">5.3.</span> <span class="nav-text">flatMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#filter"><span class="nav-number">5.4.</span> <span class="nav-text">filter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#connect"><span class="nav-number">5.5.</span> <span class="nav-text">connect</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#union"><span class="nav-number">5.6.</span> <span class="nav-text">union</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#max-maxBy"><span class="nav-number">5.7.</span> <span class="nav-text">max&#x2F;maxBy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#reduce"><span class="nav-number">5.8.</span> <span class="nav-text">reduce</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#returnType"><span class="nav-number">5.9.</span> <span class="nav-text">returnType</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#tupleAggreation"><span class="nav-number">5.10.</span> <span class="nav-text">tupleAggreation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#process"><span class="nav-number">5.11.</span> <span class="nav-text">process</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#physicalPartitioning"><span class="nav-number">5.12.</span> <span class="nav-text">physicalPartitioning</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PojoAggregation"><span class="nav-number">5.13.</span> <span class="nav-text">PojoAggregation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#udf"><span class="nav-number">5.14.</span> <span class="nav-text">udf</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sink"><span class="nav-number">6.</span> <span class="nav-text">Sink</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#kafka-1"><span class="nav-number">6.1.</span> <span class="nav-text">kafka</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#redis"><span class="nav-number">6.2.</span> <span class="nav-text">redis</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#elasticsearch"><span class="nav-number">6.3.</span> <span class="nav-text">elasticsearch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jdbc"><span class="nav-number">6.4.</span> <span class="nav-text">jdbc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#file-1"><span class="nav-number">6.5.</span> <span class="nav-text">file</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#custome-sink"><span class="nav-number">6.6.</span> <span class="nav-text">custome_sink</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Window"><span class="nav-number">7.</span> <span class="nav-text">Window</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E7%AA%97%E5%8F%A3-Time-Window"><span class="nav-number">7.1.</span> <span class="nav-text">时间窗口(Time Window)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TimeTumbling"><span class="nav-number">7.1.1.</span> <span class="nav-text">TimeTumbling</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TimeSliding"><span class="nav-number">7.1.2.</span> <span class="nav-text">TimeSliding</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TimeSession"><span class="nav-number">7.1.3.</span> <span class="nav-text">TimeSession</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%A1%E6%95%B0%E7%AA%97%E5%8F%A3-Count-Window"><span class="nav-number">7.2.</span> <span class="nav-text">计数窗口(Count Window)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CountTumbling"><span class="nav-number">7.2.1.</span> <span class="nav-text">CountTumbling</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CountSliding"><span class="nav-number">7.2.2.</span> <span class="nav-text">CountSliding</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E7%AA%97%E5%8F%A3-Global-Windows"><span class="nav-number">7.3.</span> <span class="nav-text">全局窗口(Global Windows)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0-Window-Functions"><span class="nav-number">7.4.</span> <span class="nav-text">窗口函数(Window Functions)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A2%9E%E9%87%8F%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0"><span class="nav-number">7.4.1.</span> <span class="nav-text">增量聚合函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ReduceFunction"><span class="nav-number">7.4.1.1.</span> <span class="nav-text">ReduceFunction</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AggregateFunction"><span class="nav-number">7.4.1.2.</span> <span class="nav-text">AggregateFunction</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A8%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="nav-number">7.4.2.</span> <span class="nav-text">全窗口函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#WindowFunction"><span class="nav-number">7.4.2.1.</span> <span class="nav-text">WindowFunction</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ProcessWindowFunction"><span class="nav-number">7.4.2.2.</span> <span class="nav-text">ProcessWindowFunction</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A2%9E%E9%87%8F%E8%81%9A%E5%90%88%E5%92%8C%E5%85%A8%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8"><span class="nav-number">7.4.3.</span> <span class="nav-text">增量聚合和全窗口函数的结合使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96API"><span class="nav-number">7.5.</span> <span class="nav-text">其他API</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8-Trigger"><span class="nav-number">7.5.1.</span> <span class="nav-text">触发器(Trigger)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A7%BB%E9%99%A4%E5%99%A8-Evictor"><span class="nav-number">7.5.2.</span> <span class="nav-text">移除器(Evictor)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%81%E8%AE%B8%E5%BB%B6%E8%BF%9F-Allowed-Lateness"><span class="nav-number">7.5.3.</span> <span class="nav-text">允许延迟(Allowed Lateness)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%A7%E8%BE%93%E5%87%BA%E6%B5%81"><span class="nav-number">7.5.4.</span> <span class="nav-text">侧输出流</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">7.6.</span> <span class="nav-text">窗口的生命周期</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WaterMark"><span class="nav-number">8.</span> <span class="nav-text">WaterMark</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E7%BD%AE%E6%B0%B4%E4%BD%8D%E7%BA%BF%E7%94%9F%E6%88%90%E5%99%A8"><span class="nav-number">8.1.</span> <span class="nav-text">内置水位线生成器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B0%B4%E4%BD%8D%E7%BA%BF"><span class="nav-number">8.2.</span> <span class="nav-text">自定义水位线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EmitWatermarkInSourceFunction"><span class="nav-number">8.3.</span> <span class="nav-text">EmitWatermarkInSourceFunction</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ProcessFunction-API"><span class="nav-number">9.</span> <span class="nav-text">ProcessFunction API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ProcessFunction"><span class="nav-number">9.1.</span> <span class="nav-text">ProcessFunction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KeyedProcessFunction"><span class="nav-number">9.2.</span> <span class="nav-text">KeyedProcessFunction</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8-Timer-%E5%92%8C%E5%AE%9A%E6%97%B6%E6%9C%8D%E5%8A%A1-TimerService"><span class="nav-number">9.2.1.</span> <span class="nav-text">定时器(Timer)和定时服务(TimerService)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#KeyedProcessTopN"><span class="nav-number">9.2.2.</span> <span class="nav-text">KeyedProcessTopN</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ProcessWindowFunction-1"><span class="nav-number">9.3.</span> <span class="nav-text">ProcessWindowFunction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ProcessAllWindowFunction"><span class="nav-number">9.4.</span> <span class="nav-text">ProcessAllWindowFunction</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#ProcessAllWindowTopN"><span class="nav-number">9.4.1.</span> <span class="nav-text">ProcessAllWindowTopN</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CoProcessFunction"><span class="nav-number">9.5.</span> <span class="nav-text">CoProcessFunction</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E6%97%B6%E5%AF%B9%E8%B4%A6"><span class="nav-number">9.5.1.</span> <span class="nav-text">实时对账</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ProcessJoinFunction"><span class="nav-number">9.6.</span> <span class="nav-text">ProcessJoinFunction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BroadcastProcessFunction"><span class="nav-number">9.7.</span> <span class="nav-text">BroadcastProcessFunction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#KeyedBroadcastProcessFunction"><span class="nav-number">9.8.</span> <span class="nav-text">KeyedBroadcastProcessFunction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BE%A7%E8%BE%93%E5%87%BA%E6%B5%81-Side-Output"><span class="nav-number">9.9.</span> <span class="nav-text">侧输出流(Side Output)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%B5%81%E8%BD%AC%E6%8D%A2"><span class="nav-number">10.</span> <span class="nav-text">多流转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%B5%81"><span class="nav-number">10.1.</span> <span class="nav-text">分流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#filter%E5%AE%9E%E7%8E%B0"><span class="nav-number">10.1.1.</span> <span class="nav-text">filter实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%A7%E8%BE%93%E5%87%BA%E6%B5%81-1"><span class="nav-number">10.1.2.</span> <span class="nav-text">侧输出流</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%88%E6%B5%81"><span class="nav-number">10.2.</span> <span class="nav-text">合流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%81%94%E5%90%88-Union"><span class="nav-number">10.2.1.</span> <span class="nav-text">联合(Union)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5-Connect"><span class="nav-number">10.2.2.</span> <span class="nav-text">连接(Connect)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E6%B5%81%E8%81%94%E7%BB%93-Join"><span class="nav-number">10.2.3.</span> <span class="nav-text">双流联结(Join)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E8%81%94%E7%BB%93-Window-Join"><span class="nav-number">10.2.3.1.</span> <span class="nav-text">窗口联结(Window Join)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%97%B4%E9%9A%94%E8%81%94%E7%BB%93-Interval-Join"><span class="nav-number">10.2.3.2.</span> <span class="nav-text">间隔联结(Interval Join)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E5%90%8C%E7%BB%84%E8%81%94%E7%BB%93-Window-CoGroup"><span class="nav-number">10.2.3.3.</span> <span class="nav-text">窗口同组联结(Window CoGroup)</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#State"><span class="nav-number">11.</span> <span class="nav-text">State</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%89%E9%94%AE%E5%88%86%E5%8C%BA%E7%8A%B6%E6%80%81-Keyed-State"><span class="nav-number">11.1.</span> <span class="nav-text">按键分区状态(Keyed State)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%80%BC%E7%8A%B6%E6%80%81-ValueState"><span class="nav-number">11.1.1.</span> <span class="nav-text">值状态(ValueState)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E7%8A%B6%E6%80%81-ListState"><span class="nav-number">11.1.2.</span> <span class="nav-text">列表状态(ListState)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%A0%E5%B0%84%E7%8A%B6%E6%80%81-MapState"><span class="nav-number">11.1.3.</span> <span class="nav-text">映射状态(MapState)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BD%92%E7%BA%A6%E7%8A%B6%E6%80%81-ReducingState"><span class="nav-number">11.1.4.</span> <span class="nav-text">归约状态(ReducingState)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%81%9A%E5%90%88%E7%8A%B6%E6%80%81-AggregatingState"><span class="nav-number">11.1.5.</span> <span class="nav-text">聚合状态(AggregatingState)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E7%94%9F%E5%AD%98%E6%97%B6%E9%97%B4-TTL"><span class="nav-number">11.1.6.</span> <span class="nav-text">状态生存时间(TTL)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%97%E5%AD%90%E7%8A%B6%E6%80%81-Operator-State"><span class="nav-number">11.2.</span> <span class="nav-text">算子状态(Operator State)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%97%E8%A1%A8%E7%8A%B6%E6%80%81-ListState-1"><span class="nav-number">11.2.1.</span> <span class="nav-text">列表状态(ListState)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%81%94%E5%90%88%E5%88%97%E8%A1%A8%E7%8A%B6%E6%80%81-UnionListState"><span class="nav-number">11.2.2.</span> <span class="nav-text">联合列表状态(UnionListState)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%BF%E6%92%AD%E7%8A%B6%E6%80%81-BroadcastState"><span class="nav-number">11.2.3.</span> <span class="nav-text">广播状态(BroadcastState)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E6%8C%81%E4%B9%85%E5%8C%96%E5%92%8C%E7%8A%B6%E6%80%81%E5%90%8E%E7%AB%AF"><span class="nav-number">11.3.</span> <span class="nav-text">状态持久化和状态后端</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E7%82%B9-Checkpoint"><span class="nav-number">11.3.1.</span> <span class="nav-text">检查点(Checkpoint)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E5%90%8E%E7%AB%AF-State-Backends"><span class="nav-number">11.3.2.</span> <span class="nav-text">状态后端(State Backends)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E5%90%8E%E7%AB%AF%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-number">11.3.2.1.</span> <span class="nav-text">状态后端的分类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E6%AD%A3%E7%A1%AE%E7%9A%84%E7%8A%B6%E6%80%81%E5%90%8E%E7%AB%AF"><span class="nav-number">11.3.2.2.</span> <span class="nav-text">如何选择正确的状态后端</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E5%90%8E%E7%AB%AF%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="nav-number">11.3.2.3.</span> <span class="nav-text">状态后端的配置</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%B9%E9%94%99%E6%9C%BA%E5%88%B6"><span class="nav-number">12.</span> <span class="nav-text">容错机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E7%82%B9%E7%9A%84%E4%BF%9D%E5%AD%98"><span class="nav-number">12.1.</span> <span class="nav-text">检查点的保存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%A8%E6%9C%9F%E6%80%A7%E7%9A%84%E8%A7%A6%E5%8F%91%E4%BF%9D%E5%AD%98"><span class="nav-number">12.1.1.</span> <span class="nav-text">周期性的触发保存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%9D%E5%AD%98%E7%9A%84%E6%97%B6%E9%97%B4%E7%82%B9"><span class="nav-number">12.1.2.</span> <span class="nav-text">保存的时间点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%9D%E5%AD%98%E7%9A%84%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B"><span class="nav-number">12.1.3.</span> <span class="nav-text">保存的具体流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E6%A3%80%E6%9F%A5%E7%82%B9%E6%81%A2%E5%A4%8D%E7%8A%B6%E6%80%81"><span class="nav-number">12.2.</span> <span class="nav-text">从检查点恢复状态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%90%AF%E5%BA%94%E7%94%A8"><span class="nav-number">12.2.1.</span> <span class="nav-text">重启应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96%E6%A3%80%E6%9F%A5%E7%82%B9%EF%BC%8C%E9%87%8D%E7%BD%AE%E7%8A%B6%E6%80%81"><span class="nav-number">12.2.2.</span> <span class="nav-text">读取检查点，重置状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E6%94%BE%E6%95%B0%E6%8D%AE"><span class="nav-number">12.2.3.</span> <span class="nav-text">重放数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%A7%E7%BB%AD%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE"><span class="nav-number">12.2.4.</span> <span class="nav-text">继续处理数据</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E7%82%B9%E7%AE%97%E6%B3%95"><span class="nav-number">12.3.</span> <span class="nav-text">检查点算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E7%82%B9%E9%85%8D%E7%BD%AE"><span class="nav-number">12.4.</span> <span class="nav-text">检查点配置</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%AF%E7%94%A8%E6%A3%80%E6%9F%A5%E7%82%B9"><span class="nav-number">12.4.1.</span> <span class="nav-text">启用检查点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E7%82%B9%E5%AD%98%E5%82%A8-Checkpoint-Storage"><span class="nav-number">12.4.2.</span> <span class="nav-text">检查点存储(Checkpoint Storage)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE"><span class="nav-number">12.4.3.</span> <span class="nav-text">其他高级配置</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E7%82%B9%E6%A8%A1%E5%BC%8F-CheckpointingMode"><span class="nav-number">12.4.3.1.</span> <span class="nav-text">检查点模式(CheckpointingMode)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4-checkpointTimeout"><span class="nav-number">12.4.3.2.</span> <span class="nav-text">超时时间(checkpointTimeout)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E9%97%B4%E9%9A%94%E6%97%B6%E9%97%B4-minPauseBetweenCheckpoints"><span class="nav-number">12.4.3.3.</span> <span class="nav-text">最小间隔时间(minPauseBetweenCheckpoints)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%A3%80%E6%9F%A5%E7%82%B9%E6%95%B0%E9%87%8F-maxConcurrentCheckpoints"><span class="nav-number">12.4.3.4.</span> <span class="nav-text">最大并发检查点数量(maxConcurrentCheckpoints)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%80%E5%90%AF%E5%A4%96%E9%83%A8%E6%8C%81%E4%B9%85%E5%8C%96%E5%AD%98%E5%82%A8-enableExternalizedCheckpoints"><span class="nav-number">12.4.3.5.</span> <span class="nav-text">开启外部持久化存储(enableExternalizedCheckpoints)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%9D%E5%AD%98%E7%82%B9-Savepoint"><span class="nav-number">12.5.</span> <span class="nav-text">保存点(Savepoint)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%9D%E5%AD%98%E7%82%B9%E7%9A%84%E7%94%A8%E9%80%94"><span class="nav-number">12.5.1.</span> <span class="nav-text">保存点的用途</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E4%BF%9D%E5%AD%98%E7%82%B9"><span class="nav-number">12.5.2.</span> <span class="nav-text">使用保存点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E4%B8%80%E8%87%B4%E6%80%A7"><span class="nav-number">12.6.</span> <span class="nav-text">状态一致性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E7%AB%AF%E4%BF%9D%E9%9A%9C"><span class="nav-number">12.6.1.</span> <span class="nav-text">输入端保障</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E7%AB%AF%E4%BF%9D%E9%9A%9C"><span class="nav-number">12.6.2.</span> <span class="nav-text">输出端保障</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B9%82%E7%AD%89-idempotent-%E5%86%99%E5%85%A5"><span class="nav-number">12.6.2.1.</span> <span class="nav-text">幂等(idempotent)写入</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1-transactional-%E5%86%99%E5%85%A5"><span class="nav-number">12.6.2.2.</span> <span class="nav-text">事务(transactional)写入</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Flink-%E5%92%8C-Kafka-%E8%BF%9E%E6%8E%A5%E6%97%B6%E7%9A%84%E7%B2%BE%E7%A1%AE%E4%B8%80%E6%AC%A1%E4%BF%9D%E8%AF%81"><span class="nav-number">12.6.3.</span> <span class="nav-text">Flink 和 Kafka 连接时的精确一次保证</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B4%E4%BD%93%E4%BB%8B%E7%BB%8D"><span class="nav-number">12.6.3.1.</span> <span class="nav-text">整体介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4"><span class="nav-number">12.6.3.2.</span> <span class="nav-text">具体步骤</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9C%80%E8%A6%81%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="nav-number">12.6.3.3.</span> <span class="nav-text">需要的配置</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TableAPI%E5%92%8CSQL"><span class="nav-number">13.</span> <span class="nav-text">TableAPI和SQL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B"><span class="nav-number">13.1.</span> <span class="nav-text">简单实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%ACAPI"><span class="nav-number">13.2.</span> <span class="nav-text">基本API</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E6%9E%B6%E6%9E%84"><span class="nav-number">13.2.1.</span> <span class="nav-text">程序架构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%A1%A8%E7%8E%AF%E5%A2%83"><span class="nav-number">13.2.2.</span> <span class="nav-text">创建表环境</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%A1%A8"><span class="nav-number">13.2.3.</span> <span class="nav-text">创建表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E5%99%A8%E8%A1%A8-Connector-Tables"><span class="nav-number">13.2.3.1.</span> <span class="nav-text">连接器表(Connector Tables)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E8%A1%A8-Virtual-Tables"><span class="nav-number">13.2.3.2.</span> <span class="nav-text">虚拟表(Virtual Tables)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%E7%9A%84%E6%9F%A5%E8%AF%A2"><span class="nav-number">13.2.4.</span> <span class="nav-text">表的查询</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C-SQL-%E8%BF%9B%E8%A1%8C%E6%9F%A5%E8%AF%A2"><span class="nav-number">13.2.4.1.</span> <span class="nav-text">执行 SQL 进行查询</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%B0%83%E7%94%A8-Table-API-%E8%BF%9B%E8%A1%8C%E6%9F%A5%E8%AF%A2"><span class="nav-number">13.2.4.2.</span> <span class="nav-text">调用 Table API 进行查询</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%A4%E7%A7%8D-API-%E7%9A%84%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8"><span class="nav-number">13.2.4.3.</span> <span class="nav-text">两种 API 的结合使用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E8%A1%A8"><span class="nav-number">13.2.5.</span> <span class="nav-text">输出表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%E5%92%8C%E6%B5%81%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-number">13.2.6.</span> <span class="nav-text">表和流的转换</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%86%E8%A1%A8-Table-%E8%BD%AC%E6%8D%A2%E6%88%90%E6%B5%81-DataStream"><span class="nav-number">13.2.6.1.</span> <span class="nav-text">将表(Table)转换成流(DataStream)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%86%E6%B5%81-DataStream-%E8%BD%AC%E6%8D%A2%E6%88%90%E8%A1%A8-Table"><span class="nav-number">13.2.6.2.</span> <span class="nav-text">将流(DataStream)转换成表(Table)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%94%AF%E6%8C%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">13.2.6.3.</span> <span class="nav-text">支持的数据类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="nav-number">13.2.6.4.</span> <span class="nav-text">综合应用示例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E5%A4%84%E7%90%86%E4%B8%AD%E7%9A%84%E8%A1%A8"><span class="nav-number">13.3.</span> <span class="nav-text">流处理中的表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A1%A8%E5%92%8C%E6%8C%81%E7%BB%AD%E6%9F%A5%E8%AF%A2"><span class="nav-number">13.3.1.</span> <span class="nav-text">动态表和持续查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8-SQL-%E6%8C%81%E7%BB%AD%E6%9F%A5%E8%AF%A2"><span class="nav-number">13.3.2.</span> <span class="nav-text">用 SQL 持续查询</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0-Update-%E6%9F%A5%E8%AF%A2"><span class="nav-number">13.3.2.1.</span> <span class="nav-text">更新(Update)查询</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%BD%E5%8A%A0-Append-%E6%9F%A5%E8%AF%A2"><span class="nav-number">13.3.2.2.</span> <span class="nav-text">追加(Append)查询</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9F%A5%E8%AF%A2%E9%99%90%E5%88%B6"><span class="nav-number">13.3.2.3.</span> <span class="nav-text">查询限制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%B1%9E%E6%80%A7%E5%92%8C%E7%AA%97%E5%8F%A3"><span class="nav-number">13.4.</span> <span class="nav-text">时间属性和窗口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E6%97%B6%E9%97%B4"><span class="nav-number">13.4.1.</span> <span class="nav-text">事件时间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E6%97%B6%E9%97%B4"><span class="nav-number">13.4.2.</span> <span class="nav-text">处理时间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3"><span class="nav-number">13.4.3.</span> <span class="nav-text">窗口</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E7%BB%84%E7%AA%97%E5%8F%A3-Group-Window%EF%BC%8C%E8%80%81%E7%89%88%E6%9C%AC"><span class="nav-number">13.4.3.1.</span> <span class="nav-text">分组窗口(Group Window，老版本)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E8%A1%A8%E5%80%BC%E5%87%BD%E6%95%B0-Windowing-TVFs%EF%BC%8C%E6%96%B0%E7%89%88%E6%9C%AC"><span class="nav-number">13.4.3.2.</span> <span class="nav-text">窗口表值函数(Windowing TVFs，新版本)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%9A%E5%90%88-Aggregation-%E6%9F%A5%E8%AF%A2"><span class="nav-number">13.5.</span> <span class="nav-text">聚合(Aggregation)查询</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E7%BB%84%E8%81%9A%E5%90%88"><span class="nav-number">13.5.1.</span> <span class="nav-text">分组聚合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3%E8%81%9A%E5%90%88"><span class="nav-number">13.5.2.</span> <span class="nav-text">窗口聚合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%80%E7%AA%97-Over-%E8%81%9A%E5%90%88"><span class="nav-number">13.5.3.</span> <span class="nav-text">开窗(Over)聚合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TopN"><span class="nav-number">13.5.4.</span> <span class="nav-text">TopN</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%99%AE%E9%80%9ATopN"><span class="nav-number">13.5.4.1.</span> <span class="nav-text">普通TopN</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AA%97%E5%8F%A3TopN"><span class="nav-number">13.5.4.2.</span> <span class="nav-text">窗口TopN</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%94%E7%BB%93-Join-%E6%9F%A5%E8%AF%A2"><span class="nav-number">13.6.</span> <span class="nav-text">联结(Join)查询</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E8%A7%84%E8%81%94%E7%BB%93%E6%9F%A5%E8%AF%A2"><span class="nav-number">13.6.1.</span> <span class="nav-text">常规联结查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%B4%E9%9A%94%E8%81%94%E7%BB%93%E6%9F%A5%E8%AF%A2"><span class="nav-number">13.6.2.</span> <span class="nav-text">间隔联结查询</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">13.7.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#UDF"><span class="nav-number">13.7.1.</span> <span class="nav-text">UDF</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UDF%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="nav-number">13.7.2.</span> <span class="nav-text">UDF调用流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E9%87%8F%E5%87%BD%E6%95%B0-Scalar-Functions"><span class="nav-number">13.7.3.</span> <span class="nav-text">标量函数(Scalar Functions)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%E5%87%BD%E6%95%B0-Table-Functions"><span class="nav-number">13.7.4.</span> <span class="nav-text">表函数(Table Functions)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0-Aggregate-Functions"><span class="nav-number">13.7.5.</span> <span class="nav-text">聚合函数(Aggregate Functions)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0-Table-Aggregate-Functions"><span class="nav-number">13.7.6.</span> <span class="nav-text">表聚合函数(Table Aggregate Functions)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SQL%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="nav-number">13.8.</span> <span class="nav-text">SQL客户端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E5%88%B0%E5%A4%96%E9%83%A8%E7%B3%BB%E7%BB%9F"><span class="nav-number">13.9.</span> <span class="nav-text">连接到外部系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Kafka"><span class="nav-number">13.9.1.</span> <span class="nav-text">Kafka</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">13.9.2.</span> <span class="nav-text">文件系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JDBC"><span class="nav-number">13.9.3.</span> <span class="nav-text">JDBC</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Elasticsearch"><span class="nav-number">13.9.4.</span> <span class="nav-text">Elasticsearch</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HBase"><span class="nav-number">13.9.5.</span> <span class="nav-text">HBase</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Hive"><span class="nav-number">13.9.6.</span> <span class="nav-text">Hive</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Flink-CEP"><span class="nav-number">14.</span> <span class="nav-text">Flink CEP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">14.1.</span> <span class="nav-text">基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F-Pattern"><span class="nav-number">14.1.1.</span> <span class="nav-text">模式(Pattern)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B"><span class="nav-number">14.2.</span> <span class="nav-text">快速上手</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8FAPI-Pattern-API"><span class="nav-number">14.3.</span> <span class="nav-text">模式API(Pattern API)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AA%E4%BD%93%E6%A8%A1%E5%BC%8F"><span class="nav-number">14.3.1.</span> <span class="nav-text">个体模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8F%E8%AF%8D-Quantifiers"><span class="nav-number">14.3.1.1.</span> <span class="nav-text">量词(Quantifiers )</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6-Conditions"><span class="nav-number">14.3.1.2.</span> <span class="nav-text">条件(Conditions)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="nav-number">14.3.2.</span> <span class="nav-text">组合模式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E7%BB%84"><span class="nav-number">14.3.3.</span> <span class="nav-text">模式组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8C%B9%E9%85%8D%E5%90%8E%E8%B7%B3%E8%BF%87%E7%AD%96%E7%95%A5"><span class="nav-number">14.3.4.</span> <span class="nav-text">匹配后跳过策略</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%A3%80%E6%B5%8B%E5%A4%84%E7%90%86"><span class="nav-number">14.4.</span> <span class="nav-text">模式的检测处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%86%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8%E5%88%B0%E6%B5%81%E4%B8%8A"><span class="nav-number">14.4.1.</span> <span class="nav-text">将模式应用到流上</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%8C%B9%E9%85%8D%E4%BA%8B%E4%BB%B6"><span class="nav-number">14.4.2.</span> <span class="nav-text">处理匹配事件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8C%B9%E9%85%8D%E4%BA%8B%E4%BB%B6%E7%9A%84%E9%80%89%E6%8B%A9%E6%8F%90%E5%8F%96-select"><span class="nav-number">14.4.2.1.</span> <span class="nav-text">匹配事件的选择提取(select)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8C%B9%E9%85%8D%E4%BA%8B%E4%BB%B6%E7%9A%84%E9%80%9A%E7%94%A8%E5%A4%84%E7%90%86-process"><span class="nav-number">14.4.2.2.</span> <span class="nav-text">匹配事件的通用处理(process)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E8%B6%85%E6%97%B6%E4%BA%8B%E4%BB%B6"><span class="nav-number">14.4.3.</span> <span class="nav-text">处理超时事件</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-PatternProcessFunction"><span class="nav-number">14.4.3.1.</span> <span class="nav-text">使用 PatternProcessFunction</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-PatternTimeoutFunction"><span class="nav-number">14.4.3.2.</span> <span class="nav-text">使用 PatternTimeoutFunction</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="nav-number">14.4.3.3.</span> <span class="nav-text">应用实例</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E8%BF%9F%E5%88%B0%E6%95%B0%E6%8D%AE"><span class="nav-number">14.4.4.</span> <span class="nav-text">处理迟到数据</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CEP-%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%BA%E5%AE%9E%E7%8E%B0"><span class="nav-number">14.5.</span> <span class="nav-text">CEP 的状态机实现</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Vincent"
      src="/images/cute.jpeg">
  <p class="site-author-name" itemprop="name">Vincent</p>
  <div class="site-description" itemprop="description">nice</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">19</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Vincent</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
